

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/helloworld/img/icon/log_1.png">
  <link rel="icon" href="/helloworld/img/icon/log_1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="C1thulhu">
  <meta name="keywords" content="">
  
    <meta name="description" content="集合类是Java数据结构的实现，是java.util包中的重要内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合">
<meta property="og:url" content="https://c1thulhu.github.io/helloworld/notes/Java/API/Java%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="C1thulhu">
<meta property="og:description" content="集合类是Java数据结构的实现，是java.util包中的重要内容。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_CVP/Collection&Map.png">
<meta property="article:published_time" content="2022-05-11T00:00:00.000Z">
<meta property="article:modified_time" content="2022-09-30T00:00:00.000Z">
<meta property="article:author" content="C1thulhu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JDK">
<meta property="article:tag" content="API">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_CVP/Collection&Map.png">
  
  
  <title>Java集合 - C1thulhu</title>

  <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github-dark-dimmed.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/helloworld/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"c1thulhu.github.io","root":"/helloworld/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/helloworld/local-search.xml"};
  </script>
  <script  src="/helloworld/js/utils.js" ></script>
  <script  src="/helloworld/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/helloworld/">
      <strong>C1thulhu</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/helloworld/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/helloworld/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/helloworld/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/helloworld/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/helloworld/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/helloworld/img/background/Collection&Map.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.1)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java集合">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-11 00:00" pubdate>
        2022-05-11
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java集合</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022-09-30
                
              </p>
            
            <div class="markdown-body">
              <h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2>
<p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.kyire.site//2021/07/02/13a54546.html">Java中的集合</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-collections.html">菜鸟驿站-Java 集合框架</a></li>
<li>Map
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_54361971/article/details/122430827">HashMap详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40050586/article/details/105851970">LinkedHashMap详解</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268025265">HashTable</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013467442/article/details/105826778">WeakHashMap</a></li>
</ul>
</li>
<li>Queue
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lucklycoder/article/details/115381856">ArrayDeque类详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lxyit/p/9052962.html">PriorityQueue详解</a></li>
</ul>
</li>
<li>Set
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44549134/article/details/109059724">TreeSet</a></li>
</ul>
</li>
<li>集合工具类
<ul>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java-listiterator.html">易百教程-listiterator接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yiibai.com/java/java_using_iterator.html">易百教程-iterator接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1299919855943714">Collections使用</a></li>
</ul>
</li>
</ul>
<h2 id="java集合体系"><a class="markdownIt-Anchor" href="#java集合体系"></a> #Java集合体系</h2>
<p>  Java 集合框架主要包括两种类型的容器，一种是**<code>Collection</code><strong>，存储一个元素集合，另一种是</strong><code>Map</code>**。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-linkedlist.html">LinkedList</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashset.html">HashSet</a>、LinkedHashSet、<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap.html">HashMap</a>、LinkedHashMap 等等。</p>
<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>
<ul>
<li>**接口：**是代表<b style="color:red">集合的抽象数据类型</b>。例如 Collection、List、Set、Map 等。<b style="color:#00FFFF">之所以定义多个接口，是为了以不同的方式操作集合对象。</b></li>
<li>**实现（类）：**是<b style="color:red">集合接口的具体实现</b>。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li>
<li>**算法：**是实现<b style="color:red">集合接口的对象里的方法执行的一些有用的计算</b>，例如：搜索和排序。<b style="color:#00FFFF">这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现</b>。</li>
</ul>
<p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB.png" srcset="/helloworld/img/loading.gif" lazyload alt="Java集合体系" /></p>
<p><strong>体系概述：</strong></p>
<blockquote>
<ul>
<li>整个集合框架分为两个类型：<code>Collection</code> 和 <code>Map</code>，前者是存储一系列的<strong>对象</strong>；后者是存储一系列的<strong>键值对</strong>。</li>
<li>在集合框架体系下，衍生出四种具体的集合类型：<code>Map</code>、<code>Set</code>、<code>List</code>、<code>Queue</code></li>
</ul>
</blockquote>
<h2 id="体系详解"><a class="markdownIt-Anchor" href="#体系详解"></a> #体系详解</h2>
<h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h3>
<p><code>map</code>接口定义了<b style="color:red">存储的数据结构是<code>&lt;key,value&gt;</code> 形式</b>，根据 key 映射到 value，一个 key 对应一个 value，所以 <code>key</code> 不可重复，而 <code>value</code> 可重复，key 和 value 都可以是任何引用类型的数据。</p>
<p>在 <code>Map</code> 接口下会将存储的方式细分为不同的种类：</p>
<blockquote>
<ul>
<li><code>SortedMap</code> 接口：该接口映射可以对 <code>&lt;key,value&gt;</code> 按照自己的规则进行 <strong>排序</strong>，具体实现有 TreeMap。</li>
<li><code>AbstractMap</code> 类：它为子类提供好一些 <strong>通用的API实现</strong>，所有的具体 Map 都会继承它。</li>
</ul>
</blockquote>
<h4 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h4>
<p>  <b style="color:red">HashMap 是一个 最通用的 利用哈希表存储<code>&lt;key,value&gt;</code>元素的集合</b>，将元素放入 HashMap 时，将 <code>key</code> 的哈希值转换为数组的 <code>索引</code> 下标 <strong>确定存放位置</strong>，查找时，根据 <code>key</code> 的哈希地址转换成数组的 <code>索引</code> 下标 <strong>确定查找位置</strong>。HashMap 的实现不是同步的，这意味着它不是线程安全的。<b style="color:#00FFFF">它的 key、value 都可以为 null</b>，此外，HashMap 中的映射不是有序的。</p>
<blockquote>
<ul>
<li><strong>底层结构</strong>：JDK1.8 之前 HashMap 由 数组 + 单向链表 组成，数组是 HashMap 的主体，单向链表则是主要为了解决<font style="color:#00FFFF">哈希冲突（两个不相等的key产生了相等的哈希值）</font >而存在的（&quot;<font style="color:yellow">拉链法<sup>1</sup></font>&quot;解决冲突）。<font style="color:red">JDK1.8 以后在解决哈希冲突时有了较大的变化，当单向链表长度大于阈值（默认为 8 ）并且当前数组的长度大于 64 时，此时此索引位置上的所有数据改为使用红黑树存储。</font ></li>
<li><strong>扩充机制</strong>：<font style="color:red">HashMap扩充的两个重要元素<code>Capacity</code>(HashMap当前长度)和<code>LoadFactory</code>(负载因子，默认值为<strong>0.75f</strong>)</font>。<font style="color:#00FFFF">当存入第<code>Capacity</code>*<code>LoadFactory</code>+1个元素时就会进行<code>resize</code>(扩容)。扩容会创建一个新的Entry空数组，长度是原来的2倍；然后遍历原<code>Entry</code>数组，把所有的<code>Entry</code>重新<code>hash</code>(长度扩大后，hash的规则也会随之改变)到新数组。</font></li>
<li><strong>Hash算法</strong>：…</li>
</ul>
<p><font style="color:yellow">①：将链表和数组相结合，创建的链表数组中，数组的每一格就是一个链表，<strong>当发生哈希冲突时，将冲突的值加到链表中。</strong></font></p>
</blockquote>
<h4 id="linkedhashmap"><a class="markdownIt-Anchor" href="#linkedhashmap"></a> LinkedHashMap</h4>
<p>  LinkedHashMap 可以看作是 <code>HashMap</code> 和 <code>LinkedList</code> 的结合：它<font style="color:red">在 HashMap 的基础上添加了一条双向链表</font>，<code>默认</code> 存储各个元素的插入顺序，但由于这条双向链表，使得 LinkedHashMap 可以实现 <b style="color:yellow"><code>LRU</code> 缓存淘汰策略<sup>2</sup></b>，因为我们可以设置这条双向链表按照 <code>元素的访问次序</code> 进行排序。</p>
<p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/LinkedHashMap%E7%BB%93%E6%9E%84.png" srcset="/helloworld/img/loading.gif" lazyload alt="LinkedHashMap结构" /></p>
<blockquote>
<ul>
<li>底层维护了一条 <code>双向链表</code>，因为继承了 HashMap，所以不是线程安全的。</li>
<li>LinkedHashMap 可实现 <code>LRU</code> 缓存淘汰策略，其原理是通过设置 <code>accessOrder</code> 为 <code>true</code> 并重写 <code>removeEldestEntry</code> 方法定义淘汰元素时需满足的条件。</li>
</ul>
</blockquote>
<p><font style="color:yellow"> ②：LRU缓存淘汰策略 简要来说就是当内存满了将优先删除长时间未使用的数据。</font></p>
<h4 id="treemap"><a class="markdownIt-Anchor" href="#treemap"></a> TreeMap</h4>
<p>  TreeMap 是 <code>SortedMap</code> 的子类，所以它<font style="color:red">具有 排序 功能</font>。它是基于 红黑树 数据结构实现的，每一个键值对 <code>&lt;key,value&gt;</code> 都是一个节点，<strong>默认情况下按照 <code>key</code> 自然排序(放入的Key必须实现<code>Comparable</code>接口)，另一种是可以通过传入定制的 <code>Comparator</code> 进行自定义规则排序</strong>。</p>
<ul>
<li>
<p><strong>自然排序</strong>：要求 <code>key</code> 必须实现 <code>Comparable</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">TreeMap&lt;Integer,String&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>treeMap.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;TWO&quot;</span>);<br>treeMap.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ONE&quot;</span>);<br>System.out.print(treeMap);<br></code></pre></div></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">&#123;1=ONE,2=TWO&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><strong>定制排序</strong>：在初始化 TreeMap 时传入新的 <code>Comparator</code>，不要求 <code>key</code> 实现 Comparable 接口</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">TreeMap&lt;Integer,String&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;((o1,o2) -&gt; Integer.compare(o2,o1));<br>treeMap.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;TWO&quot;</span>);<br>treeMap.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ONE&quot;</span>);<br>treeMap.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Three&quot;</span>);<br>treeMap.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;Four&quot;</span>);<br>System.out.print(treeMap);<br></code></pre></div></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">&#123;4=Four, 3=Three, 2=TWO, 1=ONE&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> HashTable</h4>
<p> HashTable和HashMap很相似，其底层的存储结构是 数组+单向链表 ，主要不同的是<strong>HashTable是线程安全的</strong>，很多方法都被<code>synchronized</code>修饰，但同时因为加锁导致并发效率低下，单线程环境效率也十分低；也是由于性能问题HashTable已经被淘汰。</p>
<p><strong>与HashMap的区别</strong>：</p>
<blockquote>
<p><strong>扩容机制</strong>：HashMap创建一个为原先2倍的数组，然后对原数组进行遍历以及rehash；HashTable扩容将创建一个原长度2倍的数组，再使用头插法将链表进行反序；</p>
<p><strong>结构区别</strong>：HashMap是由数组+链表形成，在JDK1.8之后链表长度大于8时转化为红黑树；而HashTable一直都是数组+链表；</p>
<p><strong>线程安全</strong>：Hashtable是多线程安全的，HashMap不是；</p>
<p><strong>遍历方式</strong>：HashMap仅支持<code>Iterator</code>的遍历方式，Hashtable支持<code>Iterator</code>和<code>Enumeration</code>两种遍历方式；</p>
<p><strong>继承关系</strong>：HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作；</p>
<p><strong>存储值</strong>：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。</p>
</blockquote>
<h4 id="weakhashmap"><a class="markdownIt-Anchor" href="#weakhashmap"></a> WeakHashMap</h4>
<p>  WeakHashMap 日常开发中比较少见，它是基于普通的 <code>Map</code> 实现的，而里面 <font style="color:red"><code>Entry</code> 中的键在每一次的 <code>垃圾回收</code> 都会被清除掉，所以非常适合用于存储 <strong>短暂访问</strong>、<strong>仅访问一次</strong> 的元素</font>。</p>
<p><font style="color:#00FFFF">WeakHashMap 内部维护了一个引用队列<code>queue</code></font>。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Reference queue for cleared WeakEntries</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br></code></pre></div></td></tr></table></figure>
<p><font style="color:#00FFFF">这个 <code>queue</code>里包含了所有被 <code>GC</code> 掉的键，当JVM开启 <code>GC</code> 后，如果回收掉 WeakHashMap 中的 key，会将 key 放入 queue 中，在 <code>expungeStaleEntries()</code> 中遍历 queue，把 queue 中的所有 <code>key</code> 拿出来，并在 WeakHashMap 中删除掉，以达到 <strong>同步</strong></font >。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Expunges stale entries from the table.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Object x; (x = queue.poll()) != <span class="hljs-literal">null</span>; ) &#123;<br>            <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, table.length);<br><br>                Entry&lt;K,V&gt; prev = table[i];<br>                Entry&lt;K,V&gt; p = prev;<br>                <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>                    Entry&lt;K,V&gt; next = p.next;<br>                    <span class="hljs-keyword">if</span> (p == e) &#123;<br>                        <span class="hljs-keyword">if</span> (prev == e)<br>                            table[i] = next;<br>                        <span class="hljs-keyword">else</span><br>                            prev.next = next;<br>                        <span class="hljs-comment">// Must not null out e.next;</span><br>                        <span class="hljs-comment">// stale entries may be in use by a HashIterator</span><br>                        e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help GC</span><br>                        size--;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    prev = p;<br>                    p = next;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<ul>
<li>WeakHashMap的键是一种<b style="color:yellow"> <code>弱键</code><sup>3</sup></b>，放入 WeakHashMap 时，随时会被回收掉，所以不能确保某次访问元素一定存在。</li>
<li>它依赖普通的 <code>Map</code> 进行实现，是一个<strong>非线程安全的集合。</strong></li>
<li>WeakHashMap 通常作为 <strong>缓存</strong> 使用，适用存储那些 <code>只需访问一次</code>、或 <code>只需保存短暂时间</code> 的键值对。</li>
</ul>
</blockquote>
<p><font style="color:yellow"> ③：弱键 （<code>WeakReference</code>）:又称弱引用，被WeakReference引用时，在下个垃圾收集周期时该对象就会被回收。</font><br />
<font style="color:yellow">扩展：</font><br />
<font style="color:yellow">- 软引用（<code>SoftReference</code>）:被<code>SoftReference</code>指向的对象可能会被垃圾收集器回收，但是只有在JVM内存不够的情况下才会回收。</font><br />
<font style="color:yellow">- 强引用（<code>StrongReference</code>）:被强引用指向的对象，绝对不会被垃圾收集器回收。</font></p>
<h3 id="collection"><a class="markdownIt-Anchor" href="#collection"></a> Collection</h3>
<p><code>Collection</code> 接口为其实现其接口的集合提供了 <strong>通用方法</strong>：</p>
<ul>
<li>添加方法：<code>add(E e)</code> / <code>addAll(Collection&lt;? extends E&gt; c)</code></li>
<li>删除方法：<code>remove(Object o)</code> / <code>removeAll(Collection&lt;?&gt; c)</code></li>
<li>查找方法：<code>contains(Object o)</code> / <code>containsAll(Collection&lt;?&gt; c)</code></li>
<li>查询集合自身信息；<code>size()</code> / <code>isEmpty()</code></li>
<li>···</li>
</ul>
<h4 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h4>
<p><code>List</code>接口直接继承于 Collection 接口，它定义为<font style="color:red">可以存储 <strong>重复</strong> 元素的集合，并且元素按照插入顺序 <strong>有序排列</strong>，且可以通过 <strong>索引</strong>访问指定位置的元素。</font>常见的实现有：<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code> 和 <code>Stack</code>。</p>
<p>List接口下也细分有不同的种类：</p>
<blockquote>
<ul>
<li><code>AbstractList</code>类：<font style="color:#00FFFF">内部实现了所有的 List 都需具备的功能</font>，子类可以专注于实现自己具体的操作逻辑。</li>
<li><code>AbstractSequentialList</code>类：<code>AbstractSequentialList</code> 继承了 <code>AbstractList</code>，在其原基础上<font style="color:#00FFFF">限制了访问元素的顺序 <strong>只能够按照顺序访问</strong>，而 <strong>不支持随机访问</strong></font>，如果需要满足随机访问的特性，则继承 AbstractList。</li>
</ul>
</blockquote>
<h5 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h5>
<p><font style="color:red">ArrayList 以 <strong>数组</strong> 作为存储结构，但长度不受限制(自动扩容)的集合</font>，所以它除了线程不安全这一点，其余可以替代 <code>Vector</code> ，而线程安全的 ArrayList 可以使用 <code>CopyOnWriteArrayList</code> 代替 Vector。</p>
<blockquote>
<ul>
<li><strong>底层结构</strong>：ArrayList 底层是使用数组作为存储结构，具有 <strong>查找快、增删慢、随机访问</strong> 的特点</li>
<li><strong>扩容机制</strong>：ArrayList <strong>首次扩容</strong>后其核心数组的长度为 <strong>10</strong>，集合从 <strong>第二次扩容</strong> 开始，数组长度将扩容为原来的 <strong>1.5</strong> 倍</li>
</ul>
</blockquote>
<h5 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h5>
<p><font style="color:red">LinkedList 底层采用 <strong>双向链表</strong> 数据接口存储元素，由于链表的内存地址 <strong>非连续</strong>，所以它不具备随机访问的特点，但由于它利用指针连接各个元素，所以插入、删除元素只需要 <strong>操作指针</strong>，不需要 <strong>移动元素</strong>，故具有 <strong>增删快、查询慢</strong> 的特点。</font>它也是一个<strong>非线程安全</strong>的集合。</p>
<p>LinkedList实现了 <code>Deque</code> 接口，使得 LinkedList 可以用作 <strong>双端队列</strong> 。<code>Node</code> 是LinkedList集合中的元素，提供了前驱指针和后继指针，还提供了一系列操作 <code>头结点</code> 和 <code>尾结点</code> 的方法，具有双端队列的特性。</p>
<p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/LinkedList%E7%BB%93%E6%9E%84.png" srcset="/helloworld/img/loading.gif" lazyload alt="LinkedList结构" /></p>
<p>双向链表存储的每个节点称为一个 <code>Node</code> ， <code>Node</code> 中保存了 <code>next</code> 和 <code>prev</code> 指针，<code>item</code> 是该节点的值。在插入和删除时，时间复杂度都保持为 <code>O(1)</code></p>
<blockquote>
<ul>
<li>
<p>优势：<font style="color:red">LinkedList 底层没有 <code>扩容机制</code>，使用 <code>双向链表</code> 存储元素，所以插入和删除元素效率较高，适用于频繁操作元素的场景。</font></p>
</li>
<li>
<p>劣势：<font style="color:red">LinkedList 不具备 <code>随机访问</code> 的特点，查找某个元素只能从 <code>head</code> 或 <code>tail</code> 指针一个一个比较，所以 <strong>查找中间元素是效率很低</strong>。</font></p>
</li>
<li>
<p>查找优化：LinkedList 查找某个下标 <code>index</code> 的元素时做了优化，若 <code>index &lt; (size / 2)</code>，则从 <code>head</code> 往后查找，否则从 <code>tail</code> 开始往前查找，代码如下所示：</p>
  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 查找的下标处于链表的前半部分则从头开始找</span><br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 查找的下标处于链表的后半部分则从尾开始找</span><br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h5 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> Vector</h5>
<p><code>Vector</code> 已经是一种过时的集合了，包括继承它的 <code>Stack</code> 集合也是如此，它们都同<code>HashTable</code>一样被淘汰的原因都是因为 <strong>性能</strong> 低下。</p>
<blockquote>
<p>JDK 1.0 时代，ArrayList 还没诞生，大家都是使用 Vector 集合，但由于 Vector 的 <strong>每个操作</strong> 都被 <strong>synchronized</strong> 关键字修饰，即使在线程安全的情况下， 仍然 <strong>进行着无意义的加锁/释放锁</strong>，造成额外的性能开销，做了无用功。</p>
</blockquote>
<h5 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> Stack</h5>
<p><font style="color:red"><code>Stack</code> 是一种 <code>后进先出（LIFO）</code> 型的集合容器。</font>如下图所示，<font style="color:#00FFFF">top 指针指向最后进入容器的元素。弹出元素时会将先栈顶元素开始移除。</font>Stack 继承了 Vector 类，提供了栈顶的压入元素操作（push）和弹出元素（pop），以及查看栈顶元素（peek）等等，但也是由于继承于 Vector，Stack 也渐渐被淘汰了。</p>
<p>取而代之的是 <code>Deque</code> 接口下的<code>ArrayDeque</code>，该数据结构更加完善，可靠性更好，依靠队列也可以实现 <code>LIFO</code> 的栈操作，所以优先选择 ArrayDeque 实现栈。</p>
<p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Stack%E7%BB%93%E6%9E%84.png" srcset="/helloworld/img/loading.gif" lazyload alt="Stack结构" /></p>
<h4 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h4>
<p>队列是一种特殊的线性表，遵循先进先出、后进后出的基本原则，一般来说，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，但是java的某些队列运行在任何地方插入删除；</p>
<p>Queue 中提供了两套增加、删除元素的 API，当插入或删除元素失败时，会有两种不同的失败处理策略。</p>
<table>
<thead>
<tr>
<th>方法及失败策略</th>
<th>插入方法</th>
<th>删除方法</th>
<th>查找方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>抛出异常</td>
<td>add()</td>
<td>remove()</td>
<td>get()</td>
</tr>
<tr>
<td>返回失败默认值</td>
<td>offer()</td>
<td>poll()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>add()</code> 和 <code>offer()</code> 对比：</p>
<p>在队列长度大小确定的场景下，队列放满元素后，添加下一个元素时，add() 会抛出 <code>IllegalStateException</code> 异常，而 <code>offer()</code> 会返回 <code>false</code>。但是他们两个方法在插入 <strong>某些不合法的元素</strong> 时会抛出三个相同的异常：<code>ClassCastExceptioin</code>,<code>NullPointerException</code>,<code>IllegalArgumentException</code>。</p>
</li>
<li>
<p><code>remove()</code> 和 <code>poll()</code> 对比：</p>
<p>在 <strong>队列为空</strong> 的场景下：<code>remove()</code> 会抛出 <code>NoSuchElmentException</code> 异常，而 <code>poll()</code> 则返回 <code>null</code>。</p>
</li>
<li>
<p><code>get()</code> 和 <code>peek()</code> 对比：</p>
<p>在队列为空的情况，<code>get()</code> 会抛出 <code>NoSuchElementException</code> 异常，而 <code>peek()</code> 则返回 <code>null</code>。</p>
</li>
</ul>
<p>Queue接口下可以细分不同的种类：</p>
<blockquote>
<ul>
<li>
<p><code>Deque</code>接口：<font style="color:#00FFFF">表示双端队列（Double-ended queue），同时具备 <strong>队列</strong> 和 <strong>栈</strong> 的性质。</font>双端队列可以在头尾都具有入队和出队的功能，即双端队列则可以分别从两端插入元素、两端移除元素。</p>
</li>
<li>
<p><code>AbstractQueue</code>类：AbstractQueue 类中提供了各个 API 的基本实现，主要针对各个不同的处理策略给出基本的方法实现，定义在这里的作用让 子类 根据其 方法规范 （操作失败时抛出异常还是返回默认值）实现具体的业务逻辑。</p>
</li>
</ul>
</blockquote>
<h5 id="linkedlist-2"><a class="markdownIt-Anchor" href="#linkedlist-2"></a> LinkedList</h5>
<p>上文已经解释过LinkedList实现了<code>Deque</code> 接口，提供了针对头结点和尾结点的操作，并且每个结点都有 <strong>前驱</strong> 和 <strong>后继</strong> 指针，具备双向队列的所有特性。</p>
<h5 id="arraydeque"><a class="markdownIt-Anchor" href="#arraydeque"></a> ArrayDeque</h5>
<p><code>ArrayDeque</code>是由数组组成的双端队列，它是 <strong>无界</strong> 的双端队列，最小的容量是 <code>8</code> （JDK1.8）。在 JDK11 之后默认容量是 <code>16</code>。</p>
<p>ArrayDeque可以当作栈，也可以当作队列；<font style="color:#00FFFF">作为栈时比 Stack 性能好，作为队列时比 LinkedList 性能好</font>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean add(E e)</td>
<td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>在队列尾部添加一个元素</td>
</tr>
<tr>
<td style="text-align:center">boolean offer(E e)</td>
<td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>在队列尾部添加一个元素，并返回是否成功</td>
</tr>
<tr>
<td style="text-align:center">E poll()</td>
<td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</td>
</tr>
<tr>
<td style="text-align:center">E element()</td>
<td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>获取第一个元素，如果没有将抛出异常</td>
</tr>
<tr>
<td style="text-align:center">E peek()</td>
<td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>获取第一个元素，如果返回null</td>
</tr>
<tr>
<td style="text-align:center">void push(E e)</td>
<td style="text-align:center"><font style="color:#00FFFF">(栈操作)</font>栈顶添加一个元素</td>
</tr>
<tr>
<td style="text-align:center">E pop()</td>
<td style="text-align:center"><font style="color:#00FFFF">(栈操作)</font>移除栈顶元素,如果栈顶没有元素将抛出异常</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><strong>底层结构</strong>：数组 + 双向队列，ArrayDeque的出队入队是通过头尾指针循环，利用数组实现的。</li>
<li><strong>扩容机制</strong>：ArrayDeque容量不足时是会扩容的，每次扩容容量增加一倍。</li>
</ul>
</blockquote>
<h5 id="priorityqueue"><a class="markdownIt-Anchor" href="#priorityqueue"></a> PriorityQueue</h5>
<p>PriorityQueue 基于 <strong>优先级堆实现</strong> 的优先级队列。这里的<strong>优先</strong>是指：<b style="color:red">根据某种规则将队列元素进行排序，每次出队时总是取出排序中的最大或者最小元素，这样的特性决定优先队列不完全遵循FIFO规则，其中排序规则可以决策元素的优先级。</b></p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTest</span>()</span> &#123;<br>    Queue&lt;Integer&gt; random = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>    <span class="hljs-comment">//按2，1，3的顺序添加元素</span><br>    random.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>); random.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>); random.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);<br>    System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;输出：&quot;</span> );<br>    <span class="hljs-built_in">int</span> rs = random.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; rs; i++) &#123;<br>       System.<span class="hljs-keyword">out</span>.print(random.<span class="hljs-keyword">remove</span>() + <span class="hljs-string">&quot;,&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上述代码按照FIFO规则结果应该是：输出：2,1,3,</p>
<p>然而实际输出：输出：</p>
<figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">1,2,3,<br></code></pre></div></td></tr></table></figure>
<p><code>PriorityQueue</code>会按照自然顺序对元素进行排序，它要求元素实现 <code>Comparable</code> 接口，所以 <code>PriorityQueue</code> <strong>不允许存储 NULL 元素</strong>。</p>
<blockquote>
<ul>
<li><strong>底层结构</strong>：基于 优先级堆实现 的优先级队列，而堆是采用 <strong>数组</strong> 实现的。</li>
<li><strong>扩容机制</strong>：实例化时若未指定初始容量，默认容量为11。如果容量小于64，两倍增长扩容；否则增长50%。</li>
</ul>
</blockquote>
<h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4>
<p><code>Set</code> 接口继承了 <code>Collection</code> 接口，是一个<b style="color:red">不包括重复元素</b>的集合，更确切地说，Set 中任意两个元素不会出现 <code>o1.equals(o2)</code>为<code>true</code>的情况，而且 Set <strong>至多</strong> 只能存储一个 <code>null</code> 值元素。</p>
<p>Set接口下细分的种类：</p>
<blockquote>
<ul>
<li>
<p><code>SortedSet</code> 接口：在 Set 的基础上扩展了 <strong>排序</strong> 的行为，所以所有实现它的子类都会拥有排序功能。</p>
</li>
<li>
<p><code>AbstractSet</code> 抽象类：定义在这里的方法可以将所有具体 Set 集合的 <strong>相同行为</strong> 在这里实现，<strong>避免子类包含大量的重复代码。</strong></p>
</li>
</ul>
</blockquote>
<h5 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h5>
<p><font style="color:red"><code>HashSet</code>是<code>Set</code>的实现类，自然其中<strong>不能存储相同的数据</strong>，存储数据时是无序的。而且HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。</font>HashSet 底层是借助 <code>HashMap</code> 实现，HashSet 中又没有额外添加同步策略所以HashSet 也是 <strong>线程不安全</strong>。</p>
<p>观察它的多个构造方法，本质上都是 new 一个 HashMap。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(Math.max((<span class="hljs-type">int</span>) (c.size()/<span class="hljs-number">.75f</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">16</span>));<br>        addAll(c);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity);<br>    &#125;<br><br>    HashSet(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">boolean</span> dummy) &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<p>其次还能看到一个 <strong>静态常量</strong><code>PRESENT</code>：使用 PRESENT 作为 HashMap 的 value 值，使用 HashSet 的开发者只需要 <strong>关注</strong> 插入的 <code>key</code>，<strong>屏蔽</strong> 了其中 HashMap 的 <code>value</code>。</p>
<blockquote>
<ul>
<li>底层数据结构： HashSet 和 HashMap 一样也是采用 <code>数组 + 链表 + 红黑树</code> 实现</li>
<li>存入 HashSet 的对象的状态 <strong>最好不要发生变化</strong>，因为有可能改变状态后，在集合内部出现两个元素 <code>o1.equals(o2) == true</code>，破坏了 <code>equals</code> 的含义。</li>
</ul>
</blockquote>
<h5 id="linkedhashset"><a class="markdownIt-Anchor" href="#linkedhashset"></a> LinkedHashSet</h5>
<p><font style="color:#00FFFF"><code>LinkedHashSet</code>继承自 <code>HashSet</code>，根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</font> LinkedHashSet插入性能略低于 HashSet，但在迭代访问Set里的全部元素时有很好的性能。</p>
<p>跟随<code>LinkedHashSet</code> 的构造方法可以发现它调用了父类构造方法创建了一个<code>LinkedHashMap</code>，而 <code>LinkedHashMap</code>底层又采用 HashMap + 双向链表 实现的；所以本质上 LinkedHashSet 还是使用 HashMap 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">HashSet(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">boolean</span> dummy) &#123;<br>	map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>LinkedHashSet 中也没有添加额外的同步策略，所以 LinkedHashSet 集合<strong>也不是线程安全</strong> 的。</p>
<blockquote>
<ul>
<li>底层数据结构： 继承于 <code>HashSet</code>，初始化时创建了一个LinkedHashMap，所以它是由 HashMap + 双向链表 构成的</li>
<li>除了具有set集合不重复的特点，同时具有可预测的迭代顺序，也就是我们插入的顺序。</li>
</ul>
</blockquote>
<h5 id="treeset"><a class="markdownIt-Anchor" href="#treeset"></a> TreeSet</h5>
<p><font style="color:red"><code>TreeSet</code>作用是提供有序的Set集合。TreeSet也是线程不安全的，它基于TreeMap实现，TreeSet和TreeMap一样，它们的元素支持2种排序方式：自然排序或者根据提供的Comparator进行排序。</font></p>
<p>TreeSet中的元素<strong>必须实现Comparable接口并重写<code>compareTo()</code>方法</strong>，TreeSet判断元素是否重复 、以及确定元素的顺序 靠的都是这个方法；对于未实现Comparable的元素，程序运行时会抛出java.lang.ClassCastException类型转化异常。</p>
<blockquote>
<p>① 对于Java类库中定义的类，TreeSet可以直接对其进行存储，如String，Integer等,因为这些类已经实现了Comparable接口);<br />
② 对于自定义类，如果不做适当的处理，TreeSet中只能存储一个该类型的对象实例，否则无法判断是否重复。<br />
③ 关于<code>compareTo()</code>方法规则：</p>
<ol>
<li>如果将compareTo()返回值写死为0，元素值每次比较，都认为是相同的元素，这时就不再向TreeSet中插入除第一个外的新元素。所以TreeSet中就只存在插入的第一个元素。</li>
<li>如果将compareTo()返回值写死为1，元素值每次比较，都认为新插入的元素比上一个元素大，于是二叉树存储时，会存在根的右侧，读取时就是正序排列的。</li>
<li>如果将compareTo()返回值写死为-1，元素值每次比较，都认为新插入的元素比上一个元素小，于是二叉树存储时，会存在根的左侧，读取时就是倒序序排列的。</li>
</ol>
</blockquote>
<h2 id="集合工具类"><a class="markdownIt-Anchor" href="#集合工具类"></a> #集合工具类</h2>
<h4 id="iteratoriterable-listiterator"><a class="markdownIt-Anchor" href="#iteratoriterable-listiterator"></a> Iterator，Iterable &amp; ListIterator</h4>
<ul>
<li>
<p><code>Iterator</code> 接口：迭代器（Iterator）有时又称为游标（cursor），是<strong>单向迭代器</strong>，<font style="color : red">用于遍历Collection集合中的元素，Collection接口中的iterator方法能够直接提供Iterator实例化的对象。它能访问一个容器（container）对象中各个元素，而又不暴露该对象的内部细节。</font></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>提供的API接口含义如下：</p>
<ul>
<li><code>hasNext()</code> ：判断集合中是否存在下一个对象</li>
<li><code>next()</code> ：返回集合中的下一个对象，并将访问指针移动一位</li>
<li><code>remove()</code> ：删除集合中调用 <code>next()</code> 方法返回的对象</li>
</ul>
<p>在早期，遍历集合的方式只有一种，通过 <code>Iterator</code> 迭代器操作：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Iterator&lt;Integer&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>    System.out.println(next);<br>    <span class="hljs-keyword">if</span>(next==<span class="hljs-number">2</span>)&#123;iterator.remove();&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>Iterable</code> 接口主要是为为集合类提供for-each循环的支持，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>	Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// JDK1.8</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>ListIterator</code>和<code>Iterator</code>一样也是Java迭代器，<font style="color : red">它扩展了<code>Iterator</code>接口，且仅对<code>List</code>实现的类有用。</font></p>
<p><code>ListIterator</code>&amp;<code>Iterator</code>区别：</p>
<ul>
<li><code>ListIterator</code>仅对<code>List</code>实现的类有用，<code>Iterator</code>作用在<code>Collection</code>实现的类。</li>
<li><code>ListIterator</code>支持四种操作：<font style="color:yellow"><code>CRUD</code><sup>4</sup>(<code>CREATE</code>，<code>READ</code>，<code>UPDATE</code>和<code>DELETE</code>)</font>。</li>
<li><code>ListIterator</code>是一个双向迭代器，它支持正向和反向迭代。</li>
<li><code>ListIterator</code>没有当前元素; 它的光标位置总是位于调用<code>previous()</code>返回的元素和调用<code>next()</code>返回的元素之间。</li>
</ul>
<p><font style="color:yellow">④：可以对List对象的元素进行增删改查操作</font></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void add(E e)</code></td>
<td>将指定的元素插入列表中。</td>
</tr>
<tr>
<td><code>boolean hasNext()</code></td>
<td>如果此列表迭代器在向前遍历列表时具有元素，则返回<code>true</code>。</td>
</tr>
<tr>
<td><code>boolean hasPrevious()</code></td>
<td>如果此列表迭代器在反向遍历列表时具有元素，则返回<code>true</code>。</td>
</tr>
<tr>
<td><code>E next()</code></td>
<td>返回列表中的下一个元素。</td>
</tr>
<tr>
<td><code>int nextIndex()</code></td>
<td>返回元素的索引。</td>
</tr>
<tr>
<td><code>E previous()</code></td>
<td>返回列表中的上一个元素并向后移动光标位置。</td>
</tr>
<tr>
<td><code>int previousIndex()</code></td>
<td>返回元素的索引。</td>
</tr>
<tr>
<td><code>void remove()</code></td>
<td>从列表中删除由<code>next()</code>或<code>previous()</code>返回的最后一个元素。</td>
</tr>
<tr>
<td><code>void set(E e)</code></td>
<td>用指定的元素替换由<code>next()</code>或<code>previous()</code>返回的最后一个元素。</td>
</tr>
</tbody>
</table>
<p><code>ListIterator</code>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListIteratorDemo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;Rust&quot;</span>);<br><br>    <span class="hljs-comment">// 获取ListIterator</span><br>    ListIterator&lt;String&gt; namesIterator = names.listIterator();<br><br>    <span class="hljs-comment">// 遍历元素</span><br>    <span class="hljs-keyword">while</span>(namesIterator.hasNext())&#123;<br>       System.out.println(namesIterator.next());<br>    &#125;<br>      <br>    <span class="hljs-comment">// 反向遍历元素</span><br>    <span class="hljs-keyword">while</span>(namesIterator.hasPrevious())&#123;<br>	  System.out.println(namesIterator.previous());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="collections"><a class="markdownIt-Anchor" href="#collections"></a> Collections</h4>
<p>Collections是JDK提供的集合工具类，提供了一系列的静态方法，能更方便的操作各种集合。</p>
<ul>
<li>
<p>创建空集合，<code>Collections</code>提供了一系列方法创建空集合：</p>
<blockquote>
<p>List<T> emptyList()，创建空List</p>
<p>Map&lt;K, V&gt; emptyMap()，创建空Map</p>
<p>Set<T> emptySet()，创建空Set</p>
</blockquote>
<p><font style="color:red">这些返回的空集合是不可变集合，无法向其中添加或删除元素。</font>其实在<font style="color:#00FFFF"><strong>Java9以后各个集合接口也提供了<code>of()</code>方法</strong></font>创建空集合：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list1 = List.of();<br><span class="hljs-comment">//of方法等同于Collections.emptyList();</span><br>List&lt;String&gt; list2 = Collections.emptyList();<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>创建单元素集合</p>
<blockquote>
<p>List<T> singletonList(T o)，创建单个元素List</p>
<p>Map&lt;K, V&gt; singletonMap(K key, V value)，创建单个元素Map</p>
<p>Set<T> singleton(T o)，创建单个元素Set</p>
</blockquote>
<p>各个集合接口也提供的<code>of()</code>方法也可以实现，因为<code>of()</code>可以创建任意元素集合：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Collections创建单个元素方法</span><br>List&lt;String&gt; list1 = Collections.singletonList(<span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-comment">//of方法创建任意元素的集合(Java9)</span><br>List&lt;String&gt; list2 = List.of(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>排序</p>
<p><code>Collections</code>可以对<code>List</code>进行排序。因为排序会直接修改<code>List</code>元素的位置，因此必须传入可变<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">// 排序前:</span><br>System.out.println(list);<br>Collections.sort(list);<br><span class="hljs-comment">// 排序后:</span><br>System.out.println(list);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>乱序</p>
<p><code>Collections</code>提供了洗牌算法，即传入一个有序的<code>List</code>，可以随机打乱<code>List</code>内部元素的顺序</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>	list.add(i);<br>&#125;<br><span class="hljs-comment">// 乱序前:</span><br>System.out.println(list);<br>Collections.shuffle(list);<br><span class="hljs-comment">// 乱序后:</span><br>System.out.println(list);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>不可变集合</p>
<p><code>Collections</code>提供了一组方法把可变集合封装成不可变集合：</p>
<blockquote>
<ul>
<li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>
<li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>
<li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>
</ul>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; mutable = List.of(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-comment">// 变为不可变集合</span><br>List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);<br>immutable.add(<span class="hljs-string">&quot;C&quot;</span>); <span class="hljs-comment">// 抛出错误UnsupportedOperationException!</span><br></code></pre></div></td></tr></table></figure>
<p>然而对原始的可变List进行增删会直接影响到封装后的List</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Java9以上才可用</span><br>List&lt;String&gt; mutable = List.of(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-comment">// 变为不可变集合</span><br>List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);<br>mutable.add(<span class="hljs-string">&quot;C&quot;</span>);<br>System.out.println(immutable);<br></code></pre></div></td></tr></table></figure>
<p>所以，如果我们需要封装一个不可变集合，在返回不可变后最好立刻扔掉原来可变List的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; mutable = List.of(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-comment">// 变为不可变集合</span><br>List&lt;String&gt; immutable1 = Collections.unmodifiableList(mutable);<br><span class="hljs-comment">// 立刻扔掉mutable的引用</span><br>mutable = <span class="hljs-literal">null</span>;<br>System.out.println(immutable1);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><font style="color:grey">线程安全集合，<code>Collections</code>提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</font></p>
<blockquote>
<ul>
<li>变为线程安全的List：<code>List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li>
<li>变为线程安全的Set：<code>Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li>
<li>变为线程安全的Map：<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li>
</ul>
</blockquote>
<p>Java后来引入了更高效的并发集合类，所以上述这几个转变线程安全集合方法已经没有什么用了</p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/helloworld/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/helloworld/categories/Java/API/">API</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/helloworld/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/helloworld/tags/JDK/">JDK</a>
                    
                      <a class="hover-with-bg" href="/helloworld/tags/API/">API</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/helloworld/notes/Java/API/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">多线程与并发编程</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/helloworld/notes/Java/JVM/">
                        <span class="hidden-mobile">JVM</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/helloworld/js/events.js" ></script>
<script  src="/helloworld/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/helloworld/js/local-search.js" ></script>



  
    <script  src="/helloworld/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js" ></script>
  
  
    <script  src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdnjs.cloudflare.com/ajax/libs/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/helloworld/js/boot.js" ></script>


</body>
</html>
