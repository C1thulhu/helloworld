

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/helloworld/img/icon/log_1.png">
  <link rel="icon" href="/helloworld/img/icon/log_1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="C1thulhu">
  <meta name="keywords" content="">
  
    <meta name="description" content="线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程与并发编程">
<meta property="og:url" content="https://c1thulhu.github.io/helloworld/notes/Java/API/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="C1thulhu">
<meta property="og:description" content="线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_CVP/Muti-thread&JUC.png">
<meta property="article:published_time" content="2022-05-25T00:00:00.000Z">
<meta property="article:modified_time" content="2022-09-23T00:00:00.000Z">
<meta property="article:author" content="C1thulhu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JDK">
<meta property="article:tag" content="API">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_CVP/Muti-thread&JUC.png">
  
  
  <title>多线程与并发编程 - C1thulhu</title>

  <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github-dark-dimmed.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/helloworld/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"c1thulhu.github.io","root":"/helloworld/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/helloworld/local-search.xml"};
  </script>
  <script  src="/helloworld/js/utils.js" ></script>
  <script  src="/helloworld/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/helloworld/">
      <strong>C1thulhu</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/helloworld/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/helloworld/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/helloworld/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/helloworld/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/helloworld/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/helloworld/img/background/Muti-thread&JUC.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.1)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="多线程与并发编程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-25 00:00" pubdate>
        2022-05-25
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">多线程与并发编程</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022-09-23
                
              </p>
            
            <div class="markdown-body">
              <h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2>
<p><font style="color:grey">待编纂。</font></p>
<p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.kyire.site/2021/04/17/dcfce7ce.html">多线程与线程同步</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.kyire.site/2021/05/16/eb9166f8.html">JUC并发编程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651">Java线程的6种状态及切换</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">synchronized详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html">volatile详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28082757/article/details/101065531">System.out.println如何影响内存可见性</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duzhe2905/article/details/106038681">volatile如何保证可见性和有序性</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-all.html">Java中所有的锁</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42290561/article/details/125575083">深入了解CAS和常用原子类</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43478694/article/details/123622726">Unsafe类详解</a></li>
</ul>
<h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> #多线程</h2>
<p>  <font style="color : red"><strong>线程</strong>是CPU调度和运算的<strong>最小</strong>单位。</font>而多个线程组成一个进程，<font style="color : red"><strong>进程</strong>是一个动态的概念，是系统资源分配的单位。</font>进程又是执行程序的一次执行过程，<font style="color : red"><strong>程序</strong>是一个静态的概念，是指令和数据的有序集合，其本身没有任何运行的含义。</font></p>
<p><strong>多线程核心概念</strong></p>
<ul>
<li>
<p>线程就是独立的执行路径；在程序运行时，后台会就有多个线程，也称为<font style="color:yellow">守护线程<sup>1</sup></font>，如<code>main</code>主线程、gc线程；<code>main()</code>线程称之为主线程，为系统的入口，用于执行整个程序；</p>
</li>
<li>
<p>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的；</p>
</li>
<li>
<p>对同一份资源操作时，会存在资源抢占问题，需要加入并发控制；</p>
</li>
<li>
<p>线程会带来额外的开销，如CPU调度时间，并发控制开销；</p>
</li>
<li>
<p>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致；</p>
<p><font style="color:yellow">①：守护线程是指在程序运行时 在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分。而由我们自己定义的线程称为 <strong>用户线程</strong> 。</font></p>
</li>
</ul>
<h3 id="线程创建方式"><a class="markdownIt-Anchor" href="#线程创建方式"></a> 线程创建方式</h3>
<ul>
<li>
<p>继承Thread类</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread方式&quot;</span>+i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TestThread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestThread</span>();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Runnable方式&quot;</span>+i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TestRunnable runnable=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>实现Callable接口</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Runnable方式&quot;</span>+i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;call结束&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">//创建一个callable接口实现类对象</span><br>        <span class="hljs-type">CallableTest</span> <span class="hljs-variable">callableTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableTest</span>();<br>        <span class="hljs-comment">//创建执行服务</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//提交执行</span><br>        Future&lt;String&gt; future = service.submit(callableTest);<br>        <span class="hljs-comment">//获取call返回结果</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get();<br>        System.out.println(result);<br>        <span class="hljs-comment">//关闭服务</span><br>        service.shutdownNow();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>
<p>继承<code>Thread</code>类</p>
<blockquote>
<p>启动线程：子类对象.start()</p>
<p><b style="color:red">存在OOP单继承局限性</b></p>
</blockquote>
</li>
<li>
<p>实现<code>Runnable</code>接口</p>
<blockquote>
<p>启动线程：传入目标对象+Thread对象.start()</p>
<p><b style="color:red">灵活方便，方便同一个对象被多个线程使用，减少程序之间的耦合度，面向接口编程也是设计模式六大原则的核心。</b></p>
</blockquote>
</li>
<li>
<p>实现<code>Callable</code>接口</p>
<blockquote>
<p>启动线程：执行对象(线程池).submit(目标对象)</p>
<p>获取结果：执行对象(线程池).submit(目标对象).get()</p>
<p><b style="color:red">Callable主要用于线程池可以抛出异常并且有返回值。</b></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="thread类"><a class="markdownIt-Anchor" href="#thread类"></a> Thread类</h3>
<ul>
<li>
<p>线程状态</p>
<ol>
<li>
<p><strong>初始状态(NEW)</strong><br />
<font style="color:#00FFFF">实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</font></p>
</li>
<li>
<p><strong>运行(RUNNABLE)</strong></p>
<blockquote>
<p><strong>2.1. 就绪 (RUNNABLE之READY)</strong></p>
<ul>
<li><font style="color:#00FFFF">就绪状态只是说有资格运行，只要调度程序没有挑选到你，就永远是就绪状态。</font></li>
<li>调用线程的<code>start()</code>方法，此线程进入就绪状态。</li>
<li>当前线程<code>sleep()</code>方法结束，其他线程<code>join()</code>结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</li>
<li>当前线程时间片用完了，调用当前线程的<code>yield()</code>方法，当前线程进入就绪状态。</li>
<li>锁池里的线程拿到对象锁后，进入就绪状态。</li>
</ul>
<p><strong>2.2. 运行中状态(RUNNABLE之RUNNING)</strong></p>
<ul>
<li><font style="color:#00FFFF">线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。</font></li>
</ul>
</blockquote>
</li>
<li>
<p><strong>阻塞(BLOCKED)</strong><br />
<font style="color:#00FFFF">阻塞状态是线程阻塞在进入<code>synchronized</code>关键字修饰的方法或代码块(获取锁)时的状态。</font></p>
</li>
<li>
<p><strong>等待(WAITING)</strong><br />
<font style="color:#00FFFF">处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</font></p>
</li>
<li>
<p><strong>超时等待(TIMED_WAITING)</strong><br />
<font style="color:#00FFFF">处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</font></p>
</li>
<li>
<p><strong>终止(TERMINATED)</strong><br />
<font style="color:#00FFFF">当线程的<code>run()</code>方法完成时，或者主线程的<code>main()</code>方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。</font><br />
<font style="color : red">在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</font></p>
</li>
</ol>
<p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpeg" srcset="/helloworld/img/loading.gif" lazyload alt="线程状态" /></p>
</li>
<li>
<p>线程方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setPriority(int newPriority)</td>
<td style="text-align:center">更改线程的优先级</td>
</tr>
<tr>
<td style="text-align:center">static void sleep(long millis)</td>
<td style="text-align:center">在指定毫秒数内让当前正在执行的线程休眠</td>
</tr>
<tr>
<td style="text-align:center">void join()</td>
<td style="text-align:center">等待该线程终止</td>
</tr>
<tr>
<td style="text-align:center">static void yield()</td>
<td style="text-align:center">暂停当前正在执行的线程对象，并执行其他线程</td>
</tr>
<tr>
<td style="text-align:center">void interrupt()</td>
<td style="text-align:center">中断线程，别用这个方式</td>
</tr>
<tr>
<td style="text-align:center">boolean isAlive()</td>
<td style="text-align:center">测试线程是否处于活动状态</td>
</tr>
</tbody>
</table>
<p><font style="color:yellow"><code>wait()</code>：wait是<code>Object</code>中的方法，任何对象实例都能调用。它和<code>Thread</code>中的<code>sleep()</code>很相似，不同的是sleep不会释放锁，也不需要占有锁；而wait会释放锁，而且调用它的前提是当前线程占有锁(即代码在<code>synchronized</code> 中)</font></p>
</li>
</ul>
<h3 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> synchronized</h3>
<p><code>synchronized</code>是Java中的关键字，是一种同步锁，它具有以下特点：</p>
<ul>
<li>
<p><font style="color:red">一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</font></p>
</li>
<li>
<p><font style="color:red"><code>synchronized</code>可以修饰 <strong>方法</strong> 和 <strong>代码块</strong> ；</font></p>
</li>
<li>
<p><font style="color:red">synchronized修饰 普通方法 锁对象默认为this(当前实例对象)，而同步代码块锁可以指定对象，两种都是<strong>对象锁</strong>；</font></p>
<p>对象锁示例1：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;	<span class="hljs-comment">//和synchronized修饰 普通方法 效果相同</span><br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">我是线程Thread-0<br>Thread-0结束<br>我是线程Thread-1<br>Thread-1结束<br></code></pre></div></td></tr></table></figure>
<p>上述代码两个线程使用的锁是一样的,<code>thread2</code>必须要等到<code>thread1</code>释放了该锁后，才能执行。</p>
<p>对象锁示例2：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br>    <span class="hljs-comment">// 创建2把锁</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">block1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">block2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span><br>        <span class="hljs-keyword">synchronized</span> (block1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (block2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">block1锁,Thread-0<br>block1锁,Thread-0 END！<br>block2锁,Thread-0<br>block1锁,Thread-1<br>block1锁,Thread-1 END！<br>block2锁,Thread-0 END！<br>block2锁,Thread-1<br>block2锁,Thread-1 END！<br></code></pre></div></td></tr></table></figure>
<p>由示例2可见，当同步代码块指定不同对象时，在<code>thread1</code>从<code>block1锁</code>释放后；由于此时<code>thread1</code>锁对象是<code>block1锁</code>而<code>thread2</code>锁对象是<code>block2锁</code>，<code>thread2</code>会和<code>thread1</code>同时运行。</p>
</li>
<li>
<p><font style="color:red"><code>synchronized</code>修饰 静态方法 或同步代码块指定锁对象为 <code>Class</code>对象时，称为<strong>类锁</strong>； </font></p>
<p>类锁示例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 所有线程需要的锁都是同一把</span><br>        <span class="hljs-keyword">synchronized</span>(SynchronizedObjectLock.class)&#123;<br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence1);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence2);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">Thread-0<br>Thread-0 END！<br>Thread-1<br>Thread-1 END！<br></code></pre></div></td></tr></table></figure>
<p>类锁代码，无论是哪个线程访问它，需要的锁都只有一把。</p>
</li>
<li>
<p><font style="color:red">synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁。</font></p>
</li>
</ul>
<p><font style="color:grey">待完善。。</font></p>
<h2 id="并发编程juc"><a class="markdownIt-Anchor" href="#并发编程juc"></a> #并发编程(JUC)</h2>
<p>  JUC是<code>java.util.concurrent</code>的简写，是jdk针对java并发编程的工具包。</p>
<p>  在了解JUC之前我们先了解<strong>并发</strong>的概念：<font style="color:red"><strong>单核下多线程操作同一个资源</strong>，将CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为并发(Concurrent)。</font><font style="color:#00FFFF">并发实质是一个物理CPU（也可以是多个物理CPU）在若干个程序之间多路复用，并发性是对有限物理资源强制行使 多用户共享以提高效率。</font><br />
而和并发相似的<strong>并行</strong>是在<font style="color:red"><strong>多核下多线程同时执行</strong>，多个线程之间互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。</font></p>
<p>并发问题的三要素：可见性、原子性和有序性：</p>
<ul>
<li><font style="color:red">可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</font></li>
<li>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ul>
<h3 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> volatile</h3>
<h4 id="volatile可见性"><a class="markdownIt-Anchor" href="#volatile可见性"></a> volatile可见性</h4>
<p>  可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用，</p>
<p><code>volatile</code>可见性示例1：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">()</span>&#123;<br>        a = <span class="hljs-number">3</span>;<br>        b = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;b=&quot;</span>+b+<span class="hljs-string">&quot;;a=&quot;</span>+a);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">VolatileTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileTest</span>();<br>            <span class="hljs-comment">//线程1</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                test.change();<br>            &#125;).start();<br>            <span class="hljs-comment">//线程2</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">10</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    test.print();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>正常情况下，这段代码只存在两种情况：</p>
<ol>
<li>先执行<code>change()</code>，再执行<code>print()</code> 结果是：b=3;a=3；</li>
<li>先执行<code>print()</code>，再执行<code>change()</code> 结果是：b=2;a=1；</li>
</ol>
<p>但是还可能出现 b=2;a=3 或者 b=3;a=1 的情况，这种情况主要是因为线程1修改了a或者b后，对线程2是不可见的，所以才会出现这种情况，如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。</p>
<p><code>volatile</code>可见性示例2：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span> (num ==  <span class="hljs-number">0</span>)&#123; <br><span class="hljs-comment">//			System.out.println(&quot;thread&quot;);</span><br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-comment">//主线程暂停1s</span><br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    num = <span class="hljs-number">1</span>;<br>    System.out.println(num);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上述代码也能体现volatile的可见性，代码会进入死循环；这是由于线程对主线程的内存变化不可见。</p>
<p><font style="color:#00FFFF">  如果循环中存在 输出语句 则不会进入死循环，这是因为<code>PrintStream</code>中输出方法都带上了<code>synchronized</code>，而<code>synchronized</code>会做一下操作：</font></p>
<blockquote>
<ol>
<li>获得同步锁；</li>
<li>清空工作内存；</li>
<li>从主内存拷贝对象副本到工作内存；</li>
<li>执行代码(计算或者输出等)；</li>
<li>刷新主内存数据；</li>
<li>释放同步锁。</li>
</ol>
</blockquote>
<p>可见性问题的根本原因：</p>
<blockquote>
<p>在Java内存模型中，规定了共享变量是存放在主内存中，然后<strong>每个线程都有自己的工作内存</strong>，而线程对共享变量的操作，必须先从主内存中读到工作内存中去，至于什么时候写回到主内存是不可预知的，这就导致每个线程之间对共享变量的操作是封闭的，其他线程不可见的。</p>
</blockquote>
<p><code>volatile</code>修饰的共享变量进行写操作的时候多出一条带<code>lock前缀的指令</code></p>
<ol>
<li>Lock前缀的指令让线程工作内存中的值写回主内存中；</li>
<li>通过缓存一致性协议，其他线程如果工作内存中存了该共享变量的值，就会失效；</li>
<li>其他线程会重新从主内存中获取最新的值；</li>
</ol>
<h4 id="volatile原子性"><a class="markdownIt-Anchor" href="#volatile原子性"></a> volatile原子性</h4>
<p><code>volatile</code>原子性示例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        num++; <span class="hljs-comment">//不是一个原子性操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//理论上num结果为1000</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                add();<br>            &#125;).start();<br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">//等待3秒，保证上面程序执行完成</span><br><br>        System.out.println(<span class="hljs-string">&quot;num =&quot;</span> + num);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><i style="color:yellow">注：上面代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。</i></p>
<p>输出结果理论上来说应该是1000，但是由于i++其实是一个复合操作，包括三步骤：</p>
<ul>
<li>
<p>读取i的值。</p>
</li>
<li>
<p>对i加1。</p>
</li>
<li>
<p>将i的值写回内存。</p>
</li>
</ul>
<p>volatile是无法保证这三个操作是具有原子性的，我们可以通过<strong>原子类</strong>或者<code>synchronized</code>和<code>lock</code>来保证+1操作的原子性。</p>
<h4 id="volatile有序性"><a class="markdownIt-Anchor" href="#volatile有序性"></a> volatile有序性</h4>
<p>实例化一个对象可以分为三个步骤：</p>
<ul>
<li>分配内存空间。</li>
<li>初始化对象。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
</ul>
<p>但是由于操作系统可以对指令进行<font style="color:yellow"><code>重排序</code><sup>2</sup></font>，所以上面的过程也可能会变成如下过程：</p>
<ul>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ul>
<p><font style="color:yellow">②：指令重排是指为了性能考虑, 编译器和CPU可能会对指令重新排序。同时内存也可能存在重排序，这主要是由于JMM(Java内存模型)中主内存和本地内存不一致导致程序乱序。</font></p>
<blockquote>
<p><strong>处理器在进行指令重排的时候，考虑：数据之间的依赖性！</strong></p>
<p>指令重排示例：</p>
<p>x,y,a,b初始值为0，然后进行以下操作：</p>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
<th style="text-align:center">线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x=a</td>
<td style="text-align:center">y=b</td>
</tr>
<tr>
<td style="text-align:center">b=1</td>
<td style="text-align:center">a=2</td>
</tr>
</tbody>
</table>
<p>正常结果应该是：x=0,y=0；但是由于指令重排可能导致指令执行顺序出现问题：</p>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
<th style="text-align:center">线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">b=1</td>
<td style="text-align:center">a=2</td>
</tr>
<tr>
<td style="text-align:center">x=a</td>
<td style="text-align:center">y=b</td>
</tr>
</tbody>
</table>
<p>导致结果为：x=2,y=1。</p>
</blockquote>
<p>  <strong><code>volatile</code>禁止重排序</strong>，为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了<b style="color:red">内存屏障</b>阻止这种重排序。<font style="color:red">Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</font></p>
<h3 id="final"><a class="markdownIt-Anchor" href="#final"></a> final</h3>
<p>对于常用的关键字<code>final</code>的使用只简单概述一下，主要针对<code>final</code>在并发情况下的作用。</p>
<h4 id="final基础使用"><a class="markdownIt-Anchor" href="#final基础使用"></a> final基础使用</h4>
<ul>
<li>
<p>修饰类</p>
<p>当某个类的整体定义为final时，就表明了你不能打算继承该类，即这个类是<font style="color:red">不能有子类的。</font></p>
<p><font style="color:yellow">final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。</font></p>
</li>
<li>
<p>修饰方法</p>
<p><font style="color:red">声明方法不能被子类重写。</font></p>
<p><font style="color:yellow">private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</font></p>
</li>
<li>
<p>修饰参数</p>
<p><font style="color:red">Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。</font><font style="color:#00FFFF">这个特性主要用来向匿名内部类传递数据。</font></p>
</li>
<li>
<p>修饰变量</p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
</li>
</ul>
<h4 id="final重排序规则"><a class="markdownIt-Anchor" href="#final重排序规则"></a> final重排序规则</h4>
<h5 id="final修饰基本类型"><a class="markdownIt-Anchor" href="#final修饰基本类型"></a> final修饰基本类型</h5>
<ul>
<li>
<p>写规则</p>
<p><font style="color:red">JMM禁止编译器把final域的写重排序到 构造函数 之外；</font><font style="color:#00FFFF"> 编译器会在final域写之后，构造函数return之前，插入一个<code>storestore</code>屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</font></p>
<p><font style="color:red">在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。</font></p>
</li>
<li>
<p>读规则</p>
<p><font style="color:red">在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。</font><strong>(注意，这个规则仅仅是针对处理器)</strong>，处理器会在读final域操作的前面插入一个<code>LoadLoad</code>屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p>
</li>
</ul>
<h5 id="final修饰引用类型"><a class="markdownIt-Anchor" href="#final修饰引用类型"></a> final修饰引用类型</h5>
<ul>
<li>
<p>写规则</p>
<p>引用类型和基础类型相较多了对 对象的引用，即：<font style="color:red">在final基本类型的写规则上增加了 在构造函数内对一个final修饰对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。</font></p>
</li>
<li>
<p>读规则</p>
<p><font style="color:red">读final引用对象的成员域时结果时<strong>不可预知</strong>的，因为其对final修饰对象的成员域的写入是不可见的，两者之间存在数据竞争。</font></p>
</li>
</ul>
<h3 id="juc锁"><a class="markdownIt-Anchor" href="#juc锁"></a> JUC锁</h3>
<p>  Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍：</p>
<p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Java%E9%94%81%E7%B1%BB%E5%9E%8B.png" srcset="/helloworld/img/loading.gif" lazyload alt="Java锁类型" /></p>
<h4 id="锁类型"><a class="markdownIt-Anchor" href="#锁类型"></a> 锁类型</h4>
<h5 id="悲观锁乐观锁"><a class="markdownIt-Anchor" href="#悲观锁乐观锁"></a> 悲观锁&amp;乐观锁</h5>
<ul>
<li>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此<font style="color:red">在获取数据的时候会先加锁，确保数据不会被别的线程修改。</font ><font style="color:#00FFFF">Java中，synchronized关键字和Lock的实现类都是悲观锁。</font></li>
<li>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是<font style="color:red">在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</font><font style="color:#00FFFF">乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</font></li>
</ul>
<blockquote>
<p><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。<br />
<strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</p>
</blockquote>
<h5 id="自旋锁适应性自旋锁"><a class="markdownIt-Anchor" href="#自旋锁适应性自旋锁"></a> 自旋锁&amp;适应性自旋锁</h5>
<p>  <font style="color:red">阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。</font>如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>  在同步资源的锁定时间很短的场景下，让CPU去切换线程，线程挂起和恢复线程实在得不偿失。<font style="color:red">如果能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。所以我们让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</font></p>
<p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E8%87%AA%E6%97%8B%E9%94%81.png" srcset="/helloworld/img/loading.gif" lazyload alt="自旋锁" /></p>
<p>  自旋锁本身是有缺点的，它<strong>不能代替阻塞</strong>。<font style="color:#00FFFF">如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</font>所以，<font style="color:red">自旋等待的时间和自旋次数必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</font></p>
<p>  如果线程自旋刚结束，锁正好释放，这是不是也是资源的一种浪费。于是针对这种情况JDK引入了更灵活的适应性自旋锁，来提高并发性能。</p>
<p>  适应性自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确。</p>
<h5 id="无锁偏向锁轻量级锁重量解锁"><a class="markdownIt-Anchor" href="#无锁偏向锁轻量级锁重量解锁"></a> 无锁，偏向锁，轻量级锁&amp;重量解锁</h5>
<ul>
<li>
<p>无锁</p>
<blockquote>
<p>顾名思义程序不会有锁的竞争。那么这种情况我们不需要加锁，所以这种情况下对象锁状态为无锁。</p>
</blockquote>
</li>
<li>
<p>偏向锁</p>
<blockquote>
<p>偏向第一个访问锁的线程</p>
</blockquote>
<ul>
<li><font style="color:#00FFFF">如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</font></li>
<li>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。**一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。**升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致<font style="color:yellow">STW(stop the world)<sup>3</sup></font>操作；</li>
</ul>
<p><font style="color:yellow">③：<strong>等待所有用户线程进入安全点后并阻塞</strong>，做一些全局性操作的行为。Java中一种<strong>全局暂停现象，全局停顿，所有Java代码停止</strong>，<strong>native代码可以执行，但不能与JVM交互。</strong></font></p>
</li>
<li>
<p>轻量级锁</p>
<blockquote>
<p>轻量级锁对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。</p>
</blockquote>
<ol>
<li>
<p><font style="color:red">在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为<code>Lock Record</code>(锁记录)的空间用于存储锁对象目前的<code>Mark Word</code>的拷贝(JVM会将对象头中的<code>Mark Word</code>拷贝到锁记录中)。如果当前对象没有被锁定，那么锁标志位为<strong>01</strong>状态。</font></p>
</li>
<li>
<p><font style="color:red">JVM在执行当前线程时，虚拟机使用CAS操作将标记字段<code>Mark Word</code>拷贝到锁记录中。并且将<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。</font></p>
<p>如果更新成功，那么这个线程就有用了该对象的锁，并且对象<code>Mark Word</code>的锁标志位更新为(<code>Mark Word</code>中最后的2bit)<strong>00</strong>，即表示此对象处于轻量级锁定状态。</p>
<p>如果更新失败，JVM会检查当前的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为<strong>10</strong>，<code>Mark Word</code>中存储的时指向重量级锁的指针。</p>
</li>
</ol>
<p><strong>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗</strong>，包括系统调用引起的<font style="color:yellow">内核态<sup>4</sup></font>与<font style="color:yellow">用户态<sup>5</sup></font>切换、线程阻塞造成的线程切换等。</p>
</li>
<li>
<p>重量级锁</p>
<blockquote>
<p>当有其他线程占用锁时，当前线程会进入阻塞状态。</p>
</blockquote>
<p>内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。<font style="color:red">这种同步方式的成本非常高，包括系统调用引起的<font style="color:yellow">内核态<sup>4</sup></font>与<font style="color:yellow">用户态<sup>5</sup></font>切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</font></p>
<p><font style="color:yellow">④：</font></p>
<p><font style="color:yellow">⑤：</font></p>
</li>
</ul>
<h5 id="公平锁非公平锁"><a class="markdownIt-Anchor" href="#公平锁非公平锁"></a> 公平锁&amp;非公平锁</h5>
<p>  <font style="color:red">公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</font><font style="color:#00FFFF"><strong>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</strong></font></p>
<p>  <font style="color:red">非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</font><font style="color:#00FFFF"><strong>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</strong></font></p>
<h5 id="可重入锁非可重入锁"><a class="markdownIt-Anchor" href="#可重入锁非可重入锁"></a> 可重入锁&amp;非可重入锁</h5>
<p>  <font style="color:red">可重入锁是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</font>Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法1执行...&quot;</span>);<br>        doOthers();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOthers</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法2执行...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>  类中的两个方法都是被内置锁synchronized修饰的，<strong>在<code>doSomething()</code>方法中调用<code>doOthers()</code>方法时，由于内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作；</strong><br />
  <strong>如果是不可重入锁，那么当前线程在调用<code>doOthers()</code>之前需要将执行<code>doSomething()</code>时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</strong></p>
<h5 id="共享锁排他锁"><a class="markdownIt-Anchor" href="#共享锁排他锁"></a> 共享锁&amp;排他锁</h5>
<p><strong>共享锁</strong>是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p><strong>排他锁</strong>是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的<code>synchronized</code>和JUC中<code>Lock</code>的实现类就是互斥锁。</p>
<h4 id="juc锁相关体系"><a class="markdownIt-Anchor" href="#juc锁相关体系"></a> JUC锁相关体系</h4>
<p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Lock%E6%A1%86%E6%9E%B6.png" srcset="/helloworld/img/loading.gif" lazyload alt="Lock框架" /></p>
<ul>
<li>
<p>锁核心类AQS(AbstractQueuedSynchronizer)</p>
<p><font style="color:red"><code>AQS</code>是一个用来<strong>构建锁和同步器的框架</strong>，使用AQS能简单且高效地构造出应用广泛的大量的同步器。</font></p>
<p>AQS核心思想</p>
<p> <strong> 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制</strong>，这个机制AQS是用<font style="color:yellow">CLH队列锁<sup>6</sup></font>实现的，即将暂时获取不到锁的线程加入到队列中。</p>
</li>
<li>
<p>Lock</p>
<p><font style="color:red"><code>Lock</code>为接口类型，<code>Lock</code>实现提供了比使用<code>synchronized</code>方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。</font></p>
<p><strong>ReentrantLock</strong></p>
<p><code>ReentrantLock</code>可重入锁，实现了<code>Lock</code>接口，<code>Lock</code>接口中定义了<code>lock</code>与<code>unlock</code>相关操作，并且还存在<code>Condition</code>方法，表示生成一个条件。</p>
<p><code>ReentrantLock</code>总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系：</p>
<ul>
<li>
<p>Sync类</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock</td>
<td style="text-align:center">锁定，未实现，留给具体子类实现</td>
</tr>
<tr>
<td style="text-align:center">nonfairTryAcquire</td>
<td style="text-align:center">非公平方式获取</td>
</tr>
<tr>
<td style="text-align:center">tryRelease</td>
<td style="text-align:center">试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它</td>
</tr>
<tr>
<td style="text-align:center">isHeldExclusively</td>
<td style="text-align:center">判断资源是否被当前线程占有</td>
</tr>
<tr>
<td style="text-align:center">newCondition</td>
<td style="text-align:center">新生一个条件</td>
</tr>
<tr>
<td style="text-align:center">getOwner</td>
<td style="text-align:center">返回资源的占用线程</td>
</tr>
<tr>
<td style="text-align:center">getHoldCount</td>
<td style="text-align:center">返回状态</td>
</tr>
<tr>
<td style="text-align:center">isLocked</td>
<td style="text-align:center">资源是否被占用</td>
</tr>
<tr>
<td style="text-align:center">readObject</td>
<td style="text-align:center">自定义反序列化逻辑</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>NonfairSync类</p>
<p><strong>NonfairSync类继承了Sync类，表示采用非公平策略获取锁</strong>，其实现了Sync类中抽象的lock方法，<font style="color:red">每一次都尝试获取锁，而并不会按照公平等待的原则进行等待，让等待时间最久的线程获得锁。</font></p>
</li>
<li>
<p>FairSyn类</p>
<p><strong>FairSync类也继承了Sync类，表示采用公平策略获取锁</strong>，其实现了Sync类中的抽象lock方法，<font style="color:red">当资源空闲时，它总是会先判断<code>sync</code>队列(AbstractQueuedSynchronizer中的数据结构)是否有等待时间更长的线程，如果存在，则将该线程加入到等待队列的尾部，实现了公平获取原则。</font></p>
</li>
</ul>
</li>
<li>
<p>ReadWriteLock</p>
<p><font style="color:red"><code>ReadWriteLock</code>为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 <code>writer</code>，读取锁可以由多个 <code>reader</code> 线程同时保持。写入锁是独占的。</font></p>
</li>
<li>
<p>Condition</p>
<p><code>Condition</code>为接口类型，它将 Object 监视器方法(<code>wait</code>、<code>notify</code> 和 <code>notifyAll</code>)分解成截然不同的对象，以便通过将这些对象与任意 <code>Lock</code> 实现组合使用，为每个对象提供多个等待 <code>set</code> (<code>wait-set</code>)。其中，<code>Lock</code> 替代了 <code>synchronized</code> 方法和语句的使用，<code>Condition</code> 替代了 <code>Object</code> 监视器方法的使用。可以通过<code>await()</code>,<code>signal()</code>来休眠/唤醒线程。</p>
</li>
</ul>
<p><font style="color:grey">待编纂。。</font></p>
<h3 id="原子类"><a class="markdownIt-Anchor" href="#原子类"></a> 原子类</h3>
<h4 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h4>
<p>  在了解原子类之前我们需要先了解<code>CAS</code>，<code>CAS</code>(Compare-And-Swap)是指对比交换，这是一条<code>CPU</code>原子指令，其作用是让<code>CPU</code>先进行比较两个值是否相等，然后原子地更新某个位置的值。<font style="color:yellow"><code>CAS</code>实现方式是基于硬件平台的汇编指令，<code>JVM</code>只是封装了汇编调用。</font>而<code>java.util.concurrent.atomic</code>包下所有的原子类都是使用了封装<code>CAS</code>后的接口，包括<code>Lock</code>底层<code>AQS</code>也是基于<code>CAS</code>获取锁的。</p>
<p><code>CAS</code>工作流程：</p>
<img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/CAS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" srcset="/helloworld/img/loading.gif" lazyload alt="CAS工作流程" style="zoom:80%;"/>
<p>使用示例：</p>
<p>不使用CAS，在高并发下，多线程同时修改同一个变量的值需要<code>synchronized</code>加锁</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> i++;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>以AtomicInteger原子类示例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> i.addAndGet(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><font style="color:red"><code>CAS</code> 方式为乐观锁，<code>synchronized</code> 为悲观锁。因此使用 <code>CAS</code> 解决并发问题通常情况下性能更优。</font>然而<code>CAS</code>也存在几个方面问题：</p>
<ul>
<li>
<p><strong>ABA问题</strong>，因为CAS需要在操作值时，检查值有没有发生变化，没有发生变化则更新，但是<strong>如果一个值原来是A，变成了B，又变成了A</strong>，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p>
<img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/ABA%E9%97%AE%E9%A2%98.png" srcset="/helloworld/img/loading.gif" lazyload alt="ABA问题" style="zoom:80%;" />
<p>ABA问题解决方案：JDK提供了版本号机制<code>AtomicStampedReference&lt;V&gt;</code>类，来解决 ABA问题 ，就是每次修改时更新版本号。<br />
<code>AtomicMarkableReference&lt;V&gt;</code>类也能解决，只不过该类不关心版本变更了多少次，只关心是否发生了改变。</p>
</li>
<li>
<p><strong>循环时间长开销大</strong>，同自旋锁一般，自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
</li>
<li>
<p><strong>只能保证一个共享变量的原子操作</strong>，当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
</li>
</ul>
<h4 id="unsafe"><a class="markdownIt-Anchor" href="#unsafe"></a> Unsafe</h4>
<p>  Unsafe类提供了<strong>硬件级别的的原子性操作</strong>，<font style="color:red">Unsafe类中的方法都是native方法，通过使用JNI的方式访问本地C++库。</font><br />
Unsafe是位于sun.misc包下，主要<strong>提供一些用于执行低级别、不安全操作的方法</strong>。这些方法在<strong>提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用</strong>。</p>
<p>  <font style="color:red">由于<strong>Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力</strong>，这也<strong>增加了程序发生相关指针问题的风险</strong>。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此<strong>对Unsafe的使用一定要慎重</strong>。</font></p>
<p>Unsafe中的方法示例：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">long objectFieldOffset(Field field)</td>
<td style="text-align:left">返回指定的变量在所属类中的内存偏移地址</td>
</tr>
<tr>
<td style="text-align:center">int arrayBaseOffset(Class arrayClass)</td>
<td style="text-align:left">获取数组中第一个元素的地址</td>
</tr>
<tr>
<td style="text-align:center">boolean compareAndSwapLong(Object obj, long offset, long expect, long update)</td>
<td style="text-align:left">CAS操作</td>
</tr>
<tr>
<td style="text-align:center">public native long getLongvolatile(Object obj, long offset</td>
<td style="text-align:left">获取对象obj中偏移量offset 的变量对应volatile语义的值</td>
</tr>
<tr>
<td style="text-align:center">void putLongvolatile(Object obj, long offset, long value)</td>
<td style="text-align:left">设置 obj 对象中<code>offset</code>偏移 的类型为 long 的 field 的值为 value，支持 volatile 语义</td>
</tr>
<tr>
<td style="text-align:center">void park(boolean isAbsolute, long time</td>
<td style="text-align:left">阻塞当前线程</td>
</tr>
<tr>
<td style="text-align:center">void unpark(Object thread</td>
<td style="text-align:left">唤醒调用park后阻塞的线程</td>
</tr>
<tr>
<td style="text-align:center">long getAndSetLong(Object obj , long offset, long update</td>
<td style="text-align:left">获取对象 obj 中偏移量为offset 的变量 volatile语义的当前值，并设置变量 volatile 语义的值为 update</td>
</tr>
<tr>
<td style="text-align:center">long getAndAddLong(Object obj, long offset, long addValue</td>
<td style="text-align:left">获取对象obj中偏移量为 offset 的变量 volatile 语义的当前值，并设置变量值为原始值＋addValue</td>
</tr>
</tbody>
</table>
<p><code>Unsafe</code>类尽管里面的方法都是 public 的，但是并没有办法使用它们，因为<code>AppClassLoader</code>应用程序加载器加载的，不是启动类加载器加载的，这是一种安全机制。然而可以使用<strong>反射</strong>来使用UnSafe类</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeDemo</span> &#123;<br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> O;<span class="hljs-comment">//变量</span><br>	<span class="hljs-keyword">static</span> Unsafe unsafe;<span class="hljs-comment">//获取Unsafe的实例</span><br>	<span class="hljs-keyword">static</span> <span class="hljs-type">long</span> stateoffset;<span class="hljs-comment">//记录变量state在类unsafeDemo类中的偏移值</span><br>	<span class="hljs-keyword">static</span> &#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Field field;<br>            <span class="hljs-comment">//使用反射获取unsafe类的成员交量theUnsafe,</span><br>            field = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span> );<br>            field.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置为可存取</span><br>            unsafe = (unsafe) field.get(<span class="hljs-literal">null</span>);	<span class="hljs-comment">//获取该变量的值//获取state在unsafeDemo中的偏移量</span><br>            stateOffset = unsafe.objectFieldoffset(UnsafeDemo.class.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>));<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printstackTrace();<br>		&#125;<br>	&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(string[] args)</span>&#123;<br>    	<span class="hljs-type">UnsafeDemo</span> <span class="hljs-variable">uDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsafeDemo</span>();<br>    	System.out.println( <span class="hljs-string">&quot;before CAS: &quot;</span>+uDemo.state);<br>    	<span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> unsafe.compareAndSwapInt(uDemo,stateoffset,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>		System.out.println(success);<br>		System.out.println( <span class="hljs-string">&quot;after CAS: &quot;</span>+uDemo.state);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="atomic"><a class="markdownIt-Anchor" href="#atomic"></a> Atomic</h4>
<p>在<code>atomic</code>包中主要有四种类型的原子更新类：原子更新基本类型、原子更新数组类型、原子更新引用和原子更新属性。<br />
这些原子类都用了无锁的概念，或是直接使用<code>CAS</code>操作的线程安全类型</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AtomicBoolean</td>
<td><strong>原子更新基本类型</strong></td>
<td>原子更新布尔变量</td>
</tr>
<tr>
<td>AtomicInteger</td>
<td><strong>原子更新基本类型</strong></td>
<td>原子更新整型变量</td>
</tr>
<tr>
<td>AtomicLong</td>
<td><strong>原子更新基本类型</strong></td>
<td>原子更新长整型变量</td>
</tr>
<tr>
<td>AtomicIntegerArray</td>
<td><strong>原子更新数组</strong></td>
<td>原子更新整型数组的某个元素</td>
</tr>
<tr>
<td>AtomicLongArray</td>
<td><strong>原子更新数组</strong></td>
<td>原子更新长整型数组的某个元素</td>
</tr>
<tr>
<td>AtomicReferenceArray</td>
<td><strong>原子更新数组</strong></td>
<td>原子更新引用类型数组的某个元素</td>
</tr>
<tr>
<td>AtomicReference</td>
<td><strong>原子更新引用类型</strong></td>
<td>原子更新引用类型</td>
</tr>
<tr>
<td>AtomicReferenceFieldUpdater</td>
<td><strong>原子更新引用类型</strong></td>
<td>原子更新引用类型里的字段</td>
</tr>
<tr>
<td>AtomicMarkableReference</td>
<td><strong>原子更新引用类型</strong></td>
<td>原子更新带有标记位的引用类型</td>
</tr>
<tr>
<td>AtomicIntegerFieldUpdater</td>
<td><strong>原子更新字段类</strong></td>
<td>原子更新整型字段</td>
</tr>
<tr>
<td>AtomicLongFieldUpdater</td>
<td><strong>原子更新字段类</strong></td>
<td>原子更新长整型字段</td>
</tr>
<tr>
<td>AtomicStampedReference</td>
<td><strong>原子更新字段类</strong></td>
<td>原子更新带有版本号的引用类型</td>
</tr>
</tbody>
</table>
<p>在原子类中有相应的操作方法，以<code>AtomicInteger</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br><br><span class="hljs-comment">//addAndGet()以原子方式将给定值添加到当前值，并在添加后返回新值。</span><br>System.out.println(<span class="hljs-string">&quot;addAndGet event: &quot;</span> + atomicInteger.addAndGet(<span class="hljs-number">2</span>));<br>System.out.println(<span class="hljs-string">&quot;addAndGet after: &quot;</span> + atomicInteger);<br><span class="hljs-comment">//getAndAdd()以原子方式将给定值添加到当前值并返回旧值。</span><br>System.out.println(<span class="hljs-string">&quot;getAndAdd event: &quot;</span> + atomicInteger.getAndAdd(<span class="hljs-number">2</span>));<br>System.out.println(<span class="hljs-string">&quot;getAndAdd after: &quot;</span> + atomicInteger);<br><span class="hljs-comment">//incrementAndGet()以原子方式将当前值递增1并在递增后返回新值。它相当于i ++操作。</span><br>System.out.println(<span class="hljs-string">&quot;incrementAndGet event: &quot;</span> + atomicInteger.incrementAndGet());<br>System.out.println(<span class="hljs-string">&quot;incrementAndGet after: &quot;</span> + atomicInteger);<br><span class="hljs-comment">//getAndIncrement()以原子方式递增当前值并返回旧值。它相当于++ i操作。</span><br>System.out.println(<span class="hljs-string">&quot;getAndIncrement event: &quot;</span> + atomicInteger.getAndIncrement());<br>System.out.println(<span class="hljs-string">&quot;getAndIncrement after: &quot;</span> + atomicInteger);<br><span class="hljs-comment">//decrementAndGet()原子地将当前值减1并在减量后返回新值。它等同于i-操作。</span><br>System.out.println(<span class="hljs-string">&quot;decrementAndGet event: &quot;</span> + atomicInteger.decrementAndGet());<br>System.out.println(<span class="hljs-string">&quot;decrementAndGet after: &quot;</span> + atomicInteger);<br><span class="hljs-comment">//getAndDecrement()以原子方式递减当前值并返回旧值。它相当于-i操作。</span><br>System.out.println(<span class="hljs-string">&quot;getAndDecrement event: &quot;</span> + atomicInteger.getAndDecrement());<br>System.out.println(<span class="hljs-string">&quot;getAndDecrement after: &quot;</span> + atomicInteger);<br></code></pre></div></td></tr></table></figure>
<p>每个原子类都会存在一个方法<code>compareAndSet</code>，它的作用是<font style="color:red">在多线程并发的情况下将当前状态值与旧值比较，当在某一线程修改值时，其他线程已经将该值修改了即当前状态值和旧值不一致，这时用<code>compareAndSet</code>方法就可以判断该值是否已经被修改，如果没被修改则成功赋值</font></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">do</span>&#123;<br>	oldValue = atomicInt.get();<br>	newValue = Math.max(oldValue, atomicInt);<br>&#125;<span class="hljs-keyword">while</span>(!largest.compareAndSet(oldValue, newValue);<br></code></pre></div></td></tr></table></figure>
<p>在<code>atomic</code>包下还有4个原子操作类，它们都依赖于<code>atomic</code>包中的<code>Striped64</code>实现：<br />
<code>LongAdder</code>、<code>LongAccumulator</code>、<code>DoubleAdder</code>、<code>DoubleAccumulator</code>是JDK1.8提供的针对<code>long</code>和<code>double</code>类型的累加器实现，LongAdder和DoubleAdder只针对数值的增减，LongAccumulator和DoubleAccumulator针对自定义函数的增减。</p>
<h3 id="juc集合"><a class="markdownIt-Anchor" href="#juc集合"></a> JUC集合</h3>
<p><font style="color:grey">待编纂。。</font></p>
<h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3>
<p><font style="color:grey">待编纂。。</font></p>
<h3 id="juc工具类"><a class="markdownIt-Anchor" href="#juc工具类"></a> JUC工具类</h3>
<p><font style="color:grey">待编纂。。</font></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/helloworld/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/helloworld/categories/Java/API/">API</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/helloworld/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/helloworld/tags/JDK/">JDK</a>
                    
                      <a class="hover-with-bg" href="/helloworld/tags/API/">API</a>
                    
                      <a class="hover-with-bg" href="/helloworld/tags/JUC/">JUC</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/helloworld/notes/Java/Spring/Spring/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/helloworld/notes/Java/API/Java%E9%9B%86%E5%90%88/">
                        <span class="hidden-mobile">Java集合</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/helloworld/js/events.js" ></script>
<script  src="/helloworld/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/helloworld/js/local-search.js" ></script>



  
    <script  src="/helloworld/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js" ></script>
  
  
    <script  src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdnjs.cloudflare.com/ajax/libs/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/helloworld/js/boot.js" ></script>


</body>
</html>
