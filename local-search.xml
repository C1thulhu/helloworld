<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/helloworld/notes/Middleware/Redis/"/>
    <url>/helloworld/notes/Middleware/Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待编纂。</font></p><p>参考文章：</p><ul><li><a href="https://www.runoob.com/redis/redis-tutorial.html">Redis 教程-菜鸟教程</a></li><li><a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-overview.html">Redis教程 - Redis知识体系详解</a></li></ul><h2 id="redis概念"><a class="markdownIt-Anchor" href="#redis概念"></a> #Redis概念</h2><p>  Redis是一种内存高速缓存数据库，支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p><p>Redis优点：</p><ul><li>读写新能优异</li><li>数据类型丰富</li><li>特性丰富</li><li>发布订阅</li><li>原子性</li><li>持久化</li><li>分布式</li></ul><h2 id="redis数据类型"><a class="markdownIt-Anchor" href="#redis数据类型"></a> #Redis数据类型</h2><p>  <font style="color:red">首先对redis来说，所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型。</font></p><h3 id="基础数据类型"><a class="markdownIt-Anchor" href="#基础数据类型"></a> 基础数据类型</h3><p>常见的5种数据类型，分别是：String、List、Set、Zset、Hash。</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/redis-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B.jpeg" alt="redis-基础类型" /></p><p>5种类型的特性如下表所示：</p><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td><strong>String字符串</strong></td><td>可以是字符串、整数或浮点数</td><td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td></tr><tr><td><strong>List列表</strong></td><td>一个链表，链表上的每个节点都包含一个字符串</td><td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td></tr><tr><td><strong>Set集合</strong></td><td>包含字符串的无序集合</td><td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td></tr><tr><td><strong>Hash散列</strong></td><td>包含键值对的无序散列表</td><td>包含方法有添加、获取、删除单个元素</td></tr><tr><td><strong>Zset有序集合</strong></td><td>和散列一样，用于存储键值对</td><td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td></tr></tbody></table><ol><li><p><strong>String</strong></p><p><font style="color:red">String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</font></p><p>相关命令：</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>GET</td><td>获取存储在给定键中的值</td><td><code>GET name</code></td></tr><tr><td>SET</td><td>设置存储在给定键中的值</td><td><code>SET name value</code></td></tr><tr><td>DEL</td><td>删除存储在给定键中的值</td><td><code>DEL name</code></td></tr><tr><td>INCR</td><td>将键存储的值加1</td><td><code>INCR key</code></td></tr><tr><td>DECR</td><td>将键存储的值减1</td><td><code>DECR key</code></td></tr><tr><td>INCRBY</td><td>将键存储的值加上整数</td><td><code>INCRBY key amount</code></td></tr><tr><td>DECRBY</td><td>将键存储的值减去整数</td><td><code>DECRBY key amount</code></td></tr></tbody></table><p><font style="color:grey">详细请参考官方文档：<a href="https://redis.io/commands/">https://redis.io/commands/</a></font></p><p>使用场景：</p><ul><li><font style="color:#00FFFF"><strong>缓存</strong>：经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</font></li><li><strong>计数器</strong>：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li><li><strong>session</strong>：常见方案spring session + redis实现session共享。</li></ul></li><li><p><strong>List列表</strong></p><p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p><p>相关命令：</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>RPUSH</td><td>将给定值推入到列表右端</td><td>RPUSH key value</td></tr><tr><td>LPUSH</td><td>将给定值推入到列表左端</td><td>LPUSH key value</td></tr><tr><td>RPOP</td><td>从列表的右端弹出一个值，并返回被弹出的值</td><td>RPOP key</td></tr><tr><td>LPOP</td><td>从列表的左端弹出一个值，并返回被弹出的值</td><td>LPOP key</td></tr><tr><td>LRANGE</td><td>获取列表在给定范围上的所有值</td><td>LRANGE key 0 -1</td></tr><tr><td>LINDEX</td><td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td><td>LINDEX key index</td></tr></tbody></table><p><font style="color:grey">详细请参考官方文档：<a href="https://redis.io/commands/">https://redis.io/commands/</a></font></p><p>应用场景：</p><ul><li><strong>微博TimeLine</strong>: 有人发布微博，用lpush加入时间轴，展示新的列表信息。</li><li><strong>消息队列</strong></li></ul></li><li><p><strong>Set集合</strong></p><p><font style="color:red">Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</font></p><p>相关命令：</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>SADD</td><td>向集合添加一个或多个成员</td><td>SADD key value</td></tr><tr><td>SCARD</td><td>获取集合的成员数</td><td>SCARD key</td></tr><tr><td>SMEMBERS</td><td>返回集合中的所有成员</td><td>SMEMBERS key member</td></tr><tr><td>SISMEMBER</td><td>判断 member 元素是否是集合 key 的成员</td><td>SISMEMBER key member</td></tr></tbody></table><p><font style="color:grey">详细请参考官方文档：<a href="https://redis.io/commands/">https://redis.io/commands/</a></font></p><p>应用场景：</p><ul><li><strong>标签</strong>（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li><li><strong>点赞，或点踩，收藏等</strong>，可以放到set中实现</li></ul></li><li><p><strong>Hash散列</strong></p><p><font style="color:red">Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</font></p><p>相关命令：</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>HSET</td><td>添加键值对</td><td>HSET hash-key sub-key1 value1</td></tr><tr><td>HGET</td><td>获取指定散列键的值</td><td>HGET hash-key key1</td></tr><tr><td>HGETALL</td><td>获取散列中包含的所有键值对</td><td>HGETALL hash-key</td></tr><tr><td>HDEL</td><td>如果给定键存在于散列中，那么就移除这个键</td><td>HDEL hash-key sub-key1</td></tr></tbody></table><p><font style="color:grey">详细请参考官方文档：<a href="https://redis.io/commands/">https://redis.io/commands/</a></font></p><p>应用场景：</p><ul><li><strong>缓存</strong>：相比string更节省空间地维护缓存信息，如用户信息，视频信息等。</li></ul></li><li><p><strong>Zset有序集合</strong></p><p><font style="color:red">Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。<strong>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序</strong>。</font></p><p>有序集合的成员是唯一的, 但分数(score)却可以重复。有序集合是通过两种数据结构实现：</p><ul><li><strong>压缩列表(ziplist)</strong>: ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li><li><strong>跳跃表（zSkiplist)</strong>: 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</li></ul><p>相关命令：</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>ZADD</td><td>将一个带有给定分值的成员添加到有序集合里面</td><td>ZADD zset-key 178 member1</td></tr><tr><td>ZRANGE</td><td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td><td>ZRANGE zset-key 0-1 withccores</td></tr><tr><td>ZREM</td><td>如果给定元素成员存在于有序集合中，那么就移除这个元素</td><td>ZREM zset-key member1</td></tr></tbody></table><p><font style="color:grey">详细请参考官方文档：<a href="https://redis.io/commands/">https://redis.io/commands/</a></font></p><p>应用场景：</p><ul><li><strong>排行榜</strong>：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li></ul></li></ol><h3 id="特殊数据类型"><a class="markdownIt-Anchor" href="#特殊数据类型"></a> 特殊数据类型</h3><ol><li><p><strong>HyperLogLogs</strong></p><p><strong>基数统计</strong>，可以非常省内存地统计各种计数的算法。在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>PFADD</td><td>添加指定元素到 HyperLogLog 中</td><td>PFADD key element [element …]</td></tr><tr><td>PFCOUNT</td><td>返回给定 HyperLogLog 的基数估算值</td><td>PFCOUNT key [key …]</td></tr><tr><td>PFMERGE</td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td><td>PFMERGE destkey sourcekey [sourcekey …]</td></tr></tbody></table></li><li><p><strong>Bitmap</strong></p><p><strong>位存储</strong>，即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。用于统计用户信息：打卡(不打卡)、 登录(未登录) 等<strong>两个状态的数据，都可以使用 Bitmaps</strong>。</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>SETBIT</td><td>添加指定元素到 Bitmap 中</td><td>SETBIT sign key value</td></tr><tr><td>GETBIT</td><td>返回Bitmap中的指定key值元素</td><td>GETBIT sign key</td></tr><tr><td>BITCOUNT</td><td>统计操作</td><td>BITCOUNT sign</td></tr></tbody></table></li><li><p><strong>geospatial</strong></p><p><strong>地理位置</strong>，用于存储地理位置信息，并对存储的信息进行操作</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>GEOADD</td><td>将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key(多个坐标以空格分割)</td><td>GEOADD key longitude latitude member …</td></tr><tr><td>GEOPOS</td><td>获取地理位置的坐标</td><td>GEOPOS key member</td></tr><tr><td>GEODIST</td><td>计算两个位置之间的距离</td><td>GEODIST key member1 member2</td></tr><tr><td>GEORADIUS</td><td>根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</td><td></td></tr><tr><td>GEORADIUSBYMEMBER</td><td>根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合</td><td></td></tr><tr><td>GEOHASH</td><td>返回一个或多个位置对象的 geohash 值</td><td></td></tr></tbody></table></li></ol><h2 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> #持久化</h2><h2 id="事件事务"><a class="markdownIt-Anchor" href="#事件事务"></a> #事件&amp;事务</h2>]]></content>
    
    
    <categories>
      
      <category>Middleware</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Middleware</tag>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8版本特性</title>
    <link href="/helloworld/notes/Java/JDK8%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"/>
    <url>/helloworld/notes/Java/JDK8%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p>参考文章：</p><ul><li><a href="https://blog.kyire.site/2021/06/17/397c083a.html#Stream-API">Java8 新特性</a></li><li><a href="https://www.pdai.tech/md/java/java8/java8-stream.html#%E7%90%86%E8%A7%A3%E6%B3%A8%E8%A7%A3-functioninterface">函数式编程</a></li><li><a href="https://www.runoob.com/java/java8-streams.html">Java 8 Stream</a></li><li><a href="https://www.pdai.tech/md/java/java8/java8-optional.html#">Optional解析</a></li></ul><h2 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> #函数式编程</h2><p><font style="color:red">面向对象编程是对数据进行抽象；函数式编程是对行为进行抽象。</font></p><h3 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> lambda表达式</h3><p>lambda表达式在Java中又称为闭包或匿名函数，lambda仅能放入如下代码:</p><ul><li>预定义使用了<code>@Functional</code>注释的函数式接口，自带一个抽象函数的方法。例如，<code>Predicate</code>、<code>Function</code>、<code>Consumer</code> 或 <code>Supplier</code>，都那么可以向其传lambda表达式。</li><li>SAM(Single Abstract Method <strong>单个抽象方法</strong>)类型。例如，若一个方法接收<code>Runnable</code>、<code>Comparable</code>或者 <code>Callable</code> 接口，都有单个抽象方法，可以传入lambda表达式</li></ul><p>这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。</p><p>lambda表达式限制只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; primes = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;);<br><span class="hljs-type">int</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">//修改域外变量会报编译时错误</span><br>primes.forEach(element -&gt; &#123; factor++; &#125;);<br><span class="hljs-comment">//访问而不作修改是可以的</span><br>primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;);<br></code></pre></div></td></tr></table></figure><h4 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用</h4><p>lambda表达式内可以使用<code>方法引用</code>，仅当该方法不修改lambda表达式提供的参数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">list.forEach(n -&gt; System.out.println(n)); <br><span class="hljs-comment">// 方法引用</span><br>list.forEach(System.out::println);  <br><span class="hljs-comment">//若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式</span><br>list.forEach((String n) -&gt; System.out.println(<span class="hljs-string">&quot;n:&quot;</span> + n));<br></code></pre></div></td></tr></table></figure><p>方法引用可以有四种情况：</p><ol><li><p>构造引用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Supplier&lt;Thread&gt; thread = Thread::<span class="hljs-keyword">new</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>对象::实例方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>Collections.addAll(list,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br>list.forEach(System.out::println);<br></code></pre></div></td></tr></table></figure><p><font style="color:red">这种方式<code>Lambda</code>表达式的形参列表与实例方法的实参列表类型，个数需对应，如：</font></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">list.forEach(e -&gt; System.out.println(e));<br></code></pre></div></td></tr></table></figure><p>其中的**第一个<code>e</code>**是形参，**第二个<code>e</code>**是实参，二者需一致。</p></li><li><p>类名::静态方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Double&gt; stream = Stream.generate(Math::random);<br></code></pre></div></td></tr></table></figure></li><li><p>类名::实例方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">TreeSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(String::compareTo);<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="stream-parallelstream"><a class="markdownIt-Anchor" href="#stream-parallelstream"></a> Stream &amp; parallelStream</h3><p>每个Stream都有两种模式: 顺序执行和并行执行。</p><p>顺序流:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List &lt;Person&gt; people = list.getStream.collect(Collectors.toList());<br></code></pre></div></td></tr></table></figure><p>并行流:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List &lt;Person&gt; people = list.getStream.parallel().collect(Collectors.toList());<br></code></pre></div></td></tr></table></figure><p>当使用<strong>顺序方式</strong>去遍历时，每个item读完后再读下一个item。而使用<strong>并行</strong>去遍历时，数组会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。如果是多核配置，理论上并行流则会比顺序流快上一倍。</p><blockquote><p>特点：</p><ul><li><p><code>stream</code>不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果；</p></li><li><p><code>stream</code>不会改变数据源，通常情况下会产生一个新的集合；</p></li><li><p><code>stream</code>具有延迟执行特性，只有调用终端操作时，中间操作才会执行；</p><ul><li><code>终端操作</code>：会消费流，这种操作会产生一个结果的，如果一个流被消费过了，那它就不能被重用的。</li><li><code>中间操作</code>：中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。</li></ul><p>中间操作不是立即发生的，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。</p></li><li><p><code>stream</code>不可复用，对一个已经进行过终端操作的流再次调用，会抛出异常。</p></li></ul></blockquote><p>获取Stream流：</p><ul><li>所有的 Collection 集合都可以通过 stream 默认方法获取流（顺序流）；</li><li>所有的 Collection 集合都可以通过parallelStream获取并行流</li><li>Stream 接口的静态方法 of 可以获取数组对应的流。</li><li>Arrays的静态方法stream也可以获取流</li></ul><h4 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h4><h5 id="foreach"><a class="markdownIt-Anchor" href="#foreach"></a> forEach</h5><p><font style="color:red">用于遍历的方法</font>，参数传入一个函数式接口：Consumer</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;一&quot;</span>, <span class="hljs-string">&quot;二&quot;</span>, <span class="hljs-string">&quot;三&quot;</span>);<br>stream.forEach(item‐&gt; System.out.println(item));<br></code></pre></div></td></tr></table></figure><h5 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> filter</h5><p>用于过滤，通过 filter 方法将一个流转换成另一个子集流。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Integer&gt; stream1 = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">//对流中元素过滤，设定筛选条件</span><br>Stream&lt;Integer&gt; stream2 = stream1.filter(name -&gt; &#123;<br>    <span class="hljs-keyword">if</span>(name&gt;<span class="hljs-number">1</span>&amp;&amp;name&lt;<span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;);<br><span class="hljs-comment">//遍历过滤后的流</span><br>stream2.forEach(name -&gt; System.out.println(name));<br><br></code></pre></div></td></tr></table></figure><h5 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h5><p>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建一个整数类型的流</span><br>Stream&lt;Integer&gt; stream1 = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">//把stream1流中的int类型全部转成String类型，而且可以对值做出一些修改</span><br>Stream&lt;String&gt; stream2 = stream1.map((Integer value) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;value：&quot;</span>+value;<br>&#125;);<br><br>stream2.forEach(name -&gt; System.out.println(name));<br></code></pre></div></td></tr></table></figure><h5 id="count"><a class="markdownIt-Anchor" href="#count"></a> count</h5><p>流提供 count 方法来计数其中的元素个数，该方法返回一个long值代表元素个数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">//count方法常用于与其他筛选元素的方法组合起来</span><br><span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> stream.filter(name -&gt; &#123;<br>    <span class="hljs-keyword">if</span>(name&gt;<span class="hljs-number">1</span>&amp;&amp;name&lt;<span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;).count();<br></code></pre></div></td></tr></table></figure><h5 id="concat"><a class="markdownIt-Anchor" href="#concat"></a> concat</h5><p>如果有两个流，希望合并成为一个流，那么可以使用 <strong>Stream 接口的静态方法 <code>concat</code></strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Integer&gt; streamA = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>Stream&lt;Integer&gt; streamB = Stream.of(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">//合并成一个新的流</span><br>Stream&lt;Integer&gt; result = Stream.concat(streamA, streamB);<br></code></pre></div></td></tr></table></figure><h5 id="sorted"><a class="markdownIt-Anchor" href="#sorted"></a> sorted</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = List.of(<span class="hljs-number">124</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">51</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 按照自然排序</span><br>integers.stream().sorted().forEach(System.out::println);<br><br>List&lt;Integer&gt; integers2 = List.of(<span class="hljs-number">124</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">51</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 定制排序(大到小)，需要传入Comparator接口（如果流中的是引用类型，只能用定制排序）</span><br>integers2.stream().sorted((e1,e2) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> e2-e1;<br>&#125;).forEach(System.out::println);<br><span class="hljs-comment">// 定制排序(大到小)简写</span><br>integers2.stream().sorted((e1,e2) -&gt; e2-e1).forEach(System.out::println);<br></code></pre></div></td></tr></table></figure><p><font style="color:grey">Stream的方法很多，这里只简要介绍了部分简单的使用。</font></p><table><thead><tr><th>操作</th><th>类型</th><th>返回类型</th><th>使用的类型/函数式接口</th><th>函数描述符</th></tr></thead><tbody><tr><td><code>filter</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td><code>distinct</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td></td><td></td></tr><tr><td><code>skip</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>long</code></td><td></td></tr><tr><td><code>map</code></td><td>中间</td><td><code>Stream&lt;R&gt;</code></td><td><code>Function&lt;T, R&gt;</code></td><td><code>T -&gt; R</code></td></tr><tr><td><code>flatMap</code></td><td>中间</td><td><code>Stream&lt;R&gt;</code></td><td><code>Function&lt;T,Stream&lt;R&gt;&gt;</code></td><td><code>T -&gt; Stream&lt;R&gt;</code></td></tr><tr><td><code>limit</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>long</code></td><td></td></tr><tr><td><code>sorted</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>Comparator&lt;T&gt;</code></td><td><code>(T, T) -&gt; int</code></td></tr><tr><td><code>anyMatch</code></td><td>终端</td><td><code>boolean</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td><code>noneMatch</code></td><td>终端</td><td><code>boolean</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td><code>allMatch</code></td><td>终端</td><td><code>boolean</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td><code>findAny</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td></td><td></td></tr><tr><td><code>findFirst</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td></td><td></td></tr><tr><td><code>forEach</code></td><td>终端</td><td><code>void</code></td><td><code>Consumer&lt;T&gt;</code></td><td><code>T -&gt; void</code></td></tr><tr><td><code>collect</code></td><td>终端</td><td><code>R</code></td><td><code>Collector&lt;T, A, R&gt;</code></td><td></td></tr><tr><td><code>reduce</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>(T, T) -&gt; T</code></td></tr><tr><td><code>count</code></td><td>终端</td><td><code>long</code></td><td></td><td></td></tr></tbody></table><h3 id="functionalinterfa"><a class="markdownIt-Anchor" href="#functionalinterfa"></a> FunctionalInterfa</h3><p><font style="color:red">只包含了一个抽象方法的接口，称为函数式接口（可以有多个非抽象方法）。</font>可以使用<code>@FunctionalInterface</code>注解自定义声明。</p><blockquote><p>JDK 1.8 之前已有的函数式接口：</p><ul><li><p>java.lang.Runnable</p></li><li><p>java.util.concurrent.Callable</p></li><li><p>java.security.PrivilegedAction</p></li><li><p>java.util.Comparator</p></li><li><p>java.io.FileFilter</p></li><li><p>java.nio.file.PathMatcher</p></li><li><p>java.lang.reflect.InvocationHandler</p></li><li><p>java.beans.PropertyChangeListener</p></li><li><p>java.awt.event.ActionListener</p></li><li><p>javax.swing.event.ChangeListener</p></li></ul><p>JDK 1.8 新增加的函数接口：</p><ul><li>java.util.function</li></ul></blockquote><p>如果一个类型被这个注解修饰，那么编译器会要求这个类型必须满足如下条件:</p><ul><li>这个类型必须是一个interface，而不是其他的注解类型、枚举enum或者类class</li><li>这个类型必须满足function interface的所有要求，如你个包含两个抽象方法的接口增加这个注解，会有编译错误。</li></ul><p><font style="color:red">编译器会自动把满足<code>function interface</code>要求的接口自动识别为<code>function interface</code>，所以你不需要对接口增加@FunctionInterface注解。</font></p><h4 id="自定义函数接口"><a class="markdownIt-Anchor" href="#自定义函数接口"></a> 自定义函数接口</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TestInterface test=()-&gt;System.out.println(<span class="hljs-string">&quot;Test&quot;</span>);;<br>        test.test();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="四大函数接口"><a class="markdownIt-Anchor" href="#四大函数接口"></a> 四大函数接口</h4><blockquote><ul><li>消费型接口: Consumer&lt; T&gt; void accept(T t)有参数，无返回值的抽象方法；</li><li>供给型接口: Supplier &lt; T&gt; T get() 无参有返回值的抽象方法；</li><li>断定型接口: Predicate<T> boolean test(T t):有参，但是返回值类型是固定的boolean；</li><li>函数型接口: Function&lt;T,R&gt; R apply(T t)有参有返回值的抽象方法；</li></ul></blockquote><h2 id="optional"><a class="markdownIt-Anchor" href="#optional"></a> #Optional</h2><p>Java 8中引入的一个新类<code>Optional</code>。Javadoc对<code>Optional</code>类的描述如下:</p><blockquote><p>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p></blockquote><ul><li><p><code>of</code>方法通过工厂方法创建<code>Optional</code>类。需要注意的是，创建对象时传入的参数不能为<code>null</code>。如果传入参数为<code>null</code>，则抛出<code>NullPointerException</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//调用工厂方法创建Optional实例</span><br>Optional&lt;String&gt; name = Optional.of(<span class="hljs-string">&quot;Sanaulla&quot;</span>);<br><span class="hljs-comment">//传入参数为null，抛出NullPointerException.</span><br>Optional&lt;String&gt; someNull = Optional.of(<span class="hljs-literal">null</span>);<br></code></pre></div></td></tr></table></figure></li><li><p><code>ofNullable</code>与<code>of</code>方法相似，唯一的区别是<strong>可以接受参数为<code>null</code>的情况</strong>，如果指定的值为null，则返回一个空的Optional。示例如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//下面创建了一个不包含任何值的Optional实例</span><br><span class="hljs-type">Optional</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> Optional.ofNullable(<span class="hljs-literal">null</span>);<br></code></pre></div></td></tr></table></figure></li><li><p><code>isPresent</code>，如果值存在返回true，否则返回false；</p></li><li><p><code>get</code>，如果Optional有值则将其返回，否则抛出NoSuchElementException；</p></li><li><p><code>ifPresent</code>，如果Optional实例有值则为其调用**<code>consumer</code>接口**，否则不做处理；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//ifPresent方法接受lambda表达式作为参数。</span><br><span class="hljs-comment">//lambda表达式对Optional的值调用consumer进行处理。</span><br>name.ifPresent((value) -&gt; &#123;<br>  System.out.println(<span class="hljs-string">&quot;The length of the value is: &quot;</span> + value.length());<br>&#125;);<br></code></pre></div></td></tr></table></figure></li><li><p><code>orElse</code>，如果有值则将其返回，否则返回orElse方法传入的参数。</p></li><li><p><code>orElseGet</code>与<code>orElse方法</code>类似，区别在于得到的默认值。<code>orElse</code>方法将传入的字符串作为默认值，<code>orElseGet</code>方法可以接受**<code>Supplier</code>接口**的实现用来生成默认值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//orElseGet可以接受一个lambda表达式生成默认值。</span><br>System.out.println(name.orElseGet(() -&gt; <span class="hljs-string">&quot;Default Value&quot;</span>));<br></code></pre></div></td></tr></table></figure></li><li><p><code>orElseThrow</code>，在<code>orElseGet</code>方法中，我们传入一个<code>Supplier</code>接口。然而，在<code>orElseThrow</code>中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">//orElseThrow与orElse方法类似。与返回默认值不同，</span><br>  <span class="hljs-comment">//orElseThrow会抛出lambda表达式或方法生成的异常 </span><br>  empty.orElseThrow(ValueAbsentException::<span class="hljs-keyword">new</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>  System.out.println(ex.getMessage());<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ValueAbsentException</code>定义：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueAbsentException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ValueAbsentException</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ValueAbsentException</span><span class="hljs-params">(String msg)</span> &#123;<br>    <span class="hljs-built_in">super</span>(msg);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No value present in the Optional instance&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>map</code>，如果有值，则对其执行调用<code>mapping</code>函数得到返回值。如果返回值不为null，则创建包含<code>mapping</code>返回值的<code>Optional</code>作为<code>map</code>方法返回值，否则返回空<code>Optional</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。</span><br><span class="hljs-comment">//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。</span><br>Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());<br>System.out.println(upperName.orElse(<span class="hljs-string">&quot;No value found&quot;</span>));<br></code></pre></div></td></tr></table></figure></li><li><p><code>flatMap</code>与<code>map</code>类似，区别在于<code>mapping</code>函数的返回值不同。<code>map</code>方法的<code>mapping</code>函数返回值可以是任何类型T，而<code>flatMap</code>方法的<code>mapping</code>函数必须是Optional。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//在map函数返回之前会包装为Optional，但flatMap方法中的lambda表达式返回值必须是Optionl实例。 </span><br>upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));<br>System.out.println(upperName.orElse(<span class="hljs-string">&quot;No value found&quot;</span>));<span class="hljs-comment">//输出SANAULLA</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>filter</code>，如果有值并且满足断言条件返回包含该值的<code>Optional</code>，否则返回空<code>Optional</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Excel操作</title>
    <link href="/helloworld/notes/Java/API/Excel%E6%93%8D%E4%BD%9C/"/>
    <url>/helloworld/notes/Java/API/Excel%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><a href="https://blog.kyire.site/2021/08/05/13a54546.html">Java 操作Excel之POI与EasyExcel</a></li><li><a href="https://www.bilibili.com/video/BV1Ua4y1x7BK">【狂神说Java】POI及EasyExcel</a></li></ul><h2 id="excel常用的api"><a class="markdownIt-Anchor" href="#excel常用的api"></a> #Excel常用的API</h2><ul><li><p><strong>Jakarta POI</strong> 是一套用于访问微软格式文档的Java API。Jakarta POI有很多组件组成，其中有用于操作Excel格式文件的HSSF和用于操作Word的HWPF。<br />  官方主页：<a href="http://poi.apache.org/index.html">http://poi.apache.org/index.html</a><br />  API 文档：<a href="http://poi.apache.org/apidocs/index.html">http://poi.apache.org/apidocs/index.html</a></p></li><li><p><strong>EasyExcel</strong>是阿里巴巴开源的一个excel处理框架，以使用简单，节省内存著称，EasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从磁盘上一行行读取数据，逐个解析。</p><p>EasyExcel采用一行一行的解析模式，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）<br />  官方主页：<a href="https://alibaba-easyexcel.github.io/">https://alibaba-easyexcel.github.io/</a></p><p>  API 文档：<a href="https://alibaba-easyexcel.github.io/docs/current/">https://alibaba-easyexcel.github.io/docs/current/</a></p></li></ul><h2 id="poi"><a class="markdownIt-Anchor" href="#poi"></a> #POI</h2><p>POI是目前比较流行的 Java 处理 excel 框架，但是其缺点是 <strong>数据量大容易造成 OOM 异常</strong></p><p>POI基本结构：</p><table><thead><tr><th style="text-align:center">组件</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">HSSF</td><td style="text-align:center"><font style="color:red">提供读写[Microsoft Excel](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> Excel)格式档案的功能（03 版本 excel）</font></td></tr><tr><td style="text-align:center">XSSF</td><td style="text-align:center"><font style="color:red">提供读写<a href="https://baike.baidu.com/item/OOXML">Microsoft Excel OOXML</a>格式档案的功能（07 版本 excel）</font></td></tr><tr><td style="text-align:center">HWPF</td><td style="text-align:center">提供读写[Microsoft Word](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> Word)格式档案的功能</td></tr><tr><td style="text-align:center">HSLF</td><td style="text-align:center">提供读写[Microsoft PowerPoint](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> PowerPoint)格式档案的功能</td></tr><tr><td style="text-align:center">HDGF</td><td style="text-align:center">提供读写[Microsoft Visio](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> Visio)格式档案的功能</td></tr></tbody></table><p>POI操作EXCEL文件的组件有两种分别针对两种不同格式的Excel文件：</p><p>pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--xLs(03)--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--xLsx(07)--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi-ooxml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="读取操作"><a class="markdownIt-Anchor" href="#读取操作"></a> 读取操作</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * POI读取Excel</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadExcelTest</span> &#123;<br><br>    <span class="hljs-comment">// 生成文件路径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\Work\\IntelliJ IDEA\\testspace\\&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取03版本的excel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRead03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 通过文件路径得到文件输入流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(PATH + <span class="hljs-string">&quot;员工信息表_03.xls&quot;</span>);<br><br>        <span class="hljs-comment">// 通过文件输入流拿到工作簿</span><br>        <span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSSFWorkbook</span>(fileInputStream);<br><br>        <span class="hljs-comment">// 通过工作簿获取工作表</span><br>        <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> workbook.getSheetAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 拿到行数，通过循环读取数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rowCount</span> <span class="hljs-operator">=</span> sheet.getPhysicalNumberOfRows();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">rowNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; rowNum &lt; rowCount; rowNum++) &#123;<br>            <span class="hljs-comment">// 通过工作表读取行，并取到对应的列数</span><br>            <span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> sheet.getRow(rowNum);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cellCount</span> <span class="hljs-operator">=</span> row.getPhysicalNumberOfCells();<br>            <span class="hljs-comment">// 通过行读取单元格</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cellNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cellNum &lt; cellCount; cellNum++) &#123;<br>                <span class="hljs-type">Cell</span> <span class="hljs-variable">cell</span> <span class="hljs-operator">=</span> row.getCell(cellNum);<br>                <span class="hljs-comment">// 读取 excel 表格中的数据时要注意类型</span><br>                System.out.print(cell.getStringCellValue()+<span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取07版本的excel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRead07</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 通过文件路径得到文件输入流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(PATH + <span class="hljs-string">&quot;员工信息表_07.xlsx&quot;</span>);<br><br>        <span class="hljs-comment">// 通过文件输入流拿到工作簿</span><br>        <span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>(fileInputStream);<br><br>        <span class="hljs-comment">// 通过工作簿获取工作表</span><br>        <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> workbook.getSheetAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 拿到行数，通过循环读取数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rowCount</span> <span class="hljs-operator">=</span> sheet.getPhysicalNumberOfRows();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">rowNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; rowNum &lt; rowCount; rowNum++) &#123;<br>            <span class="hljs-comment">// 通过工作表读取行，并取到对应的列数</span><br>            <span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> sheet.getRow(rowNum);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cellCount</span> <span class="hljs-operator">=</span> row.getPhysicalNumberOfCells();<br>            <span class="hljs-comment">// 通过行读取单元格</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cellNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cellNum &lt; cellCount; cellNum++) &#123;<br>                <span class="hljs-type">Cell</span> <span class="hljs-variable">cell</span> <span class="hljs-operator">=</span> row.getCell(cellNum);<br>                <span class="hljs-comment">// 读取 excel 表格中的数据时要注意类型</span><br>                System.out.print(cell.getStringCellValue()+<span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="写入操作"><a class="markdownIt-Anchor" href="#写入操作"></a> 写入操作</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * POI写入Excel</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteExcelTest</span> &#123;<br><br>    <span class="hljs-comment">// 生成文件路径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\Work\\IntelliJ IDEA\\testspace\\&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 写入03版本的excel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWrite03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建工作簿</span><br>        <span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSSFWorkbook</span>();<br><br>        <span class="hljs-comment">// 创建工作表</span><br>        <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> workbook.createSheet(<span class="hljs-string">&quot;员工信息表&quot;</span>);<br><br>        <span class="hljs-comment">// 创建第一行</span><br>        <span class="hljs-type">Row</span> <span class="hljs-variable">row1</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 创建单元格</span><br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell11</span> <span class="hljs-operator">=</span> row1.createCell(<span class="hljs-number">0</span>);<br>        cell11.setCellValue(<span class="hljs-string">&quot;姓名&quot;</span>);<br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell12</span> <span class="hljs-operator">=</span> row1.createCell(<span class="hljs-number">1</span>);<br>        cell12.setCellValue(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">// 创建第二行</span><br>        <span class="hljs-type">Row</span> <span class="hljs-variable">row2</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 创建单元格</span><br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell21</span> <span class="hljs-operator">=</span> row2.createCell(<span class="hljs-number">0</span>);<br>        cell21.setCellValue(<span class="hljs-string">&quot;出生日期&quot;</span>);<br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell22</span> <span class="hljs-operator">=</span> row2.createCell(<span class="hljs-number">1</span>);<br>        cell22.setCellValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>().toString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br><br>        <span class="hljs-comment">// 生成表 io流 -- 03版本使用xls后缀名</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(PATH + <span class="hljs-string">&quot;员工信息表_03.xls&quot;</span>);<br>        workbook.write(fileOutputStream);<br><br>        <span class="hljs-comment">// 关闭流</span><br>        fileOutputStream.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 写入07版本的excel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWrite07</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建工作簿</span><br>        <span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>();<br><br>        <span class="hljs-comment">// 创建工作表</span><br>        <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> workbook.createSheet(<span class="hljs-string">&quot;员工信息表&quot;</span>);<br><br>        <span class="hljs-comment">// 创建第一行</span><br>        <span class="hljs-type">Row</span> <span class="hljs-variable">row1</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 创建单元格</span><br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell11</span> <span class="hljs-operator">=</span> row1.createCell(<span class="hljs-number">0</span>);<br>        cell11.setCellValue(<span class="hljs-string">&quot;姓名&quot;</span>);<br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell12</span> <span class="hljs-operator">=</span> row1.createCell(<span class="hljs-number">1</span>);<br>        cell12.setCellValue(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">// 创建第二行</span><br>        <span class="hljs-type">Row</span> <span class="hljs-variable">row2</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 创建单元格</span><br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell21</span> <span class="hljs-operator">=</span> row2.createCell(<span class="hljs-number">0</span>);<br>        cell21.setCellValue(<span class="hljs-string">&quot;出生日期&quot;</span>);<br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell22</span> <span class="hljs-operator">=</span> row2.createCell(<span class="hljs-number">1</span>);<br>        cell22.setCellValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>().toString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br><br>        <span class="hljs-comment">// 生成表 io流 -- 07版本使用xlsx后缀名</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(PATH + <span class="hljs-string">&quot;员工信息表_07.xlsx&quot;</span>);<br>        workbook.write(fileOutputStream);<br><br>        <span class="hljs-comment">// 关闭流</span><br>        fileOutputStream.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="高级操作"><a class="markdownIt-Anchor" href="#高级操作"></a> 高级操作</h3><p>POI还支持对Excel表格的一些复杂操作，如合并单元格，修改单元格样式等。详细操作参考文档：<a href="https://poi.apache.org/components/spreadsheet/quick-guide.html">https://poi.apache.org/components/spreadsheet/quick-guide.html</a></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Workbook</span> <span class="hljs-variable">wb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSSFWorkbook</span>();<br><span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> wb.createSheet(<span class="hljs-string">&quot;new sheet&quot;</span>);<br><span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">1</span>);<br><span class="hljs-type">Cell</span> <span class="hljs-variable">cell</span> <span class="hljs-operator">=</span> row.createCell(<span class="hljs-number">1</span>);<br>cell.setCellValue(<span class="hljs-string">&quot;This is a test&quot;</span>);<br><span class="hljs-comment">//合并单元格</span><br>sheet.addMergedRegion(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CellRangeAddress</span>(<br>        <span class="hljs-number">1</span>, <span class="hljs-comment">//first row (0-based)</span><br>        <span class="hljs-number">1</span>, <span class="hljs-comment">//last row  (0-based)</span><br>        <span class="hljs-number">1</span>, <span class="hljs-comment">//first column (0-based)</span><br>        <span class="hljs-number">2</span>  <span class="hljs-comment">//last column  (0-based)</span><br>));<br><br><span class="hljs-comment">// 创建一个新字体</span><br><span class="hljs-type">Font</span> <span class="hljs-variable">font</span> <span class="hljs-operator">=</span> wb.createFont();<br>font.setFontHeightInPoints((<span class="hljs-type">short</span>)<span class="hljs-number">24</span>);<br>font.setFontName(<span class="hljs-string">&quot;Courier New&quot;</span>);<br>font.setItalic(<span class="hljs-literal">true</span>);<br>font.setStrikeout(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//赋给CellStyle作为样式使用</span><br><span class="hljs-type">CellStyle</span> <span class="hljs-variable">style</span> <span class="hljs-operator">=</span> wb.createCellStyle();<br>style.setFont(font);<br><span class="hljs-comment">//将样式赋给单元格</span><br>cell.setCellStyle(style);<br></code></pre></div></td></tr></table></figure><h2 id="easyexcel"><a class="markdownIt-Anchor" href="#easyexcel"></a> #EasyExcel</h2><p>EasyExcel 是 Alibaba 开源的一个 excel 处理框架，特点是 <strong>使用简单、节约内存</strong>。</p><p>pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入easyexcel依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easyexcel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>与POI不同，EasyExcel操作 <code>03</code> 版本的 <code>excel</code>，只需要在读写操作时传入 <code>excelType</code> 参数</p><h3 id="读取操作-2"><a class="markdownIt-Anchor" href="#读取操作-2"></a> 读取操作</h3><p>读取Excel表示例：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/ExcelDemo.png" alt="image-20220623160312762" /></p><p>读取对象实体类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@EqualsAndHashCode</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexOrNameData</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 强制读取第三列 这里不建议 index 和 name 同时用，要么一个对象只用index，要么一个对象只用name去匹配</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExcelProperty(index = 2)</span><br>    <span class="hljs-keyword">private</span> Double doubleData;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用名字去匹配，这里需要注意，如果名字重复，会导致只有一个字段读取到数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ExcelProperty(&quot;字符串标题&quot;)</span><br>    <span class="hljs-keyword">private</span> String string;<br>    <span class="hljs-meta">@ExcelProperty(&quot;日期标题&quot;)</span><br>    <span class="hljs-keyword">private</span> Date date;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="写入操作-2"><a class="markdownIt-Anchor" href="#写入操作-2"></a> 写入操作</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EasyExcelWrite</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最简单的写</span><br><span class="hljs-comment">     * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;<span class="hljs-doctag">@link</span> DemoData&#125;</span><br><span class="hljs-comment">     * &lt;p&gt;2. 直接写即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleWrite</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> PATH + <span class="hljs-string">&quot;easyexcel07.xlsx&quot;</span>;<br>        <span class="hljs-comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span><br>        <span class="hljs-comment">// 如果这里想使用 03版本 则 传入excelType参数即可</span><br>        EasyExcel.write(fileName, DemoData.class).sheet(<span class="hljs-string">&quot;模板&quot;</span>).doWrite(data());<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/helloworld/notes/DT/hexo/"/>
    <url>/helloworld/notes/DT/hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p>参考文章：</p><ul><li><a href="https://blog.kyire.site/2021/02/06/8fe2b6a8.html">Hexo+Gitee 搭建个人博客</a></li><li><a href="https://blog.kyire.site/2022/06/16/47488464.html">使用 GitHub Actions 自动发布Hexo博客</a></li><li><a href="https://hexo.io/zh-cn/docs/">hexo文档</a></li></ul><h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> #环境搭建</h2><h3 id="git"><a class="markdownIt-Anchor" href="#git"></a> Git</h3><ul><li><p>在Windows上使用git，可以从Git官网直接下载<a href="https://git-scm.com/downloads">安装程序</a>，然后按默认选项安装即可。</p></li><li><p>安装完成后，在cmd界面输入<code>git --version</code>，如果正常返回git版本号，就说明安装成功。</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">C:\Users\Admin&gt; git <span class="hljs-literal">--version</span><br>git version <span class="hljs-number">2.33</span>.<span class="hljs-number">1</span>.windows.<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure></li><li><p>桌面单击右键打开快捷菜单上会直接显示<code>Git Bash Here</code>选项，用来快速打开git。</p></li></ul><h3 id="nodejs"><a class="markdownIt-Anchor" href="#nodejs"></a> Node.js</h3><p><code>Hexo</code>是基于 Node.js 制作的静态博客，我们要用到 Node.js 里面的<a href="https://www.npmjs.cn/">npm</a>(node package manager)包管理器来安装插件。</p><ul><li><p>首先从<a href="https://nodejs.org/">Node.js官网</a>下载对应平台的安装程序，同样也可以直接按照默认选项安装即可。</p></li><li><p>安装成功后，在cmd界面输入<code>node -v</code>和<code>npm -v</code>以验证是否成功：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">C:\Users\Admin&gt;node <span class="hljs-literal">-v</span><br>v14.<span class="hljs-number">17.6</span><br><br>C:\Users\Admin&gt;npm <span class="hljs-literal">-v</span><br><span class="hljs-number">6.14</span>.<span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="hexo"><a class="markdownIt-Anchor" href="#hexo"></a> Hexo</h3><p>安装Hexo，我们需要借助 <code>npm</code> 工具来安装，但是因为npm的远程服务器在国外，所以有时候难免出现访问过慢，甚至无法访问的情况。<br />我们可以使用淘宝的cnpm代替解决这个问题，而修改方法有两种：</p><ol><li><p>直接安装cnpm 安装淘宝提供的cnpm，并更改服务器地址为淘宝的国内地址如：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> cnpm <span class="hljs-literal">--registry</span>=https://registry.npm.taobao.org<br></code></pre></div></td></tr></table></figure><p>通过<code>cnpm -v</code>命令查看版本号验证是否安装成功；</p><p>这种方式在需要下载安装包时用<code>cnpm</code>替代<code>npm</code>，如：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">cnpm install <span class="hljs-literal">-g</span> hexo<span class="hljs-literal">-cli</span><br></code></pre></div></td></tr></table></figure></li><li><p>替换npm仓库地址为淘宝镜像地址：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></div></td></tr></table></figure><p>通过<code>npm config get registry</code>查看版本号验证是否更改成功。</p></li></ol><p>安装 Hexo命令：<code>cnpm install -g hexo-cli</code> 或 <code>npm install -g hexo-cli</code>，</p><p>并且通过<code>Hexo -v</code>验证是否安装成功。</p><h2 id="初始化hexo"><a class="markdownIt-Anchor" href="#初始化hexo"></a> #初始化Hexo</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">hexo init &lt;folder&gt;<br><span class="hljs-built_in">cd</span> &lt;folder&gt;<br>npm install<br></code></pre></div></td></tr></table></figure><p>初始化创建的项目如下：<br />.<br />|-- node_modules <font style="color:yellow">(依赖包)</font><br />|-- scaffolds <font style="color:yellow">(生成文章的模板)</font><br />|-- source <font style="color:yellow">(资源文件夹)</font><br />|   |--  _posts <font style="color:yellow">(存放文章文件夹)</font><br />|-- themes <font style="color:yellow">(主题)</font><br />|-- _config.yml  <font style="color:yellow">(配置文件)</font><br />|-- package.json <font style="color:yellow">(应用程序的信息)</font></p><p>其中source文件夹中<code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。<br />所以source中也可以存放一些静态资源如图片等。</p><p><strong>运行</strong></p><p>通过<code>hexo server</code>命令打开hexo服务，默认使用http://localhost:4000/访问。</p><p>默认访问界面如下：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/hexo-%E5%88%9D%E5%A7%8B%E7%95%8C%E9%9D%A2.png" alt="hexo-初始界面" /></p><h2 id="hexo指令"><a class="markdownIt-Anchor" href="#hexo指令"></a> #Hexo指令</h2><h3 id="hexo-init"><a class="markdownIt-Anchor" href="#hexo-init"></a> hexo init</h3><p>初始化Hexo，init后可接文件路径如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">hexo init D:\Data\Project\Test<br></code></pre></div></td></tr></table></figure><h3 id="hexo-server"><a class="markdownIt-Anchor" href="#hexo-server"></a> hexo server</h3><p>启动服务器。可缩写为<code>hexo s</code>默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-p</code>, <code>--port</code></td><td style="text-align:left">重设端口</td></tr><tr><td style="text-align:left"><code>-s</code>, <code>--static</code></td><td style="text-align:left">只使用静态文件</td></tr><tr><td style="text-align:left"><code>-l</code>, <code>--log</code></td><td style="text-align:left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="hexo-clean"><a class="markdownIt-Anchor" href="#hexo-clean"></a> hexo clean</h3><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="hexo-generate"><a class="markdownIt-Anchor" href="#hexo-generate"></a> hexo generate</h3><p>生成静态文件。可缩写为 <code>hexo g</code></p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-d</code>, <code>--deploy</code></td><td style="text-align:left">文件生成后立即部署网站</td></tr><tr><td style="text-align:left"><code>-w</code>, <code>--watch</code></td><td style="text-align:left">监视文件变动</td></tr><tr><td style="text-align:left"><code>-b</code>, <code>--bail</code></td><td style="text-align:left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td style="text-align:left"><code>-f</code>, <code>--force</code></td><td style="text-align:left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td style="text-align:left"><code>-c</code>, <code>--concurrency</code></td><td style="text-align:left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h3 id="hexo-deploy"><a class="markdownIt-Anchor" href="#hexo-deploy"></a> hexo deploy</h3><p>部署网站。可缩写为<code>hexo d</code></p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-g</code>, <code>--generate</code></td><td style="text-align:left">部署之前预先生成静态文件</td></tr></tbody></table><p>以上5个命令足以用于部署个人静态网站，更详细的指令使用请参考<a href="https://hexo.io/zh-cn/docs/commands">hexo官方文档</a></p><h2 id="部署网站"><a class="markdownIt-Anchor" href="#部署网站"></a> #部署网站</h2><ul><li>首先需要创建一个git仓库并复制仓库地址：</li></ul><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/hexo-%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93.png" alt="hexo-创建git仓库" /></p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/hexo-git%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80.png" alt="image-20220621181615257" /></p><ul><li>打开 Hexo 的配置文件<code>_config.yml</code></li></ul><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: https://github.com/C1thulhu/MyBlog.git <span class="hljs-comment">#仓库的url</span><br>  branch: master<br></code></pre></div></td></tr></table></figure><ul><li>安装Hexo插件</li></ul><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">cnpm install hexo<span class="hljs-literal">-deployer-git</span> <span class="hljs-literal">--save</span>  <span class="hljs-comment">#通过cpnm安装git插件</span><br>git config <span class="hljs-literal">--global</span> user.email <span class="hljs-string">&#x27;******@qq.com&#x27;</span>  <span class="hljs-comment">#设置git邮箱（git的注册邮箱）</span><br>git config <span class="hljs-literal">--global</span> user.name <span class="hljs-string">&#x27;****&#x27;</span>            <span class="hljs-comment">#设置用户名（git的y注册昵称）</span><br></code></pre></div></td></tr></table></figure><ul><li>上传</li></ul><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">hexo d  <span class="hljs-comment">#上传到git的远端仓库</span><br><span class="hljs-comment"># 在上传时，需要再次输入git的用户名username和密码password</span><br></code></pre></div></td></tr></table></figure><p>上传会将生成的静态文件(public文件夹)提交到git仓库中。</p><p>上传后github会自动部署页面：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/hexo-github%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%A1%B5%E9%9D%A2.png" alt="hexo-github自动部署页面" /></p><p>如果使用的是gitee，代码上传后还需要手动启动GiteePages服务：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/hexo-GiteePages1.png" alt="hexo-GiteePages1" /></p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/hexo-GiteePages2.png" alt="hexo-GiteePages2.png" /></p><h2 id="hexo主题"><a class="markdownIt-Anchor" href="#hexo主题"></a> #Hexo主题</h2><p>此博客使用主题为 <a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></p><p>你可以在hexo官网找到各种各样的博客主题：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><h2 id="github-actions自动发布博客"><a class="markdownIt-Anchor" href="#github-actions自动发布博客"></a> #GitHub Actions自动发布博客</h2><h3 id="github-actions"><a class="markdownIt-Anchor" href="#github-actions"></a> GitHub Actions</h3><p><code>GitHub Actions</code> 是一个持续集成和持续交付 (<code>CI/CD</code>) 平台，可用于自动执行构建、测试和部署管道。 我们可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。</p><h3 id="环境搭建-2"><a class="markdownIt-Anchor" href="#环境搭建-2"></a> 环境搭建</h3><ul><li>私有Hexo源码仓库：<code>blog-source</code></li><li><code>Github</code>公共静态页面仓库：<code>MyBlog</code></li><li>国内环境对<code>GitHub</code>的访问总是会很慢或者打不开，为确保正常浏览同时设立<code>Gitee</code>公共静态页面仓库</li></ul><h4 id="密钥配置"><a class="markdownIt-Anchor" href="#密钥配置"></a> 密钥配置</h4><ol><li><p>生成ssh密钥对</p><p>执行命令：<code>ssh-keygen -f blog-source-key -t rsa -C &quot;username@example.com&quot;</code>，邮箱是GitHub绑定邮箱。<font style="color:red"><strong>Enter passphrase时不要键入，直接回车！</strong></font>命令执行后会生成两个文件：<code>blog-source-key</code>(私钥) 和 <code>blog-source-key.pub</code>(公钥)</p><p><img src="D:%5Cdevelop%5Cworkspace%5Coss-repositorie%5Cssh%E5%AF%86%E9%92%A5.jpg" alt="ssh密钥" /></p></li><li><p>添加公钥至公共静态页面仓库</p><p><code>MyBlog</code>仓库&gt;<code>Settings</code>&gt; <code>Deploy keys</code>&gt; <code>Add deploy key</code></p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E5%85%AC%E9%92%A5%E9%85%8D%E7%BD%AE.png" alt="公钥配置" /></p><p><code>Title</code>只要符合规范都可以，<code>Key</code>值填<code>blog-source-key.pub</code>中的内容，<font style = "color:red">需要勾选Allow write access！</font></p></li><li><p>添加私钥到博客源码仓库中</p><p><code>blog-source</code>仓库&gt;<code>Settings</code>&gt;<code>Secrets</code>&gt;<code>Actions</code>&gt;<code>New repository secret</code></p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E7%A7%81%E9%92%A5%E9%85%8D%E7%BD%AE.png" alt="私钥配置" /></p><p>同公钥配置<code>Name</code>只要符合规范任意命名，<code>Secret</code>填<code>helloworld-key</code>中的内容</p></li><li><p>添加Gitee 账号密码到博客源码仓库中，同私钥配置，<code>Name</code>按规范命名<code>Secret</code>填gitee密码。</p></li><li><p>添加公钥到Gitee仓库中</p><p>仓库 &gt; 管理 &gt; 部署公钥管理 &gt; 添加公钥 &gt; 添加个人公钥</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Gitee%E5%85%AC%E9%92%A5%E9%85%8D%E7%BD%AE.png" alt="Gitee公钥配置" /></p><p>其他步骤同GitHub公钥配置，需要在Gitee微信公众号中绑定Gitee账号，否则同步不通过。</p></li></ol><h4 id="配置github-actions"><a class="markdownIt-Anchor" href="#配置github-actions"></a> 配置GitHub Actions</h4><p>在博客源码仓库中编写<code>workflow</code>文件，创建<code>.github</code>&gt;<code>workflow</code>&gt;<code>deploy.yml</code>文件在仓库根目录，<code>yaml</code>文件可以任意命名。</p><p><code>deploy.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">deploy</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">paths-ignore:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;.github/**&#x27;</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">A</span> <span class="hljs-string">job</span> <span class="hljs-string">to</span> <span class="hljs-string">deploy</span> <span class="hljs-string">blog.</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v1</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">submodules:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">node</span> <span class="hljs-string">modules</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v1</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">cache</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>        <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          $&#123;&#123; runner.os &#125;&#125;-node-</span><br><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>      <span class="hljs-attr">if:</span> <span class="hljs-string">steps.cache.outputs.cache-hit</span> <span class="hljs-type">!=</span> <span class="hljs-string">&#x27;true&#x27;</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">ci</span><br><br>    <span class="hljs-comment"># Deploy hexo blog website.</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">deploy</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">sma11black/hexo-action@v1.0.4</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-comment"># 用于访问 GitHub 静态页面仓库的部署密钥（私钥）。</span><br>        <span class="hljs-attr">deploy_key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.BLOG_SOURCE</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-comment"># 用于部署的 github 帐户的用户名。</span><br>        <span class="hljs-attr">user_name:</span> <span class="hljs-string">C1thulhu</span><br>        <span class="hljs-comment"># 用于部署的 github 帐户的用户电子邮件。</span><br>        <span class="hljs-attr">user_email:</span> <span class="hljs-number">1841103203</span><span class="hljs-string">@qq.com</span><br>        <span class="hljs-attr">commit_msg:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">github.event.head_commit.message</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Get</span> <span class="hljs-string">the</span> <span class="hljs-string">output</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        echo &quot;$&#123;&#123; steps.deploy.outputs.notify &#125;&#125;&quot;</span><br><span class="hljs-string"></span>  <span class="hljs-attr">sync:</span><br>    <span class="hljs-attr">needs:</span> <span class="hljs-string">build</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Sync</span> <span class="hljs-string">to</span> <span class="hljs-string">Gitee</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">wearerequired/git-mirror-action@master</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-comment"># 用于访问 GitHub 静态页面仓库的部署密钥（私钥）。</span><br>          <span class="hljs-attr">SSH_PRIVATE_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.BLOG_SOURCE</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># 源仓库</span><br>          <span class="hljs-attr">source-repo:</span> <span class="hljs-string">git@github.com:C1thulhu/helloworld.git</span><br>          <span class="hljs-comment"># 目标仓库</span><br>          <span class="hljs-attr">destination-repo:</span> <span class="hljs-string">git@gitee.com:C1thulhu/helloworld.git</span><br>  <span class="hljs-attr">reload-pages:</span><br>    <span class="hljs-attr">needs:</span> <span class="hljs-string">sync</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">Gitee</span> <span class="hljs-string">Pages</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">yanglbme/gitee-pages-action@main</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># Gitee登录用户名</span><br>          <span class="hljs-attr">gitee-username:</span> <span class="hljs-string">C1thulhu</span><br>          <span class="hljs-comment"># Gitee账号密码</span><br>          <span class="hljs-attr">gitee-password:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.C1THULHU_GITEE</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-comment"># Gitee仓库名称，注意大小写</span><br>          <span class="hljs-attr">gitee-repo:</span> <span class="hljs-string">C1thulhu/helloworld</span><br>          <span class="hljs-comment"># 仓库分支名，根据实际情况填写</span><br>          <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DT</category>
      
      <category>git</category>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>hexo</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaIO</title>
    <link href="/helloworld/notes/Java/API/JavaIO/"/>
    <url>/helloworld/notes/Java/API/JavaIO/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><p><a href="https://www.runoob.com/java/java-file.html">Java File</a></p></li><li><p><a href="https://blog.kyire.site/2021/04/04/13a54546.html">Java-IO流</a></p></li><li><p><a href="http://www.yiidian.com/java-io/what-is-java-io.html">Java IO流教程（一点教程）</a></p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945227202752">廖雪峰的官方网站-IO</a></p></li><li><p><a href="https://blog.csdn.net/weixin_32265569/article/details/108355392">设计模式—装饰者模式</a></p></li><li><p><a href="https://blog.csdn.net/weixin_51712663/article/details/124562360">io流详细解读</a></p></li><li><p><a href="https://blog.csdn.net/K_520_W/article/details/123389551">java之BIO简介</a></p></li></ul><h2 id="file"><a class="markdownIt-Anchor" href="#file"></a> #File</h2><p>Java的标准库<code>java.io</code>提供了<code>File</code>对象来操作文件和目录。<font style="color:#00FFFF">File 类不能访问文件内容本身，如果需要访问文件内容本身，则需要使用输入/输出流。</font></p><p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。<font style="color:yellow">注意Windows平台使用<code>\</code>作为路径分隔符，在Java字符串中需要用<code>\\</code>表示一个<code>\</code>。Linux平台使用<code>/</code>作为路径分隔符。</font>例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Window平台</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Windows\\test.text&quot;</span>);<br><span class="hljs-comment">//Linux平台</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/usr/bin/test.text&quot;</span>);<br><br><span class="hljs-comment">//相对路径(假设当前目录为&quot;C:\Windows&quot;) .表示当前目录 ..表示上级目录</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;docs\\Test.text&quot;</span>);    <span class="hljs-comment">//绝对路径是 C:\Windowsdocs\Test.text</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;.\\docs\\Test.text&quot;</span>); <span class="hljs-comment">//绝对路径是 C:\Windowsdocs\Test.text</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;..\\Downloads&quot;</span>);      <span class="hljs-comment">//绝对路径是 C:\Downloads</span><br></code></pre></div></td></tr></table></figure><p>File方法归类：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">String getName()</td><td style="text-align:center">返回由此抽象路径名表示的文件或目录的名称</td><td style="text-align:center">void deleteOnExit()</td><td style="text-align:center">在虚拟机终止时，请求删除此抽象路径名表示的文件或目录</td></tr><tr><td style="text-align:center">String getParent()</td><td style="text-align:center">获取当前路径下父路径名则返回，没有则返回null</td><td style="text-align:center">String[] list()</td><td style="text-align:center">获取当前路径下的目录中的所有文件和目录的名称</td></tr><tr><td style="text-align:center">File getParentFile()</td><td style="text-align:center">获取当前路径下的父级目录，没有则返回null</td><td style="text-align:center">String[] list(FilenameFilter filter)</td><td style="text-align:center">满足指定过滤器的当前路径下的目录中的所有文件和目录的名称</td></tr><tr><td style="text-align:center">String getPath()</td><td style="text-align:center">将此路径名转换为一个路径名字符串</td><td style="text-align:center">File[] listFiles()</td><td style="text-align:center">获取当前路径下目录中的文件和目录的路径</td></tr><tr><td style="text-align:center">boolean isAbsolute()</td><td style="text-align:center">是否为绝对路径名</td><td style="text-align:center">File[] listFiles(FileFilter filter)</td><td style="text-align:center">满足指定过滤器的当前路径下目录中的文件和目录的路径</td></tr><tr><td style="text-align:center">String getAbsolutePath()</td><td style="text-align:center">获取绝对路径名</td><td style="text-align:center">boolean mkdir()</td><td style="text-align:center">创建此路径名指定的目录</td></tr><tr><td style="text-align:center">boolean canRead()</td><td style="text-align:center">是否可以读取此路径名表示的文件</td><td style="text-align:center">boolean mkdirs()</td><td style="text-align:center">创建此路径名指定的目录，包括必需但不存在的父目录</td></tr><tr><td style="text-align:center">boolean canWrite()</td><td style="text-align:center">是否可以修改此路径名表示的文件</td><td style="text-align:center">boolean renameTo(File dest)</td><td style="text-align:center">重新命名当前路径名表示的文件。</td></tr><tr><td style="text-align:center">boolean exists()</td><td style="text-align:center">文件或目录是否存在</td><td style="text-align:center">boolean setLastModified(long time)</td><td style="text-align:center">设置由此路径名所指定的文件或目录的最后一次修改时间</td></tr><tr><td style="text-align:center">boolean isDirectory()</td><td style="text-align:center">是否是一个目录</td><td style="text-align:center">boolean setReadOnly()</td><td style="text-align:center">标记此路径名指定的文件或目录，以便只可对其进行读操作</td></tr><tr><td style="text-align:center">boolean isFile()</td><td style="text-align:center">是否是一个标准文件</td><td style="text-align:center">static File createTempFile(String prefix, String suffix, File directory)</td><td style="text-align:center">在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称</td></tr><tr><td style="text-align:center">long lastModified()</td><td style="text-align:center">获取此路径名表示的文件最后一次被修改的时间</td><td style="text-align:center">static File createTempFile(String prefix, String suffix)</td><td style="text-align:center">在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称</td></tr><tr><td style="text-align:center">long length()</td><td style="text-align:center">获取此路径名表示的文件的长度</td><td style="text-align:center">int compareTo(File pathname)</td><td style="text-align:center">按字母顺序比较两个抽象路径名</td></tr><tr><td style="text-align:center">boolean createNewFile()</td><td style="text-align:center">当且仅当不存在具有此路径名指定的名称的文件时，原子地创建由此路径名指定的一个新的空文件</td><td style="text-align:center">int compareTo(Object o)</td><td style="text-align:center">按字母顺序比较抽象路径名与给定对象</td></tr><tr><td style="text-align:center">boolean delete()</td><td style="text-align:center"></td><td style="text-align:center">boolean equals(Object obj)</td><td style="text-align:center">测试此抽象路径名与给定对象是否相等</td></tr><tr><td style="text-align:center">String toString()</td><td style="text-align:center">此路径名的路径名字符串</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="io"><a class="markdownIt-Anchor" href="#io"></a> #IO</h2><p><font style="color:red">Java I/O（输入和输出）用于处理输入并产生输出，Java使用<code>Stream</code>(流)的概念来加快I/O操作的速度。</font>java.io软件包包含输入和输出操作所需的所有类。我们可以通过Java I/O API 在Java中执行文件处理。</p><p><font style="color:#00FFFF"><code>Stream</code>是数据序列。在Java中，流由字节组成。之所以称其为流，是因为它就像不断流动的水流一样。</font></p><p><font style="color:yellow">在Java中，会自动为我们创建3个流。所有这些流都随控制台附带。</font></p><ul><li><font style="color:yellow">System.out：标准输出流</font></li><li><font style="color:yellow"><a href="http://System.in">System.in</a>：  标准输入流</font></li><li><font style="color:yellow">System.err：标准错误流</font></li></ul><p>IO流可以根据处理数据类型的不同分为：字符流和字节流，或数据流向不同分为：输入流和输出流。</p><table><thead><tr><th style="text-align:center"><strong>分类</strong></th><th style="text-align:center"><strong>字节输入</strong></th><th style="text-align:center"><strong>字节输出</strong></th><th style="text-align:center"><strong>字符输入</strong></th><th style="text-align:center"><strong>字符输出</strong></th></tr></thead><tbody><tr><td style="text-align:center">抽象基类</td><td style="text-align:center">InputStream</td><td style="text-align:center">OutputStream</td><td style="text-align:center">Reader</td><td style="text-align:center">Writer</td></tr><tr><td style="text-align:center">访问文件</td><td style="text-align:center">FileInputStream</td><td style="text-align:center">FileOutputStream</td><td style="text-align:center">FileReader</td><td style="text-align:center">FileWriter</td></tr><tr><td style="text-align:center">访问数组</td><td style="text-align:center">ByteArrayInputStream</td><td style="text-align:center">ByteArrayOutputStream</td><td style="text-align:center">CharArrayReader</td><td style="text-align:center">CharArrayWriter</td></tr><tr><td style="text-align:center">访问管道</td><td style="text-align:center">PipedInputStream</td><td style="text-align:center">PipedOutputStream</td><td style="text-align:center">PipedReader</td><td style="text-align:center">PipedWriter</td></tr><tr><td style="text-align:center">访问字符串</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">StringReader</td><td style="text-align:center">StringWriter</td></tr><tr><td style="text-align:center">缓存流</td><td style="text-align:center">BufferedInputStream</td><td style="text-align:center">BufferedOutputStream</td><td style="text-align:center">BufferedReader</td><td style="text-align:center">BufferedWriter</td></tr><tr><td style="text-align:center">转换流</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">InputStreamReader</td><td style="text-align:center">OutputStreamReader</td></tr><tr><td style="text-align:center">对象流</td><td style="text-align:center">ObjectInputStream</td><td style="text-align:center">ObjectOutputStream</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">过滤流</td><td style="text-align:center">FilterInputStream</td><td style="text-align:center">FilterOutputStream</td><td style="text-align:center">FilterReader</td><td style="text-align:center">FilterWriter</td></tr><tr><td style="text-align:center">打印流</td><td style="text-align:center"></td><td style="text-align:center">PrintStream</td><td style="text-align:center"></td><td style="text-align:center">PrintWriter</td></tr><tr><td style="text-align:center">推回输入流</td><td style="text-align:center">PushbackInputStream</td><td style="text-align:center"></td><td style="text-align:center">PushbackInputReader</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">特殊流</td><td style="text-align:center">DataInputStream</td><td style="text-align:center">DataOutputStream</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">序列流</td><td style="text-align:center">SequenceInputStream</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>InputStream示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * InputStream使用示例：</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        input = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/test.txt&quot;</span>);<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-keyword">while</span> ((n = input.read()) != -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 利用while同时读取并判断</span><br>            System.out.println(n);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (input != <span class="hljs-literal">null</span>) &#123; input.close(); &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 用try ... finally来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的try(resource)的语法，</span><br><span class="hljs-comment"> * 只需要编写try语句，让编译器自动为我们关闭资源 如下：</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/test.txt&quot;</span>)) &#123;<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-keyword">while</span> ((n = input.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(n);<br>        &#125;<br>    &#125; <span class="hljs-comment">//编译器在此自动为我们写入finally并调用close()</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>  <font style="color:red">实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</font></p><h3 id="装饰者模式"><a class="markdownIt-Anchor" href="#装饰者模式"></a> 装饰者模式</h3><p><font style="color:red"><strong>装饰模式（Decorator）</strong>，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更灵活。<br /></font><br /><font style="color:grey">详细了解转至<a href="https://blog.csdn.net/weixin_32265569/article/details/108355392">设计模式—装饰者模式</a></font>，下文也会详细指出io中运用的装饰者模式。</p><p><strong>初计初衷：</strong></p><p>通常可以使用继承来实现功能的扩展，<font style="color:#00FFFF">如果这些需要扩展的功能的种类很繁多，那么继承势必生成很多子类，增加系统的复杂性；同时使用继承实现功能拓展，我们必须可预见这些拓展功能，这些功能是编译时就确定了的，是静态的。</font></p><h3 id="inputstream"><a class="markdownIt-Anchor" href="#inputstream"></a> Inputstream</h3><p><code>InputStream</code>就是Java标准库提供的最基本的输入流，抽象类<code>InputStream</code>中重要方法设计如下：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">abstract int read()</td><td style="text-align:center">读取下一个字节，如果没有则返回-1</td></tr><tr><td style="text-align:center">int read(byte b[])</td><td style="text-align:center">将读取到的数据放在 byte 数组中，该方法实际上调用read(byte b[], int off, int len)方法</td></tr><tr><td style="text-align:center">int read(byte b[], int off, int len)</td><td style="text-align:center">从第 off 位置读取<b>最多(实际可能小于)</b> len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的; 此方法会一直阻止，直到输入数据可用、检测到stream结尾或引发异常为止。</td></tr><tr><td style="text-align:center">void close()</td><td style="text-align:center">读取完，关闭流，释放资源</td></tr><tr><td style="text-align:center">long skip(long n)</td><td style="text-align:center">跳过指定个数的字节不读取</td></tr><tr><td style="text-align:center">int available()</td><td style="text-align:center">返回可读的字节数量</td></tr><tr><td style="text-align:center">synchronized void reset()</td><td style="text-align:center">重置读取位置为上次 mark 标记的位置</td></tr><tr><td style="text-align:center">synchronized void mark(int readlimit)</td><td style="text-align:center">标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断</td></tr><tr><td style="text-align:center">boolean markSupported()</td><td style="text-align:center">判断当前流是否支持标记流，和上面两个方法配套使用</td></tr><tr><td style="text-align:center">byte[] readAllBytes()</td><td style="text-align:center">JDK9新增：读取 InputStream 中的所有剩余字节，调用readNBytes(Integer.MAX_VALUE)方法</td></tr><tr><td style="text-align:center">int readNBytes(byte[] b, int off, int len)</td><td style="text-align:center">JDK9新增：从输入流读取请求的字节数并保存在byte数组中； 此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</td></tr><tr><td style="text-align:center">long transferTo(OutputStream out)</td><td style="text-align:center">JDK9新增：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中</td></tr><tr><td style="text-align:center">byte[] readNBytes(int len)</td><td style="text-align:center">JDK11更新：读取 InputStream 中的剩余字节的指定上限大小的字节内容；此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</td></tr></tbody></table><p>InputStream及其派生类实现关系：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/io-inputstream.png" alt="io-inputstream" /></p><h4 id="fileinputstream"><a class="markdownIt-Anchor" href="#fileinputstream"></a> FileInputStream</h4><p><strong>FileInputStream</strong>：从文件系统中的文件获取输入字节，获取的文件可用性取决于主机环境。</p><p><strong>构造方法：</strong></p><ol><li>FileInputStream(String name)</li></ol><p>通过打开与实际文件的连接来创建 FileInputStream ，该文件由文件系统中的路径名 name命名。</p><ol start="2"><li>FileInputStream(File file)</li></ol><p>通过打开与实际文件的连接来创建 FileInputStream ，该文件由文件系统中的 File对象 file命名。</p><ol start="3"><li>FileInputStream(FileDescriptor ds)</li></ol><p>使用文件描述符 fdObj创建 FileInputStream ，该文件描述符表示与文件系统中实际文件的现有连接。</p><p><strong>特点：</strong></p><p><font style="color:#00FFFF">FileInputStream 多用于读取诸如图像数据之类的原始字节流。使用其中<code>read()</code>方法读取中文会乱码（3字节），而使用<code>read(byte[] b)</code>方法并且不是截断读取才不会乱码。</font></p><h4 id="filterinputstream"><a class="markdownIt-Anchor" href="#filterinputstream"></a> FilterInputStream</h4><p>过滤输入流的主要功能是为基础流提供一些额外的功能。对FilterInputStream来说,常见的子类有BufferedInputStream，PushBackInputStream以及DataInputStream等，其子类总结为:</p><ul><li><p>BufferedInputStream</p><p><font style="color:red">缓冲输入流，由于基础输入流一个字节一个字节读取，频繁与磁盘进行交互，造成读取速度较低。缓冲流的存在就是先将数据读取到缓冲流(内存中)，然后一次性从内存中读取多个字符。提高读取的效率。</font></p></li><li><p>PushbackInputStream</p><p><font style="color:red">回退输入流，java中读取数据的方式是顺序读取，如果某个数据不需要读取，需要程序处理。PushBackInputStream就可以将某些不需要的数据回退到缓冲中。</font></p></li><li><p>DataInputStream</p><p><font style="color:red">数据输入流，以机器无关的方式读取Java的基本类型。</font></p></li></ul><p>FilterInputStream是io流中装饰者模式的主要体现：</p><p>以<code>BufferedInputStream</code>举例，当<code>FileInputStream</code>需要额外实现一个缓冲功能，就可以直接将<code>FileInputStream</code>传入<code>BufferedInputStream</code>的有参构造方法中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/test.txt&quot;</span>));<br></code></pre></div></td></tr></table></figure><p>而BufferedInputStream继承自FilterInputStream，构造方法也是直接将传入的<code>InputStream</code>赋给父类，</p><p>BufferedInputStream构造方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>(in, DEFAULT_BUFFER_SIZE);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">super</span>(in);<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>        &#125;<br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>FilterInputStream构造方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">FilterInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总的来说，JDK首先将<code>InputStream</code>分为两大类：</p><p>一类是直接提供数据的基础<code>InputStream</code>，如FileInputStream、ObjectInputStream等，另一类是提供额外附加功能都继承自FilterInputStream的<code>InputStream</code>，如BufferedInputStream、DataInputStream等；当需要给InputStream附加额外的功能时，将需要增强的InputStream传给提供额外附加功能<code>InputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//给FileInputStream附加缓冲功能</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/test.txt&quot;</span>));<br><br><span class="hljs-comment">//可以给InputStream附加多个功能</span><br><span class="hljs-type">PushbackInputStream</span> <span class="hljs-variable">pushbackInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushbackInputStream</span>(bufferedInputStream);<br></code></pre></div></td></tr></table></figure><h4 id="pipedinputstream"><a class="markdownIt-Anchor" href="#pipedinputstream"></a> PipedInputStream</h4><p>java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用</p><blockquote><p>大致流程：<br />我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；线程B通过读取PipedInputStream中的数据。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//使用connect方法连接PipedInputStream与PipedOutputStream方式</span><br>PipedInputStream pipedInputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PipedInputStream</span>();<br>PipedOutputStream pipedOutputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PipedOutputStream</span>();<br><span class="hljs-keyword">try</span> &#123;<br>pipedInputStream.connect(pipedOutputStream);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>pipedInputStream.connect(pipedOutputStream)</code>或者<code>pipedOutputStream.connect(pipedInputStream)</code>效果是一样的，但是要注意 <strong>只能选择其中的一个而不能两个connect同时调用</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//不使用connect方法连接PipedInputStream与PipedOutputStream方式</span><br>PipedInputStream pipedInputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PipedInputStream</span>();<br>PipedOutputStream pipedOutputStream=<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>pipedOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PipedOutputStream</span>(pipedInputStream);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><font style='color:red'><strong>在一个线程里使用PipedInpuStream和PipedOutputStream会造成死锁。</strong></font></p><h3 id="reader"><a class="markdownIt-Anchor" href="#reader"></a> Reader</h3><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">int read()</td><td style="text-align:center">读取下一个字节，如果没有则返回-1</td></tr><tr><td style="text-align:center">int read(char cbuf[])</td><td style="text-align:center">将读取到的数据放在 char 数组中，该方法实际上调用read(char cbuf[], int off, int len)方法</td></tr><tr><td style="text-align:center">int read(java.nio.CharBuffer target)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">int read(char cbuf[], int off, int len)</td><td style="text-align:center">从第 off 位置读取<b>最多(实际可能小于)</b> len 长度字节的数据放到 char 数组中，流是以 -1 来判断是否读取结束的; 此方法会一直阻止，直到输入数据可用、检测到stream结尾或引发异常为止。</td></tr><tr><td style="text-align:center">long skip(long n)</td><td style="text-align:center">跳过指定个数的字符不读取</td></tr><tr><td style="text-align:center">boolean ready()</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">void reset()</td><td style="text-align:center">重置读取位置为上次 mark 标记的位置</td></tr><tr><td style="text-align:center">void mark(int readAheadLimit)</td><td style="text-align:center">标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断</td></tr><tr><td style="text-align:center">boolean markSupported()</td><td style="text-align:center">判断当前流是否支持标记流，和上面两个方法配套使用</td></tr><tr><td style="text-align:center">void close()</td><td style="text-align:center">读取完，关闭流，释放资源</td></tr></tbody></table><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/io-reader.png" alt="io-reader" /></p><h4 id="inputstreamreader"><a class="markdownIt-Anchor" href="#inputstreamreader"></a> InputStreamReader</h4><ul><li>FileReader</li></ul><h4 id="filterreader"><a class="markdownIt-Anchor" href="#filterreader"></a> FilterReader</h4><ul><li>PushbackReader</li></ul><h4 id="bufferedreader"><a class="markdownIt-Anchor" href="#bufferedreader"></a> BufferedReader</h4><ul><li>LineNumberReader</li></ul><h3 id="outputstream"><a class="markdownIt-Anchor" href="#outputstream"></a> Outputstream</h3><p>与<code>InputStream</code>相反，<code>OutputStream</code>是Java标准库提供的最基本的输出流，抽象类OutputStream中重要方法设计如下：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">abstract void write(int b)</td><td style="text-align:center">写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。</td></tr><tr><td style="text-align:center">void write(byte b[])</td><td style="text-align:center">将数组中的所有字节写入，实际调用的是write(byte b[], int off, int len)方法。</td></tr><tr><td style="text-align:center">void write(byte b[], int off, int len)</td><td style="text-align:center">将 byte 数组从 off 位置开始，len 长度的字节写入</td></tr><tr><td style="text-align:center">void flush()</td><td style="text-align:center">强制刷新，将缓冲中的数据写入; 默认是空实现，供子类覆盖</td></tr><tr><td style="text-align:center">void close()</td><td style="text-align:center">关闭输出流，流被关闭后就不能再输出数据了; 默认是空实现，供子类覆盖</td></tr></tbody></table><p>OutputStream及其派生类实现关系：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/io-outputstream.png" alt="img" /></p><h4 id="fileoutputstream"><a class="markdownIt-Anchor" href="#fileoutputstream"></a> FileOutputStream</h4><p><strong>FileOutputStream</strong>：从文件系统中的文件获取输出字节，文件是否可用或能否可以被创建取决于基础平台，特别是某些平台一次只允许一个 FileOutputStream（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。</p><p><strong>构造方法：</strong></p><ol><li><p>FileOutputStream(String name)</p></li><li><p>FileOutputStream(String name, boolean append)</p></li><li><p>FileOutputStream(File file)</p></li><li><p>FileOutputStream(File file, boolean append)</p></li><li><p>FileOutputStream(FileDescriptor fdObj)</p><p>源码中构造方法中只有<code>FileOutputStream(FileDescriptor fdObj)</code>和其他构造方法不同，其他构造方法本质上都是调用了<code>FileOutputStream(File file, boolean append)</code>构造方法。</p></li></ol><p><strong>特点：</strong></p><p><font style="color:#00FFFF">在FileOutputStream中，append为true表示<font style="color:yellow"> 追加模式<sup>1</sup></font>，false为<font style="color:yellow"> 覆盖模式<sup>2</sup> </font>，默认false。</font></p><p><font style="color:yellow">①：追加模式是指写入时往文件原本内容中追加；</font></p><p><font style="color:yellow"> ②：覆盖模式是指写入文件时覆盖文件原本内容。</font></p><h4 id="filteroutputstream"><a class="markdownIt-Anchor" href="#filteroutputstream"></a> FilterOutputStream</h4><p>同<code>FilterInputStream</code>一样，<code>FilterOutputStream</code> 类本身只是简单地重写那些将所有请求传递给所包含输出流的 <code>OutputStream</code> 的所有方法。<code>FilterOutputStream</code> 的子类可进一步地重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。</p><ul><li><p>PrintStream</p></li><li><p>BufferedOutputStream</p><p><font style="color:red">缓冲输出流</font></p></li><li><p>DataOutputStream</p><p>允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型</p></li></ul><h3 id="writer"><a class="markdownIt-Anchor" href="#writer"></a> Writer</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">void write(int c)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">void write(char cbuf[])</td><td style="text-align:center">将数组中的所有字符写入，实际调用的是write(char cbuf[], int off, int len)方法。</td></tr><tr><td style="text-align:center">void write(String str)</td><td style="text-align:center">将数组中的所有字符串写入，实际调用的也是write(char cbuf[], int off, int len)方法。</td></tr><tr><td style="text-align:center">void write(char cbuf[], int off, int len)</td><td style="text-align:center">将 char 数组从 off 位置开始，len 长度的字节写入</td></tr><tr><td style="text-align:center">void flush()</td><td style="text-align:center">强制刷新，将缓冲中的数据写入; 默认是空实现，供子类覆盖</td></tr><tr><td style="text-align:center">void close()</td><td style="text-align:center">关闭输出流，流被关闭后就不能再输出数据了; 默认是空实现，供子类覆盖</td></tr><tr><td style="text-align:center">Writer append(CharSequence csq)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Writer append(CharSequence csq, int start, int end)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Writer append(char c)</td><td style="text-align:center"></td></tr></tbody></table><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/io-writer.png" alt="io-writer" /></p><h2 id="bio"><a class="markdownIt-Anchor" href="#bio"></a> #BIO</h2><p><strong>同步并阻塞</strong>(传统阻塞型)，服务器实现模式为<strong>一个连接一个线程</strong>，即客户端<strong>有连接请求</strong>时服务器端就需要<strong>启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销。</p><blockquote><ul><li>客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。</li><li>服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。</li></ul></blockquote><ul><li>伪异步IO</li></ul><h2 id="nio"><a class="markdownIt-Anchor" href="#nio"></a> #NIO</h2><p><strong>同步非阻塞</strong>，服务器实现模式为<strong>一个线程处理多个请</strong>求(连接)，即客户端发送的连接请求都会注册到<strong>多路复用器</strong>上，多路复用器<strong>轮询</strong>到连接有I/O请求就进行处理</p><h2 id="aio"><a class="markdownIt-Anchor" href="#aio"></a> #AIO</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础</title>
    <link href="/helloworld/notes/SQL/MySQL/"/>
    <url>/helloworld/notes/SQL/MySQL/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待编纂。</font></p><p>参考文章：</p><ul><li><a href="https://www.pdai.tech/md/db/sql-lan/sql-lan.html">SQL语法基础</a></li><li><a href="https://www.runoob.com/mysql/mysql-tutorial.html">MySQL教程 | 菜鸟教程</a></li><li></li></ul><h2 id="mysql数据类型"><a class="markdownIt-Anchor" href="#mysql数据类型"></a> #MySQL数据类型</h2><h3 id="数值类型"><a class="markdownIt-Anchor" href="#数值类型"></a> 数值类型</h3><p>MySQL 支持所有标准 SQL 数值数据类型。</p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 bytes</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 bytes</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 bytes</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 bytes</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 bytes</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 bytes</td><td>单精度<br/>浮点数值</td></tr><tr><td>DOUBLE</td><td>8 bytes</td><td>双精度<br/>浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>小数值</td></tr></tbody></table><h3 id="时间类型"><a class="markdownIt-Anchor" href="#时间类型"></a> 时间类型</h3><p>表示时间值的时间类型有DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>DATE</td><td>3 bytes</td><td>日期值</td><td>YYYY-MM-DD</td></tr><tr><td>TIME</td><td>3 bytes</td><td>时间值或持续时间</td><td>HH:MM:SS</td></tr><tr><td>YEAR</td><td>1 bytes</td><td>年份值</td><td>YYYY</td></tr><tr><td>DATETIME</td><td>8 bytes</td><td>混合日期和时间值</td><td>YYYY-MM-DD hh:mm:ss</td></tr><tr><td>TIMESTAMP</td><td>4 bytes</td><td>混合日期和时间值，时间戳</td><td>YYYY-MM-DD hh:mm:ss</td></tr></tbody></table><h3 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h3><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">CHAR</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">定长字符串</td></tr><tr><td style="text-align:left">VARCHAR</td><td style="text-align:left">0-65535 bytes</td><td style="text-align:left">变长字符串</td></tr><tr><td style="text-align:left">TINYBLOB</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:left">TINYTEXT</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">短文本字符串</td></tr><tr><td style="text-align:left">BLOB</td><td style="text-align:left">0-65 535 bytes</td><td style="text-align:left">二进制形式的长文本数据</td></tr><tr><td style="text-align:left">TEXT</td><td style="text-align:left">0-65 535 bytes</td><td style="text-align:left">长文本数据</td></tr><tr><td style="text-align:left">MEDIUMBLOB</td><td style="text-align:left">0-16 777 215 bytes</td><td style="text-align:left">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:left">MEDIUMTEXT</td><td style="text-align:left">0-16 777 215 bytes</td><td style="text-align:left">中等长度文本数据</td></tr><tr><td style="text-align:left">LONGBLOB</td><td style="text-align:left">0-4 294 967 295 bytes</td><td style="text-align:left">二进制形式的极大文本数据</td></tr><tr><td style="text-align:left">LONGTEXT</td><td style="text-align:left">0-4 294 967 295 bytes</td><td style="text-align:left">极大文本数据</td></tr></tbody></table><h2 id="sql基础语法"><a class="markdownIt-Anchor" href="#sql基础语法"></a> #SQL基础语法</h2><ul><li><p>创建</p><p>数据库的创建与使用</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE test;<br>USE test;<br></code></pre></div></td></tr></table></figure><p>表的创建</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table1 (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  col1 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,<br>  col2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NULL</span>,<br>  col3 <span class="hljs-type">DATE</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`));<br>  <br># 复制表，包括表结构和数据<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> newtable <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1;<br></code></pre></div></td></tr></table></figure></li><li><p>插入</p><p>普通插入</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table1(col1, col2)<br><span class="hljs-keyword">VALUES</span>(val1, val2);<br></code></pre></div></td></tr></table></figure><p>插入检索的数据</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table2(col1, col2)<br><span class="hljs-keyword">SELECT</span> col1, col2<br><span class="hljs-keyword">FROM</span> table1;<br></code></pre></div></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 使用更新和删除操作时一定要用 <span class="hljs-keyword">WHERE</span> 子句，不然会把整张表的数据都破坏。可以先用 <span class="hljs-keyword">SELECT</span> 语句进行测试，防止错误删除。<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br># <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 可以清空表，也就是删除所有行。<br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> table1;<br></code></pre></div></td></tr></table></figure></li><li><p>更新</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table1<br><span class="hljs-keyword">SET</span> col <span class="hljs-operator">=</span> val<br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 普通查询<br><span class="hljs-keyword">SELECT</span> col1,col2 <span class="hljs-keyword">FROM</span> table1;<br></code></pre></div></td></tr></table></figure><ul><li><strong>WHERE</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 尽量使用 <span class="hljs-keyword">SQL</span> 语句来过滤不必要的数据，如果数据非常大，会导致通过网络传输了多余的数据，从而浪费了网络带宽。<br><span class="hljs-keyword">SELECT</span> col1,col2 <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> col <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></div></td></tr></table></figure><p><strong>AND 和 OR</strong>  用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong>  操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong>  操作符用于否定一个条件。</p><p><strong>LIKE</strong>操作符用于模糊查询，对应的通配符：</p><p>  <strong>%</strong>  匹配 &gt;=0 个任意字符；</p><p>  <strong>_</strong>  匹配 ==1 个任意字符；</p><p>  <strong>[ ]</strong>  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 <strong>^</strong> 可以对其进行否定，也就是不匹配集合内的字符。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 匹配不以 A 和 B 开头的任意文本<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">WHERE</span> col <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;[^AB]%&#x27;</span>; <br></code></pre></div></td></tr></table></figure><ul><li><strong>DISTINCT</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 用于去重 相同值只会出现一次。对于多个列所有列的值都相同才算相同。<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> col1, col2<br><span class="hljs-keyword">FROM</span> table1;<br></code></pre></div></td></tr></table></figure><ul><li><strong>LIMIT</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 限制返回的行数。可以有两个参数，第一个参数为起始行，从 <span class="hljs-number">0</span> 开始;第二个参数为返回的总行数。<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> table1<br>LIMIT <span class="hljs-number">0</span>, <span class="hljs-number">5</span>;<br></code></pre></div></td></tr></table></figure><ul><li><strong>ORDER BY</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"># <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>可以对查询字段进行排序，并且为每个列指定不同的排序方式: <span class="hljs-keyword">ASC</span>(默认)：升序；<span class="hljs-keyword">DESC</span>：降序 <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> table1 <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> col1 <span class="hljs-keyword">ASC</span>, col2 <span class="hljs-keyword">DESC</span>;<br></code></pre></div></td></tr></table></figure><ul><li><strong>GROUP BY</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>可以把具有相同的数据值的行放在同一组中。<br><span class="hljs-keyword">SELECT</span> col, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> col;<br><br># <span class="hljs-keyword">WHERE</span> 过滤行，<span class="hljs-keyword">HAVING</span> 过滤分组，行过滤应当先于分组过滤。<br><span class="hljs-keyword">SELECT</span> col, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">WHERE</span> col <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> col<br><span class="hljs-keyword">HAVING</span> num <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>;<br><br># <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 后可以接<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 按分组后字段来进行排序。<br><span class="hljs-keyword">SELECT</span> col, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> col<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> num;<br></code></pre></div></td></tr></table></figure><blockquote><ul><li><p>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</p></li><li><p>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</p></li><li><p>NULL 的行会单独分为一组；</p></li><li><p>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</p></li></ul></blockquote><ul><li><p><strong>子查询</strong></p><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> mytable1<br><span class="hljs-keyword">WHERE</span> col1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> col2<br>               <span class="hljs-keyword">FROM</span> mytable2);<br></code></pre></div></td></tr></table></figure><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <br>  <span class="hljs-keyword">FROM</span> Orders <br>  <span class="hljs-keyword">WHERE</span> Orders.cust_id <span class="hljs-operator">=</span> Customers.cust_id) <span class="hljs-keyword">AS</span> orders_num <br><span class="hljs-keyword">FROM</span> Customers<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cust_name;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> #连接</h2><p><font style="color:red">连接用于连接多个表，使用 <code>JOIN</code> 关键字，并且连接的条件语句使用 <code>ON</code> 而不是 <code>WHERE</code>。</font></p><p><strong>连接可以替换子查询，并且比子查询的效率一般会更快。</strong></p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><ul><li><p><strong>自然连接</strong></p><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> tab1.value, tab2.value<br><span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">AS</span> tab1 <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">AS</span> tab2;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>内连接</strong></p><p>内连接又称等值连接，使用 INNER JOIN 关键字。可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> tab1.value, tab2.value<br><span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">AS</span> tab1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">AS</span> tab2<br><span class="hljs-keyword">ON</span> tab1.key <span class="hljs-operator">=</span> tab2.key;<br><br><span class="hljs-keyword">SELECT</span> tab1.value, tab2.value<br><span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">AS</span> tab1  <br><span class="hljs-keyword">WHERE</span> tab1.key <span class="hljs-operator">=</span> tab2.key;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>外连接</strong></p><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 检索所有顾客的订单信息，包括还没有订单信息的顾客。<br><span class="hljs-keyword">SELECT</span> Customers.cust_id, Orders.order_num<br><span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> Orders<br><span class="hljs-keyword">ON</span> Customers.cust_id <span class="hljs-operator">=</span> Orders.cust_id;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> #索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><p><font style="color:grey">待编纂。。</font></p><h2 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> #触发器</h2><p><font style="color:red">触发器会在某个表执行以下语句时而自动执行: DELETE、INSERT、UPDATE。</font></p><p><font style="color:red">触发器必须指定在语句执行之前或者之后自动执行，之前执行使用 <code>BEFORE</code> 关键字，之后执行使用 <code>AFTER</code> 关键字。<code>BEFORE</code> 用于数据验证和净化，<code>AFTER</code> 用于审计跟踪，将修改记录到另外一张表中。</font></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger1 AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> table1<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">SELECT</span> NEW.col <span class="hljs-keyword">into</span> <span class="hljs-variable">@result</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@result</span>; <span class="hljs-comment">-- 获取结果</span><br></code></pre></div></td></tr></table></figure><blockquote><p>INSERT 触发器包含一个名为 <code>NEW</code> 的虚拟表。</p><p>DELETE 触发器包含一个名为 <code>OLD</code> 的虚拟表，并且是只读的。</p><p>UPDATE 触发器包含一个名为 <code>NEW</code> 和一个名为 <code>OLD</code> 的虚拟表，其中 <strong>NEW 是可以被修改的，而 OLD 是只读的。</strong></p><p>MySQL 不允许在触发器中使用 <code>CALL</code> 语句，也就是不能调用存储过程。</p></blockquote><h2 id="存储过程"><a class="markdownIt-Anchor" href="#存储过程"></a> #存储过程</h2><p><font style="color:grey">待编纂。。</font></p><h2 id="游标"><a class="markdownIt-Anchor" href="#游标"></a> #游标</h2><p><font style="color:grey">待编纂。。</font></p><h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> #事务</h2><p><font style="color:grey">待编纂。。</font></p><h2 id="sql优化"><a class="markdownIt-Anchor" href="#sql优化"></a> #SQL优化</h2><ol><li><p><strong>避免全表扫描</strong>，首先应考虑在 where 及 order by 涉及的列上建立索引；</p></li><li><p><strong>避免在 where 子句中对字段进行 null 值判断</strong>，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> num <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br></code></pre></div></td></tr></table></figure><p>也可以自定义表示 null 值的标识符来填充，同时 定长类型 的字段在建立时，空间也固定了不管是否插入值（NULL也包含在内）。如果是 变长类型 字段 null 值是不占用空间的；</p></li><li><p><strong>避免在where子句中使用<code>!=</code>或<code>&lt;&gt;</code>操作符</strong>，否则引擎会放弃索引搜索而进行全表扫描；</p></li><li><p><strong>避免在where子句中使用<code>or</code>来连接条件</strong>，如果一个字段有索引，另一个没有索引时，引擎也会放弃索引搜索而进行全表扫描；</p><p><strong>可以将<code>or</code>连接方式改成<code>union</code>方式</strong> ：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> role <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;admin&#x27;</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong><code>in</code>和<code>not in</code>也会导致全表扫描，用 <code>exists</code> 代替 <code>in</code>，或者对于连续的数值使用<code>between</code></strong>；</p></li><li><p>前导的模糊查询会导致全表扫描：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%abc&#x27;</span><br></code></pre></div></td></tr></table></figure><p>若要提高效率，可以考虑全文检索。</p></li><li><p>避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</p></li><li><p>Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</p></li><li><p>对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。</p></li><li><p>类似 <code>select count(*) from table；</code>这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。</p></li><li><p>索引并不是越多越好，<strong>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引</strong>，所以怎样建索引需要慎重考虑，视具体情况而定。<strong>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</strong></p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p></li><li><p>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p></li><li><p>任何地方都不要使用 select * from t ，用具体的字段列表代替“ * ”，不要返回用不到的任何字段。</p></li><li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</p></li><li><p>**在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；**如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p></li><li><p><strong>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</strong></p></li><li><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p></li><li><p>尽量避免大事务操作，提高系统并发能力。</p></li><li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写；使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p></li></ol><h2 id="规范"><a class="markdownIt-Anchor" href="#规范"></a> #规范</h2><p><font style="color:grey">待编纂。。</font></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/helloworld/notes/Java/Spring/Spring/"/>
    <url>/helloworld/notes/Java/Spring/Spring/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待编纂。</font></p><p>参考文章：</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-introduce.html">Spring框架组成</a></li><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-ioc.html">Spring核心之控制反转(IoC)</a></li><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-aop.html">Spring核心之面向切面编程(AOP)</a></li><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-springmvc.html">SpringMVC请求流程和案例</a></li></ul><h2 id="spring概念"><a class="markdownIt-Anchor" href="#spring概念"></a> #Spring概念</h2><ul><li>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。</li><li>容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期</li><li><strong>控制反转：IoC</strong>(Inversion of Control)，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。</li><li><strong>依赖注入：DI</strong>(Dependency Injection)，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。</li><li><strong>面向切面编程</strong>：<strong>AOP</strong>(Aspect Oriented Programming)</li><li>一站式：在 <strong>IoC</strong> 和 <strong>AOP</strong> 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表现层的 SpringMVC 和持久层的 Spring JDBC）</li><li>非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API</li></ul><h2 id="spring组件"><a class="markdownIt-Anchor" href="#spring组件"></a> #Spring组件</h2><p>Spring采用分层架构，根据不同的功能划分为多个组件模块：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/Spring%E7%BB%84%E4%BB%B6.png" alt="Spring组件" /></p><ol><li><p><strong>Data Access/Integration（数据访问／集成）</strong>:</p><p>数据访问/集成层 包括JDBC、ORM、OXM、JMS和Transactions模块：</p><ul><li>JDBC模块：提供了JDBC的抽象层，大幅减少了开发时对数据库的操作。</li><li>ORM模块：对流行的对象关系映射API，包括JPA、JDO、Hibernate和iBatis提供了集成层。</li><li>OXM 模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。</li><li>JMS 模块：指 Java 消息服务，包含的功能为生产和消费的信息。</li><li><font style="color:red">Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类。</font></li></ul></li><li><p><strong>Web模块</strong>：</p><p>包括Web、Servlet、Struts和Protlet组件：</p><ul><li>Web模块：提供了基本的Web开发集成特性，如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。</li><li>Servlet模块：包括Spring模型-视图-控制器（MVC）实现Web应用程序。</li><li>Struts模块：支持类内的Spring应用程序，集成了经典的Struts Web层。</li><li>Protlet模块：提供在 Portlet 环境中使用 MVC实现，类似 Web-Servlet 模块的功能。</li></ul></li><li><p><strong>Core Container（核心容器）</strong>：</p><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成，具体介绍如下。</p><ul><li><font style="color:red">Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。</font></li><li><font style="color:red">Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。</font></li><li>Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。</li><li>Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。</li></ul></li><li><p><strong>其他模块</strong>：</p><p>Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下。</p><ul><li><font style="color:red">AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。</font></li><li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li><li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li>Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。</li></ul></li></ol><h2 id="bean"><a class="markdownIt-Anchor" href="#bean"></a> #Bean</h2><p>  <font style="color:red">在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。由Spring IoC容器实例化、组装和管理bean对象，从而对组件之间依赖关系进行了解耦。</font></p><h3 id="bean配置"><a class="markdownIt-Anchor" href="#bean配置"></a> Bean配置</h3><p>  Spring 配置文件支持两种不同的格式，分别是 XML 文件格式和 Properties 文件格式。</p><p>  通常情况下，Spring 会以 XML 文件格式作为 Spring 的配置文件，这种配置方式通过 XML 文件注册并管理 Bean 之间的依赖关系。定义 Bean 的示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用id属性定义bean1，其对应的实现类为com.bean.Bean1 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bean1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.Bean1&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--使用name属性定义bean2，其对应的实现类为com.beam.Bean2--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bean2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.beam.Bean2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>Bean配置常用属性：</p><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">是一个 Bean 的唯一标识符，Spring 容器对 Bean 的配置和管理都通过该属性完成</td></tr><tr><td style="text-align:center">name</td><td style="text-align:center">Spring 容器同样可以通过此属性对容器中的 Bean 进行配置和管理，name 属性中可以为 Bean 指定多个名称，每个名称之间用逗号或分号隔开</td></tr><tr><td style="text-align:center">class</td><td style="text-align:center">该属性指定了 Bean 的具体实现类，它必须是一个完整的类名，使用类的全限定名</td></tr><tr><td style="text-align:center">scope</td><td style="text-align:center">用于设定 Bean 实例的作用域，其属性值有 singleton（单例）、prototype（原型）、request、session 和 global Session。其默认值是 singleton</td></tr><tr><td style="text-align:center">constructor-arg</td><td style="text-align:center"><bean>元素的子元素，可以使用此元素传入构造参数进行实例化。该元素的 index 属性指定构造参数的序号（从 0 开始），type 属性指定构造参数的类型</td></tr><tr><td style="text-align:center">property</td><td style="text-align:center"><bean>元素的子元素，用于调用 Bean 实例中的 Set 方法完成属性赋值，从而完成依赖注入。该元素的 name 属性指定 Bean 实例中的相应属性名</td></tr><tr><td style="text-align:center">ref</td><td style="text-align:center"><property> 和 <constructor-arg> 等元素的子元索，该元素中的 bean 属性用于指定对 Bean 工厂中某个 Bean 实例的引用</td></tr><tr><td style="text-align:center">value</td><td style="text-align:center"><property> 和 <constractor-arg> 等元素的子元素，用于直接指定一个常量值</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">用于封装 List 或数组类型的依赖注入</td></tr><tr><td style="text-align:center">set</td><td style="text-align:center">用于封装 Set 类型属性的依赖注入</td></tr><tr><td style="text-align:center">map</td><td style="text-align:center">用于封装 Map 类型属性的依赖注入</td></tr><tr><td style="text-align:center">entry</td><td style="text-align:center"><map> 元素的子元素，用于设置一个键值对。其 key 属性指定字符串类型的键值，ref 或 value 子元素指定其值</td></tr></tbody></table><h3 id="bean的使用"><a class="markdownIt-Anchor" href="#bean的使用"></a> Bean的使用：</h3><p>由于IoC 是指在程序开发中，实例的创建不再由调用者管理，而是由 Spring 容器创建，Spring 容器会负责控制程序之间的关系。</p><p>Spring提供了两种IoC容器</p><ul><li><p>BeanFactory</p><p>若使用BeanFactory</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BeanFactory factory=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanFactory</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;application.xml&quot;</span>));<br></code></pre></div></td></tr></table></figure></li><li><p>ApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationContext app=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;application.xml&quot;</span>);<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="ioc控制反转"><a class="markdownIt-Anchor" href="#ioc控制反转"></a> #IoC(控制反转)</h2><p>  IoC(Inversion of Control)即 控制反转 <strong>是一种设计思想</strong>，简单来说就是<font style="color:red">创建对象的控制权，被反转到了Spring框架上；</font><font style="color:#00FFFF">通常，我们实例化一个对象时，都是使用类的构造方法来new一个对象，这个过程是由我们自己来控制的，而控制反转就把new对象的工作交给了Spring容器。</font></p><p>传统程序设计下，需要我们主动去创建相关对象然后再组合起来，比如：</p><p>示例1：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">UserDaoImpl userDao=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>UserServiceImpl userService=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>userService.setUserDao(userDao);<br></code></pre></div></td></tr></table></figure><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/IoC%E7%A4%BA%E4%BE%8B1.png" alt="IoC示例1" /></p><p>当有了IoC/DI的容器后，我们就不用再主动去创建这些对象了，如下：</p><p>示例2：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationContext context=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPashXmlApplicationContext</span>(<span class="hljs-string">&quot;application.xml&quot;</span>);<br><span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> xmlApp.getBean(<span class="hljs-string">&quot;userService&quot;</span>,UserServiceImpl.class);<br></code></pre></div></td></tr></table></figure><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/IoC%E7%A4%BA%E4%BE%8B2.png" alt="IoC示例2" /></p><p><strong>IoC</strong>的主要实现方式有两种：依赖查找、依赖注入。</p><h3 id="依赖查找"><a class="markdownIt-Anchor" href="#依赖查找"></a> 依赖查找</h3><p>  主要是容器为组件提供一个回调接口和上下文环境。这样一来，组件就必须自己使用容器提供的API来查找资源和协作对象，所以依赖查找的控制反转仅体现在那些回调方法上，容器调用这些回调方法，从而应用代码获取到资源。</p><h3 id="依赖注入"><a class="markdownIt-Anchor" href="#依赖注入"></a> 依赖注入</h3><p>  组件不做定位查询，只提供标准的Java方法让容器去决定依赖关系。容器全权负责组件的装配，把符合依赖关系的对象通过Java Bean属性或构造方法传递给需要的对象。<font style="color:red">由IoC容器动态地将某个对象所需要的外部资源（包括对象、资源、常量数据）注入到组件(Controller, Service等）之中。简单点说，就是IoC容器会把当前对象所需要的外部资源动态的注入给我们。</font></p><p>Spring依赖注入的方式主要有三个：</p><ul><li><p>注解注入</p><p><code>@Autowired</code>默认按类型装配<br /><code>@Qualifier</code>和<code>Autowired</code>配合使用，指定bean的名称<br /><code>@Resource</code>默认按名称装配，当找不到与名称匹配的bean时，才会按类型装配。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pojo;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;cat&quot;)</span><br>    Cat cat;<br>    <span class="hljs-meta">@Resource</span><br>    Dog dog;<br><br><br>    <span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">getCat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cat;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Dog <span class="hljs-title function_">getDog</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dog;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;People&#123;&quot;</span><br>                +<span class="hljs-string">&quot; cat=&quot;</span> + cat.name +<br>                <span class="hljs-string">&quot;, dog=&quot;</span> + dog.name +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>set注入</p><p>setter是Spring现在<strong>最主流</strong>的注入方式,它可以利用<strong>Java Bean</strong> 规范所定义<strong>set/get</strong>方法来完成注入,可读性灵活性高</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String lastName ;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String email;<br><span class="hljs-comment">//getter/setter方法和无参全参构造器省略.....</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>xml文件配置：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person01&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lkh.bean.Person&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--   使用property标签是通过类的set方法为Person对象的属性赋值     --&gt;</span><br><span class="hljs-comment">&lt;!--    name是属性名，value是属性值    --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;163@qq.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>构造器注入</p><p><font style="color:#00FFFF">构造器注入主要是依赖于构造方法去实现,构造方法可以是有参也可以是无参,我们在平常都是通过类的构造方法来创建类对象,以及给他赋值,同样Spring 是通过反射的方式,使用构造方法来完成注入(赋值)</font></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String lastName ;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String email;<br><span class="hljs-comment">//getter/setter方法省略.....</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String lastName, Integer age, String gender, String email)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lastName = lastName;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>        <span class="hljs-built_in">this</span>.email = email;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>xml文件配置：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person03&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lkh.bean.Person&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--    constructor-arg标签是通过有参构造器方法为属性赋值   --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;王五&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;12494@qq.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>接口注入</p><p>接口注入模式因为具备<font style="color:yellow">侵入性<sup>1</sup></font>，它要求组件必须与特定的接口相关联，其在灵活性、易用性上不如其他注入模式，所以不突出说明了。</p></li></ul><p><font style="color:yellow">①：侵入性是指一个类中继承了一个接口或继承了一个类，那么这个类就得实现接口的定义的方法或继承了父类。从一定的意义上说这个类被入侵了。</font></p><h2 id="aop面向切面编程"><a class="markdownIt-Anchor" href="#aop面向切面编程"></a> #AOP(面向切面编程)</h2><p>Spring 框架通过定义切面, 通过拦截切点实现了不同业务模块的解耦，这个就叫<strong>面向切面编程</strong>。它和IoC一样是一种设计思想。</p><p>将分散在各个业务逻辑代码中相同的代码通过<strong>横向切割</strong>的方式抽取到一个独立的模块中</p><p><strong>AOP术语</strong>：</p><blockquote><p><strong>连接点（Jointpoint）</strong>：表示需要在程序中插入横切关注点的扩展点，<strong>连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等</strong>，Spring只支持方法执行连接点，在AOP中表示为<strong>在哪里干</strong>；</p><p><strong>切入点（Pointcut）</strong>： 选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为<strong>在哪里干的集合</strong>；</p><p><strong>通知（Advice）</strong>：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为<strong>干什么</strong>；</p><p><strong>方面/切面（Aspect）</strong>：横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为<strong>在哪干和干什么集合</strong>；</p><p><strong>引入（inter-type declaration）</strong>：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在AOP中表示为<strong>干什么（引入什么）</strong>；</p><p><strong>目标对象（Target Object）</strong>：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为被通知对象；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为<strong>对谁干</strong>；</p><p><strong>织入（Weaving）</strong>：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。在AOP中表示为<strong>怎么实现的</strong>；</p><p><strong>AOP代理（AOP Proxy）</strong>：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</p></blockquote><p><strong>通知类型</strong>：</p><blockquote><p><strong>前置通知（Before advice）</strong>：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</p><p><strong>后置通知（After returning advice）</strong>：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p><p><strong>异常通知（After throwing advice）</strong>：在方法抛出异常退出时执行的通知。</p><p><strong>最终通知（After (finally) advice）</strong>：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p><p><strong>环绕通知（Around Advice）</strong>：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p></blockquote><h2 id="spring-mvc"><a class="markdownIt-Anchor" href="#spring-mvc"></a> #Spring MVC</h2><p><font style="color:red">MVC英文是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计规范：用一种业务逻辑、数据、界面显示分离的方法，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</font></p><blockquote><ul><li><strong>Model</strong>（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。</li><li><strong>View</strong>（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。</li><li><strong>Controller</strong>（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul></blockquote><p>Spring MVC 是一种基于Java 的实现了Web MVC 设计模式的请求驱动类型的轻量级Web 框架，即使用了MVC 架 构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，<font style="color:red">框架的目的就是帮助我们简化开发。</font></p><p>SpringMVC运行流程：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/SpringMVC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="SpringMVC运行流程" /></p><blockquote><ol><li>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</li><li>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</li><li>返回处理器执行链，根据url查找控制器，并且将解析后的信息传递给DispatcherServlet</li><li>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</li><li>执行handler找到具体的处理器</li><li>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</li><li>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</li><li>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</li><li>视图解析器将解析的逻辑视图名传给DispatcherServlet。</li><li>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图，进行试图渲染</li><li>将响应数据返回给客户端</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muti-thread&amp;JUC</title>
    <link href="/helloworld/notes/Java/API/Muti-thread&amp;JUC/"/>
    <url>/helloworld/notes/Java/API/Muti-thread&amp;JUC/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待编纂。</font></p><p>参考文章：</p><ul><li><p><a href="https://blog.kyire.site/2021/04/17/dcfce7ce.html">多线程与线程同步</a></p></li><li><p><a href="https://blog.kyire.site/2021/05/16/eb9166f8.html">JUC并发编程</a></p></li><li><p><a href="https://blog.csdn.net/pange1991/article/details/53860651">Java线程的6种状态及切换</a></p></li><li><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">synchronized详解</a></p></li><li><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html">volatile详解</a></p></li><li><p><a href="https://blog.csdn.net/qq_28082757/article/details/101065531">System.out.println如何影响内存可见性</a></p></li><li><p><a href="https://blog.csdn.net/duzhe2905/article/details/106038681">volatile如何保证可见性和有序性</a></p></li><li><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-all.html">Java中所有的锁</a></p></li></ul><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> #多线程</h2><p>  <font style="color : red"><strong>线程</strong>是CPU调度和执行的单位。</font>而多个线程组成一个进程，<font style="color : red"><strong>进程</strong>是一个动态的概念，是系统资源分配的单位。</font>进程又是执行程序的一次执行过程，<font style="color : red"><strong>程序</strong>是一个静态的概念，是指令和数据的有序集合，其本身没有任何运行的含义。</font></p><p><strong>多线程核心概念</strong></p><ul><li><p>线程就是独立的执行路径；在程序运行时，后台会就有多个线程，也称为<font style="color:yellow">守护线程<sup>1</sup></font>，如<code>main</code>主线程、gc线程；<code>main()</code>线程称之为主线程，为系统的入口，用于执行整个程序；</p></li><li><p>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的；</p></li><li><p>对同一份资源操作时，会存在资源抢占问题，需要加入并发控制；</p></li><li><p>线程会带来额外的开销，如CPU调度时间，并发控制开销；</p></li><li><p>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致；</p><p><font style="color:yellow">①：守护线程是指在程序运行时 在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分。而由我们自己定义的线程称为 <strong>用户线程</strong> 。</font></p></li></ul><h3 id="线程创建方式"><a class="markdownIt-Anchor" href="#线程创建方式"></a> 线程创建方式</h3><ul><li><p>继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread方式&quot;</span>+i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TestThread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestThread</span>();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>实现Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Runnable方式&quot;</span>+i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TestRunnable runnable=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>实现Callable接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Runnable方式&quot;</span>+i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;call结束&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">//创建一个callable接口实现类对象</span><br>        <span class="hljs-type">CallableTest</span> <span class="hljs-variable">callableTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableTest</span>();<br>        <span class="hljs-comment">//创建执行服务</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//提交执行</span><br>        Future&lt;String&gt; future = service.submit(callableTest);<br>        <span class="hljs-comment">//获取call返回结果</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get();<br>        System.out.println(result);<br>        <span class="hljs-comment">//关闭服务</span><br>        service.shutdownNow();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote></blockquote><p><strong>小结</strong></p><ul><li>继承<code>Thread</code>类<ul><li>启动线程：子类对象.start()</li><li><b style="color:red">存在OOP单继承局限性</b></li></ul></li><li>实现<code>Runnable</code>接口<ul><li>启动线程：传入目标对象+Thread对象.start()</li><li><b style="color:red">灵活方便，方便同一个对象被多个线程使用，减少程序之间的耦合度，面向接口编程也是设计模式六大原则的核心。</b></li></ul></li><li>实现<code>Callable</code>接口<ul><li>启动线程：执行对象(线程池).submit(目标对象)</li><li>获取结果：执行对象(线程池).submit(目标对象).get()</li><li><b style="color:red">Callable主要用于线程池可以抛出异常并且有返回值。</b></li></ul></li></ul></li></ul><h3 id="thread类"><a class="markdownIt-Anchor" href="#thread类"></a> Thread类</h3><ul><li><p>线程状态</p><ol><li><p><strong>初始状态(NEW)</strong><br /><font style="color:#00FFFF">实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</font></p></li><li><p><strong>运行(RUNNABLE)</strong></p><blockquote><p><strong>2.1. 就绪 (RUNNABLE之READY)</strong></p><ul><li><font style="color:#00FFFF">就绪状态只是说有资格运行，只要调度程序没有挑选到你，就永远是就绪状态。</font></li><li>调用线程的<code>start()</code>方法，此线程进入就绪状态。</li><li>当前线程<code>sleep()</code>方法结束，其他线程<code>join()</code>结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</li><li>当前线程时间片用完了，调用当前线程的<code>yield()</code>方法，当前线程进入就绪状态。</li><li>锁池里的线程拿到对象锁后，进入就绪状态。</li></ul><p><strong>2.2. 运行中状态(RUNNABLE之RUNNING)</strong></p><ul><li><font style="color:#00FFFF">线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。</font></li></ul></blockquote></li><li><p><strong>阻塞(BLOCKED)</strong><br /><font style="color:#00FFFF">阻塞状态是线程阻塞在进入<code>synchronized</code>关键字修饰的方法或代码块(获取锁)时的状态。</font></p></li><li><p><strong>等待(WAITING)</strong><br /><font style="color:#00FFFF">处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</font></p></li><li><p><strong>超时等待(TIMED_WAITING)</strong><br /><font style="color:#00FFFF">处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</font></p></li><li><p><strong>终止(TERMINATED)</strong><br /><font style="color:#00FFFF">当线程的<code>run()</code>方法完成时，或者主线程的<code>main()</code>方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。</font><br /><font style="color : red">在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</font></p></li></ol><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpeg" alt="线程状态" /></p></li><li><p>线程方法</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">setPriority(int newPriority)</td><td style="text-align:center">更改线程的优先级</td></tr><tr><td style="text-align:center">static void sleep(long millis)</td><td style="text-align:center">在指定毫秒数内让当前正在执行的线程休眠</td></tr><tr><td style="text-align:center">void join()</td><td style="text-align:center">等待该线程终止</td></tr><tr><td style="text-align:center">static void yield()</td><td style="text-align:center">暂停当前正在执行的线程对象，并执行其他线程</td></tr><tr><td style="text-align:center">void interrupt()</td><td style="text-align:center">中断线程，别用这个方式</td></tr><tr><td style="text-align:center">boolean isAlive()</td><td style="text-align:center">测试线程是否处于活动状态</td></tr></tbody></table><p><font style="color:yellow"><code>wait()</code>：wait是<code>Object</code>中的方法，任何对象实例都能调用。它和<code>Thread</code>中的<code>sleep()</code>很相似，不同的是sleep不会释放锁，也不需要占有锁；而wait会释放锁，而且调用它的前提是当前线程占有锁(即代码在<code>synchronized</code> 中)</font></p></li></ul><h3 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> synchronized</h3><p><code>synchronized</code>是Java中的关键字，是一种同步锁，它具有以下特点：</p><ul><li><p><font style="color:red">一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</font></p></li><li><p><font style="color:red"><code>synchronized</code>可以修饰 <strong>方法</strong> 和 <strong>代码块</strong> ；</font></p></li><li><p><font style="color:red">synchronized修饰 普通方法 锁对象默认为this(当前实例对象)，而同步代码块锁可以指定对象，两种都是<strong>对象锁</strong>；</font></p><p>对象锁示例1：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<span class="hljs-comment">//和synchronized修饰 普通方法 效果相同</span><br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">我是线程Thread-0<br>Thread-0结束<br>我是线程Thread-1<br>Thread-1结束<br></code></pre></div></td></tr></table></figure><p>上述代码两个线程使用的锁是一样的,<code>thread2</code>必须要等到<code>thread1</code>释放了该锁后，才能执行。</p><p>对象锁示例2：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br>    <span class="hljs-comment">// 创建2把锁</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">block1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">block2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span><br>        <span class="hljs-keyword">synchronized</span> (block1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (block2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">block1锁,Thread-0<br>block1锁,Thread-0 END！<br>block2锁,Thread-0<br>block1锁,Thread-1<br>block1锁,Thread-1 END！<br>block2锁,Thread-0 END！<br>block2锁,Thread-1<br>block2锁,Thread-1 END！<br></code></pre></div></td></tr></table></figure><p>由示例2可见，当同步代码块指定不同对象时，在<code>thread1</code>从<code>block1锁</code>释放后；由于此时<code>thread1</code>锁对象是<code>block1锁</code>而<code>thread2</code>锁对象是<code>block2锁</code>，<code>thread2</code>会和<code>thread1</code>同时运行。</p></li><li><p><font style="color:red"><code>synchronized</code>修饰 静态方法 或同步代码块指定锁对象为 <code>Class</code>对象时，称为<strong>类锁</strong>； </font></p><p>类锁示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 所有线程需要的锁都是同一把</span><br>        <span class="hljs-keyword">synchronized</span>(SynchronizedObjectLock.class)&#123;<br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence1);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence2);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">Thread-0<br>Thread-0 END！<br>Thread-1<br>Thread-1 END！<br></code></pre></div></td></tr></table></figure><p>类锁代码，无论是哪个线程访问它，需要的锁都只有一把。</p></li><li><p><font style="color:red">synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁。</font></p></li></ul><p><font style="color:grey">待完善。。</font></p><h2 id="并发编程juc"><a class="markdownIt-Anchor" href="#并发编程juc"></a> #并发编程(JUC)</h2><p>  JUC是java.util.concurrent的简写，是jdk针对java并发编程的工具包。</p><p>  在了解JUC之前我们先了解<strong>并发</strong>的概念：<font style="color:red"><strong>单核下多线程操作同一个资源</strong>，将CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。这种方式我们称之为并发(Concurrent)。</font><font style="color:#00FFFF">并发实质是一个物理CPU（也可以是多个物理CPU）在若干个程序之间多路复用，并发性是对有限物理资源强制行使 多用户共享以提高效率。</font><br />而和并发相似的<strong>并行</strong>是在<font style="color:red"><strong>多核下多线程同时执行</strong>，多个线程之间互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。</font></p><p>并发问题的三要素：可见性、原子性和有序性：</p><ul><li><font style="color:red">可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</font></li><li>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li></ul><h3 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> volatile</h3><h4 id="volatile可见性"><a class="markdownIt-Anchor" href="#volatile可见性"></a> volatile可见性</h4><p>  可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用，</p><p><code>volatile</code>可见性示例1：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">()</span>&#123;<br>        a = <span class="hljs-number">3</span>;<br>        b = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;b=&quot;</span>+b+<span class="hljs-string">&quot;;a=&quot;</span>+a);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">VolatileTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileTest</span>();<br>            <span class="hljs-comment">//线程1</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                test.change();<br>            &#125;).start();<br>            <span class="hljs-comment">//线程2</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">10</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    test.print();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>正常情况下，这段代码只存在两种情况：</p><ol><li>先执行<code>change()</code>，再执行<code>print()</code> 结果是：b=3;a=3；</li><li>先执行<code>print()</code>，再执行<code>change()</code> 结果是：b=2;a=1；</li></ol><p>但是还可能出现 b=2;a=3 或者 b=3;a=1 的情况，这种情况主要是因为线程1修改了a或者b后，对线程2是不可见的，所以才会出现这种情况，如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。</p><p><code>volatile</code>可见性示例2：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span> (num ==  <span class="hljs-number">0</span>)&#123; <br><span class="hljs-comment">//System.out.println(&quot;thread&quot;);</span><br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-comment">//主线程暂停1s</span><br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    num = <span class="hljs-number">1</span>;<br>    System.out.println(num);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码也能体现volatile的可见性，代码会进入死循环；这是由于线程对主线程的内存变化不可见。</p><p><font style="color:#00FFFF">  如果循环中存在 输出语句 则不会进入死循环，这是因为<code>PrintStream</code>中输出方法都带上了<code>synchronized</code>，而<code>synchronized</code>会做一下操作：</font></p><blockquote><ol><li>获得同步锁；</li><li>清空工作内存；</li><li>从主内存拷贝对象副本到工作内存；</li><li>执行代码(计算或者输出等)；</li><li>刷新主内存数据；</li><li>释放同步锁。</li></ol></blockquote><p>可见性问题的根本原因：</p><blockquote><p>在Java内存模型中，规定了共享变量是存放在主内存中，然后<strong>每个线程都有自己的工作内存</strong>，而线程对共享变量的操作，必须先从主内存中读到工作内存中去，至于什么时候写回到主内存是不可预知的，这就导致每个线程之间对共享变量的操作是封闭的，其他线程不可见的。</p></blockquote><p><code>volatile</code>修饰的共享变量进行写操作的时候多出一条带<code>lock前缀的指令</code></p><ol><li>Lock前缀的指令让线程工作内存中的值写回主内存中；</li><li>通过缓存一致性协议，其他线程如果工作内存中存了该共享变量的值，就会失效；</li><li>其他线程会重新从主内存中获取最新的值；</li></ol><h4 id="volatile原子性"><a class="markdownIt-Anchor" href="#volatile原子性"></a> volatile原子性</h4><p><code>volatile</code>原子性示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        num++; <span class="hljs-comment">//不是一个原子性操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//理论上num结果为1000</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                add();<br>            &#125;).start();<br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">//等待3秒，保证上面程序执行完成</span><br><br>        System.out.println(<span class="hljs-string">&quot;num =&quot;</span> + num);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><i style="color:yellow">注：上面代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。</i></p><p>输出结果理论上来说应该是1000，但是由于i++其实是一个复合操作，包括三步骤：</p><ul><li><p>读取i的值。</p></li><li><p>对i加1。</p></li><li><p>将i的值写回内存。</p></li></ul><p>volatile是无法保证这三个操作是具有原子性的，我们可以通过<strong>原子类</strong>或者<code>synchronized</code>和<code>lock</code>来保证+1操作的原子性。</p><p><font style="color:grey">待编纂。。</font></p><h4 id="volatile有序性"><a class="markdownIt-Anchor" href="#volatile有序性"></a> volatile有序性</h4><p>实例化一个对象可以分为三个步骤：</p><ul><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ul><p>但是由于操作系统可以对指令进行<font style="color:yellow"><code>重排序</code><sup>2</sup></font>，所以上面的过程也可能会变成如下过程：</p><ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul><p><font style="color:yellow">②：指令重排是指为了性能考虑, 编译器和CPU可能会对指令重新排序。同时内存也可能存在重排序，这主要是由于JMM(Java内存模型)中主内存和本地内存不一致导致程序乱序。</font></p><blockquote><p><strong>处理器在进行指令重排的时候，考虑：数据之间的依赖性！</strong></p><p>指令重排示例：</p><p>x,y,a,b初始值为0，然后进行以下操作：</p><table><thead><tr><th style="text-align:center">线程1</th><th style="text-align:center">线程2</th></tr></thead><tbody><tr><td style="text-align:center">x=a</td><td style="text-align:center">y=b</td></tr><tr><td style="text-align:center">b=1</td><td style="text-align:center">a=2</td></tr></tbody></table><p>正常结果应该是：x=0,y=0；但是由于指令重排可能导致指令执行顺序出现问题：</p><table><thead><tr><th style="text-align:center">线程1</th><th style="text-align:center">线程2</th></tr></thead><tbody><tr><td style="text-align:center">b=1</td><td style="text-align:center">a=2</td></tr><tr><td style="text-align:center">x=a</td><td style="text-align:center">y=b</td></tr></tbody></table><p>导致结果为：x=2,y=1。</p></blockquote><p>  <strong><code>volatile</code>禁止重排序</strong>，为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了<b style="color:red">内存屏障</b>阻止这种重排序。<font style="color:red">Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</font></p><h3 id="final"><a class="markdownIt-Anchor" href="#final"></a> final</h3><p>对于常用的关键字<code>final</code>的使用只简单概述一下，主要针对<code>final</code>在并发情况下的作用。</p><h4 id="final基础使用"><a class="markdownIt-Anchor" href="#final基础使用"></a> final基础使用</h4><ul><li><p>修饰类</p><p>当某个类的整体定义为final时，就表明了你不能打算继承该类，即这个类是<font style="color:red">不能有子类的。</font></p><p><font style="color:yellow">final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。</font></p></li><li><p>修饰方法</p><p><font style="color:red">声明方法不能被子类重写。</font></p><p><font style="color:yellow">private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</font></p></li><li><p>修饰参数</p><p><font style="color:red">Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。</font><font style="color:#00FFFF">这个特性主要用来向匿名内部类传递数据。</font></p></li><li><p>修饰变量</p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul></li></ul><h4 id="final重排序规则"><a class="markdownIt-Anchor" href="#final重排序规则"></a> final重排序规则</h4><h5 id="final修饰基本类型"><a class="markdownIt-Anchor" href="#final修饰基本类型"></a> final修饰基本类型</h5><ul><li><p>写规则</p><p><font style="color:red">JMM禁止编译器把final域的写重排序到 构造函数 之外；</font><font style="color:#00FFFF"> 编译器会在final域写之后，构造函数return之前，插入一个<code>storestore</code>屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</font></p><p><font style="color:red">在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。</font></p></li><li><p>读规则</p><p><font style="color:red">在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。</font><strong>(注意，这个规则仅仅是针对处理器)</strong>，处理器会在读final域操作的前面插入一个<code>LoadLoad</code>屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p></li></ul><h5 id="final修饰引用类型"><a class="markdownIt-Anchor" href="#final修饰引用类型"></a> final修饰引用类型</h5><ul><li><p>写规则</p><p>引用类型和基础类型相较多了对 对象的引用，即：<font style="color:red">在final基本类型的写规则上增加了 在构造函数内对一个final修饰对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。</font></p></li><li><p>读规则</p><p><font style="color:red">读final引用对象的成员域时结果时<strong>不可预知</strong>的，因为其对final修饰对象的成员域的写入是不可见的，两者之间存在数据竞争。</font></p></li></ul><p><font style="color:grey">待编纂。。</font></p><h3 id="juc锁"><a class="markdownIt-Anchor" href="#juc锁"></a> JUC锁</h3><p>  Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/Java%E9%94%81%E7%B1%BB%E5%9E%8B.png" alt="Java锁类型" /></p><h4 id="锁类型"><a class="markdownIt-Anchor" href="#锁类型"></a> 锁类型</h4><h5 id="悲观锁乐观锁"><a class="markdownIt-Anchor" href="#悲观锁乐观锁"></a> 悲观锁&amp;乐观锁</h5><ul><li>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此<font style="color:red">在获取数据的时候会先加锁，确保数据不会被别的线程修改。</font ><font style="color:#00FFFF">Java中，synchronized关键字和Lock的实现类都是悲观锁。</font></li><li>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是<font style="color:red">在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</font><font style="color:#00FFFF">乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</font></li></ul><blockquote><p><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。<br /><strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</p></blockquote><h5 id="自旋锁适应性自旋锁"><a class="markdownIt-Anchor" href="#自旋锁适应性自旋锁"></a> 自旋锁&amp;适应性自旋锁</h5><p>  <font style="color:red">阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。</font>如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>  在同步资源的锁定时间很短的场景下，让CPU去切换线程，线程挂起和恢复线程实在得不偿失。<font style="color:red">如果能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。所以我们让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</font></p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/%E8%87%AA%E6%97%8B%E9%94%81.png" alt="自旋锁" /></p><p>  自旋锁本身是有缺点的，它<strong>不能代替阻塞</strong>。<font style="color:#00FFFF">如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</font>所以，<font style="color:red">自旋等待的时间和自旋次数必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</font></p><p>  如果线程自旋刚结束，锁正好释放，这是不是也是资源的一种浪费。于是针对这种情况JDK引入了更灵活的适应性自旋锁，来提高并发性能。</p><p>  适应性自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确。</p><h5 id="无锁偏向锁轻量级锁重量解锁"><a class="markdownIt-Anchor" href="#无锁偏向锁轻量级锁重量解锁"></a> 无锁，偏向锁，轻量级锁&amp;重量解锁</h5><ul><li><p>无锁</p><blockquote><p>顾名思义程序不会有锁的竞争。那么这种情况我们不需要加锁，所以这种情况下对象锁状态为无锁。</p></blockquote></li><li><p>偏向锁</p><blockquote><p>偏向第一个访问锁的线程</p></blockquote><ul><li><font style="color:#00FFFF">如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</font></li><li>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。**一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。**升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致<font style="color:yellow">STW(stop the world)<sup>3</sup></font>操作；</li></ul><p><font style="color:yellow">③：<strong>等待所有用户线程进入安全点后并阻塞</strong>，做一些全局性操作的行为。Java中一种<strong>全局暂停现象，全局停顿，所有Java代码停止</strong>，<strong>native代码可以执行，但不能与JVM交互。</strong></font></p></li><li><p>轻量级锁</p><blockquote><p>轻量级锁对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。</p></blockquote><ol><li><p><font style="color:red">在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为<code>Lock Record</code>(锁记录)的空间用于存储锁对象目前的<code>Mark Word</code>的拷贝(JVM会将对象头中的<code>Mark Word</code>拷贝到锁记录中)。如果当前对象没有被锁定，那么锁标志位为<strong>01</strong>状态。</font></p></li><li><p><font style="color:red">JVM在执行当前线程时，虚拟机使用CAS操作将标记字段<code>Mark Word</code>拷贝到锁记录中。并且将<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。</font></p><p>如果更新成功，那么这个线程就有用了该对象的锁，并且对象<code>Mark Word</code>的锁标志位更新为(<code>Mark Word</code>中最后的2bit)<strong>00</strong>，即表示此对象处于轻量级锁定状态。</p><p>如果更新失败，JVM会检查当前的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为<strong>10</strong>，<code>Mark Word</code>中存储的时指向重量级锁的指针。</p></li></ol><p><strong>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗</strong>，包括系统调用引起的<font style="color:yellow">内核态<sup>4</sup></font>与<font style="color:yellow">用户态<sup>5</sup></font>切换、线程阻塞造成的线程切换等。</p></li><li><p>重量级锁</p><blockquote><p>当有其他线程占用锁时，当前线程会进入阻塞状态。</p></blockquote><p>内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。<font style="color:red">这种同步方式的成本非常高，包括系统调用引起的<font style="color:yellow">内核态<sup>4</sup></font>与<font style="color:yellow">用户态<sup>5</sup></font>切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</font></p></li></ul><h5 id="公平锁非公平锁"><a class="markdownIt-Anchor" href="#公平锁非公平锁"></a> 公平锁&amp;非公平锁</h5><p>  公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>  非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><h5 id="可重入锁非可重入锁"><a class="markdownIt-Anchor" href="#可重入锁非可重入锁"></a> 可重入锁&amp;非可重入锁</h5><p>  <font style="color:red">可重入锁是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</font>Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法1执行...&quot;</span>);<br>        doOthers();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOthers</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法2执行...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>  类中的两个方法都是被内置锁synchronized修饰的，<strong>在<code>doSomething()</code>方法中调用<code>doOthers()</code>方法时，由于内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作；</strong><br />  <strong>如果是不可重入锁，那么当前线程在调用<code>doOthers()</code>之前需要将执行<code>doSomething()</code>时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</strong></p><h5 id="共享锁排他锁"><a class="markdownIt-Anchor" href="#共享锁排他锁"></a> 共享锁&amp;排他锁</h5><p><strong>共享锁</strong>是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p><strong>排他锁</strong>是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的<code>synchronized</code>和JUC中<code>Lock</code>的实现类就是互斥锁。</p><p>JUC锁相关体系：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/Lock%E6%A1%86%E6%9E%B6.png" alt="Lock框架" /></p><ul><li><p>Lock</p><p><font style="color:red"><code>Lock</code>为接口类型，<code>Lock</code>实现提供了比使用<code>synchronized</code>方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。</font></p><p><strong>ReentrantLock</strong></p><p><code>ReentrantLock</code>实现了<code>Lock</code>接口，<code>Lock</code>接口中定义了<code>lock</code>与<code>unlock</code>相关操作，并且还存在<code>Condition</code>方法，表示生成一个条件。</p><p><code>ReentrantLock</code>总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系：</p><ul><li><p>Sync类</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">lock</td><td style="text-align:center">锁定，未实现，留给具体子类实现</td></tr><tr><td style="text-align:center">nonfairTryAcquire</td><td style="text-align:center">非公平方式获取</td></tr><tr><td style="text-align:center">tryRelease</td><td style="text-align:center">试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它</td></tr><tr><td style="text-align:center">isHeldExclusively</td><td style="text-align:center">判断资源是否被当前线程占有</td></tr><tr><td style="text-align:center">newCondition</td><td style="text-align:center">新生一个条件</td></tr><tr><td style="text-align:center">getOwner</td><td style="text-align:center">返回资源的占用线程</td></tr><tr><td style="text-align:center">getHoldCount</td><td style="text-align:center">返回状态</td></tr><tr><td style="text-align:center">isLocked</td><td style="text-align:center">资源是否被占用</td></tr><tr><td style="text-align:center">readObject</td><td style="text-align:center">自定义反序列化逻辑</td></tr></tbody></table></li><li><p>NonfairSync类</p><p>NonfairSync类继承了Sync类，表示采用非公平策略获取锁，其实现了Sync类中抽象的lock方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 非公平锁</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// 版本号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7316153563782823691L</span>;<br>    <span class="hljs-comment">// 获得锁</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment">// 比较并设置状态成功，状态0表示锁没有被占用</span><br>            <span class="hljs-comment">// 把当前线程设置独占了锁</span><br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 锁已经被占用，或者set失败</span><br>            <span class="hljs-comment">// 以独占模式获取对象，忽略中断</span><br>            acquire(<span class="hljs-number">1</span>); <br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从<code>lock</code>方法实现可知，</p></li><li><p>FairSyn类</p><p>FairSync类也继承了Sync类，表示采用公平策略获取锁，其实现了Sync类中的抽象lock方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 公平锁</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-comment">// 版本序列化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 以独占模式获取对象，忽略中断</span><br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="hljs-comment">        * recursive call or no waiters or is first.</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-comment">// 尝试公平获取锁</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-comment">// 获取当前线程</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-comment">// 获取状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 状态为0</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123; <span class="hljs-comment">// 不存在已经等待更久的线程并且比较并且设置状态成功</span><br>                <span class="hljs-comment">// 设置当前线程独占</span><br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="hljs-comment">// 状态不为0，即资源已经被线程占据</span><br>            <span class="hljs-comment">// 下一个状态</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 超过了int的表示范围</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-comment">// 设置状态</span><br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从<code>lock</code>方法实现可知，</p></li></ul></li><li><p>ReadWriteLock</p><p><font style="color:red"><code>ReadWriteLock</code>为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 <code>writer</code>，读取锁可以由多个 <code>reader</code> 线程同时保持。写入锁是独占的。</font></p></li><li><p>Condition</p><p><code>Condition</code>为接口类型，它将 Object 监视器方法(<code>wait</code>、<code>notify</code> 和 <code>notifyAll</code>)分解成截然不同的对象，以便通过将这些对象与任意 <code>Lock</code> 实现组合使用，为每个对象提供多个等待 <code>set</code> (<code>wait-set</code>)。其中，<code>Lock</code> 替代了 <code>synchronized</code> 方法和语句的使用，<code>Condition</code> 替代了 <code>Object</code> 监视器方法的使用。可以通过<code>await()</code>,<code>signal()</code>来休眠/唤醒线程。</p></li></ul><p><font style="color:grey">待编纂。。</font></p><h3 id="原子类"><a class="markdownIt-Anchor" href="#原子类"></a> 原子类</h3><p><font style="color:grey">待编纂。。</font></p><h3 id="juc集合"><a class="markdownIt-Anchor" href="#juc集合"></a> JUC集合</h3><p><font style="color:grey">待编纂。。</font></p><h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3><p><font style="color:grey">待编纂。。</font></p><h3 id="juc工具类"><a class="markdownIt-Anchor" href="#juc工具类"></a> JUC工具类</h3><p><font style="color:grey">待编纂。。</font></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
      <tag>API</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collection&amp;Map</title>
    <link href="/helloworld/notes/Java/API/Java%E9%9B%86%E5%90%88/"/>
    <url>/helloworld/notes/Java/API/Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><p><a href="https://blog.kyire.site//2021/07/02/13a54546.html">Java中的集合</a></p></li><li><p><a href="https://www.runoob.com/java/java-collections.html">菜鸟驿站-Java 集合框架</a></p></li><li><p>Map</p><ul><li><a href="https://blog.csdn.net/weixin_54361971/article/details/122430827">HashMap详解</a></li><li><a href="https://blog.csdn.net/qq_40050586/article/details/105851970">LinkedHashMap详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/268025265">HashTable</a></li><li><a href="https://blog.csdn.net/u013467442/article/details/105826778">WeakHashMap</a></li></ul></li><li><p>Queue</p><ul><li><a href="https://blog.csdn.net/lucklycoder/article/details/115381856">ArrayDeque类详解</a></li><li><a href="https://www.cnblogs.com/lxyit/p/9052962.html">PriorityQueue详解</a></li></ul></li><li><p>Set</p><ul><li><a href="https://blog.csdn.net/qq_44549134/article/details/109059724">TreeSet</a></li></ul></li><li><h2 id="集合工具类"><a class="markdownIt-Anchor" href="#集合工具类"></a> 集合工具类</h2></li></ul><h2 id="java集合体系"><a class="markdownIt-Anchor" href="#java集合体系"></a> #Java集合体系</h2><p>  Java 集合框架主要包括两种类型的容器，一种是**<code>Collection</code><strong>，存储一个元素集合，另一种是</strong><code>Map</code>**。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 <a href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a>、<a href="https://www.runoob.com/java/java-linkedlist.html">LinkedList</a>、<a href="https://www.runoob.com/java/java-hashset.html">HashSet</a>、LinkedHashSet、<a href="https://www.runoob.com/java/java-hashmap.html">HashMap</a>、LinkedHashMap 等等。</p><p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p><ul><li>**接口：**是代表<b style="color:red">集合的抽象数据类型</b>。例如 Collection、List、Set、Map 等。<b style="color:#00FFFF">之所以定义多个接口，是为了以不同的方式操作集合对象。</b></li><li>**实现（类）：**是<b style="color:red">集合接口的具体实现</b>。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li><li>**算法：**是实现<b style="color:red">集合接口的对象里的方法执行的一些有用的计算</b>，例如：搜索和排序。<b style="color:#00FFFF">这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现</b>。</li></ul><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB.png" alt="Java集合体系" /></p><p><strong>体系概述：</strong></p><blockquote><ul><li>整个集合框架分为两个类型：<code>Collection</code> 和 <code>Map</code>，前者是存储一系列的<strong>对象</strong>；后者是存储一系列的<strong>键值对</strong>。</li><li>在集合框架体系下，衍生出四种具体的集合类型：<code>Map</code>、<code>Set</code>、<code>List</code>、<code>Queue</code></li></ul></blockquote><h2 id="体系详解"><a class="markdownIt-Anchor" href="#体系详解"></a> #体系详解</h2><h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h3><p><code>map</code>接口定义了<b style="color:red">存储的数据结构是<code>&lt;key,value&gt;</code> 形式</b>，根据 key 映射到 value，一个 key 对应一个 value，所以 <code>key</code> 不可重复，而 <code>value</code> 可重复，key 和 value 都可以是任何引用类型的数据。</p><p>在 <code>Map</code> 接口下会将存储的方式细分为不同的种类：</p><blockquote><ul><li><code>SortedMap</code> 接口：该接口映射可以对 <code>&lt;key,value&gt;</code> 按照自己的规则进行 <strong>排序</strong>，具体实现有 TreeMap。</li><li><code>AbstractMap</code> 类：它为子类提供好一些 <strong>通用的API实现</strong>，所有的具体 Map 都会继承它。</li></ul></blockquote><h4 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h4><p>  HashMap 是一个 <strong>最通用的</strong> 利用哈希表存储元素的集合，将元素放入 HashMap 时，将 <code>key</code> 的哈希值转换为数组的 <code>索引</code> 下标 <strong>确定存放位置</strong>，查找时，根据 <code>key</code> 的哈希地址转换成数组的 <code>索引</code> 下标 <strong>确定查找位置</strong>。HashMap 的实现不是同步的，这意味着<b style="color:#00FFFF">它不是线程安全的</b>。<b style="color:#00FFFF">它的 key、value 都可以为 null</b>，此外，HashMap 中的映射不是有序的。</p><blockquote><ul><li><strong>底层结构</strong>：JDK1.8 之前 HashMap 由 数组 + 单向链表 组成，数组是 HashMap 的主体，单向链表则是主要为了解决<font style="color:#00FFFF">哈希冲突（两个对象调用的 hashCode 方法计算的哈希值经哈希函数算出来的地址被别的元素占用）</font >而存在的（“拉链法”解决冲突）。<font style="color:red">JDK1.8 以后在解决哈希冲突时有了较大的变化，当单向链表长度大于阈值（或者红黑树的边界值，默认为 8 ）并且当前数组的长度大于 64 时，此时此索引位置上的所有数据改为使用红黑树存储。</font ></li><li><strong>扩充机制</strong>：<font style="color:red">HashMap扩充的两个重要元素<code>Capacity</code>(HashMap当前长度)和<code>LoadFactory</code>(负载因子，默认值为<strong>0.75f</strong>)</font>。<font style="color:#00FFFF">当存入第<code>Capacity</code>*<code>LoadFactory</code>+1个元素时就会进行<code>resize</code>(扩容)。扩容会创建一个新的Entry空数组，长度是原来的2倍；然后遍历原<code>Entry</code>数组，把所有的<code>Entry</code>重新<code>hash</code>(长度扩大后，hash的规则也会随之改变)到新数组。</font></li><li><strong>Hash算法</strong>：…</li></ul></blockquote><h4 id="linkedhashmap"><a class="markdownIt-Anchor" href="#linkedhashmap"></a> LinkedHashMap</h4><p>  LinkedHashMap 可以看作是 <code>HashMap</code> 和 <code>LinkedList</code> 的结合：它<font style="color:red">在 HashMap 的基础上添加了一条双向链表</font>，<code>默认</code> 存储各个元素的插入顺序，但由于这条双向链表，使得 LinkedHashMap 可以实现 <b style="color:yellow"><code>LRU</code> 缓存淘汰策略<sup>1</sup></b>，因为我们可以设置这条双向链表按照 <code>元素的访问次序</code> 进行排序。</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/LinkedHashMap%E7%BB%93%E6%9E%84.png" alt="LinkedHashMap结构" /></p><blockquote><ul><li>底层维护了一条 <code>双向链表</code>，因为继承了 HashMap，所以不是线程安全的。</li><li>LinkedHashMap 可实现 <code>LRU</code> 缓存淘汰策略，其原理是通过设置 <code>accessOrder</code> 为 <code>true</code> 并重写 <code>removeEldestEntry</code> 方法定义淘汰元素时需满足的条件。</li></ul></blockquote><p><font style="color:yellow"> ① ：LRU缓存淘汰策略 简要来说就是当内存满了将优先删除长时间未使用的数据。</font></p><h4 id="treemap"><a class="markdownIt-Anchor" href="#treemap"></a> TreeMap</h4><p>  TreeMap 是 <code>SortedMap</code> 的子类，所以它<font style="color:red">具有 排序 功能</font>。它是基于 红黑树 数据结构实现的，每一个键值对 <code>&lt;key,value&gt;</code> 都是一个节点，<strong>默认情况下按照 <code>key</code> 自然排序(放入的Key必须实现<code>Comparable</code>接口)，另一种是可以通过传入定制的 <code>Comparator</code> 进行自定义规则排序</strong>。</p><ul><li><p><strong>自然排序</strong>：要求 <code>key</code> 必须实现 <code>Comparable</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">TreeMap&lt;Integer,String&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>treeMap.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;TWO&quot;</span>);<br>treeMap.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ONE&quot;</span>);<br>System.out.print(treeMap);<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">&#123;1=ONE,2=TWO&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>定制排序</strong>：在初始化 TreeMap 时传入新的 <code>Comparator</code>，不要求 <code>key</code> 实现 Comparable 接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">TreeMap&lt;Integer,String&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;((o1,o2) -&gt; Integer.compare(o2,o1));<br>treeMap.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;TWO&quot;</span>);<br>treeMap.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ONE&quot;</span>);<br>treeMap.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Three&quot;</span>);<br>treeMap.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;Four&quot;</span>);<br>System.out.print(treeMap);<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">&#123;4=Four, 3=Three, 2=TWO, 1=ONE&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> HashTable</h4><p> HashTable和HashMap很相似，其底层的存储结构是 数组+单向链表 ，主要不同的是<strong>HashTable是线程安全的</strong>，很多方法都被<code>synchronized</code>修饰，但同时因为加锁导致并发效率低下，单线程环境效率也十分低；也是由于性能问题HashTable已经被淘汰。</p><p><strong>与HashMap的区别</strong>：</p><blockquote><p><strong>扩容机制</strong>：HashMap创建一个为原先2倍的数组，然后对原数组进行遍历以及rehash；HashTable扩容将创建一个原长度2倍的数组，再使用头插法将链表进行反序；</p><p><strong>结构区别</strong>：HashMap是由数组+链表形成，在JDK1.8之后链表长度大于8时转化为红黑树；而HashTable一直都是数组+链表；</p><p><strong>线程安全</strong>：Hashtable是多线程安全的，HashMap不是；</p><p><strong>遍历方式</strong>：HashMap仅支持<code>Iterator</code>的遍历方式，Hashtable支持<code>Iterator</code>和<code>Enumeration</code>两种遍历方式；</p><p><strong>继承关系</strong>：HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作；</p><p><strong>存储值</strong>：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。</p></blockquote><h4 id="weakhashmap"><a class="markdownIt-Anchor" href="#weakhashmap"></a> WeakHashMap</h4><p>  WeakHashMap 日常开发中比较少见，它是基于普通的 <code>Map</code> 实现的，而里面 <font style="color:red"><code>Entry</code> 中的键在每一次的 <code>垃圾回收</code> 都会被清除掉，所以非常适合用于存储 <strong>短暂访问</strong>、<strong>仅访问一次</strong> 的元素</font>。</p><p><font style="color:#00FFFF">WeakHashMap 内部维护了一个引用队列<code>queue</code></font>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Reference queue for cleared WeakEntries</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br></code></pre></div></td></tr></table></figure><p><font style="color:#00FFFF">这个 <code>queue</code>里包含了所有被 <code>GC</code> 掉的键，当JVM开启 <code>GC</code> 后，如果回收掉 WeakHashMap 中的 key，会将 key 放入 queue 中，在 <code>expungeStaleEntries()</code> 中遍历 queue，把 queue 中的所有 <code>key</code> 拿出来，并在 WeakHashMap 中删除掉，以达到 <strong>同步</strong></font >。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Expunges stale entries from the table.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Object x; (x = queue.poll()) != <span class="hljs-literal">null</span>; ) &#123;<br>            <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, table.length);<br><br>                Entry&lt;K,V&gt; prev = table[i];<br>                Entry&lt;K,V&gt; p = prev;<br>                <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>                    Entry&lt;K,V&gt; next = p.next;<br>                    <span class="hljs-keyword">if</span> (p == e) &#123;<br>                        <span class="hljs-keyword">if</span> (prev == e)<br>                            table[i] = next;<br>                        <span class="hljs-keyword">else</span><br>                            prev.next = next;<br>                        <span class="hljs-comment">// Must not null out e.next;</span><br>                        <span class="hljs-comment">// stale entries may be in use by a HashIterator</span><br>                        e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help GC</span><br>                        size--;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    prev = p;<br>                    p = next;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><ul><li>WeakHashMap的键是一种<b style="color:yellow"> <code>弱键</code><sup>2</sup></b>，放入 WeakHashMap 时，随时会被回收掉，所以不能确保某次访问元素一定存在。</li><li>它依赖普通的 <code>Map</code> 进行实现，是一个<strong>非线程安全的集合。</strong></li><li>WeakHashMap 通常作为 <strong>缓存</strong> 使用，适用存储那些 <code>只需访问一次</code>、或 <code>只需保存短暂时间</code> 的键值对。</li></ul></blockquote><p><font style="color:yellow"> ②：弱键 （<code>WeakReference</code>）:又称弱引用，被WeakReference引用时，在下个垃圾收集周期时该对象就会被回收。</font><br /><font style="color:yellow">扩展：</font><br /><font style="color:yellow">- 软引用（<code>SoftReference</code>）:被<code>SoftReference</code>指向的对象可能会被垃圾收集器回收，但是只有在JVM内存不够的情况下才会回收。</font><br /><font style="color:yellow">- 强引用（<code>StrongReference</code>）:被强引用指向的对象，绝对不会被垃圾收集器回收。</font></p><h3 id="collection"><a class="markdownIt-Anchor" href="#collection"></a> Collection</h3><p><code>Collection</code> 接口为其实现其接口的集合提供了 <strong>通用方法</strong>：</p><ul><li>添加方法：<code>add(E e)</code> / <code>addAll(Collection&lt;? extends E&gt; c)</code></li><li>删除方法：<code>remove(Object o)</code> / <code>removeAll(Collection&lt;?&gt; c)</code></li><li>查找方法：<code>contains(Object o)</code> / <code>containsAll(Collection&lt;?&gt; c)</code></li><li>查询集合自身信息；<code>size()</code> / <code>isEmpty()</code></li><li>···</li></ul><h4 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h4><p><code>List</code>接口直接继承于 Collection 接口，它定义为<font style="color:red">可以存储 <strong>重复</strong> 元素的集合，并且元素按照插入顺序 <strong>有序排列</strong>，且可以通过 <strong>索引</strong>访问指定位置的元素。</font>常见的实现有：<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code> 和 <code>Stack</code>。</p><p>List接口下也细分有不同的种类：</p><blockquote><ul><li><code>AbstractList</code>类：<font style="color:#00FFFF">内部实现了所有的 List 都需具备的功能</font>，子类可以专注于实现自己具体的操作逻辑。</li><li><code>AbstractSequentialList</code>类：<code>AbstractSequentialList</code> 继承了 <code>AbstractList</code>，在其原基础上<font style="color:#00FFFF">限制了访问元素的顺序 <strong>只能够按照顺序访问</strong>，而 <strong>不支持随机访问</strong></font>，如果需要满足随机访问的特性，则继承 AbstractList。</li></ul></blockquote><h5 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h5><p><font style="color:red">ArrayList 以 <strong>数组</strong> 作为存储结构，它是 <strong>线程不安全</strong> 的集合；具有 <strong>查询快、在数组中或头部增删慢</strong> 的特点</font>，所以它除了线程不安全这一点，其余可以替代 <code>Vector</code> ，而线程安全的 ArrayList 可以使用 <code>CopyOnWriteArrayList</code> 代替 Vector。</p><blockquote><ul><li><strong>底层结构</strong>：ArrayList 底层是使用数组作为存储结构，具有 <strong>查找快、增删慢、随机访问</strong> 的特点</li><li><strong>扩容机制</strong>：ArrayList <strong>首次扩容</strong>后其核心数组的长度为 <strong>10</strong>，集合从 <strong>第二次扩容</strong> 开始，数组长度将扩容为原来的 <strong>1.5</strong> 倍</li></ul></blockquote><h5 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h5><p><font style="color:red">LinkedList 底层采用 <strong>双向链表</strong> 数据接口存储元素，由于链表的内存地址 <strong>非连续</strong>，所以它不具备随机访问的特点，但由于它利用指针连接各个元素，所以插入、删除元素只需要 <strong>操作指针</strong>，不需要 <strong>移动元素</strong>，故具有 <strong>增删快、查询慢</strong> 的特点。</font>它也是一个<strong>非线程安全</strong>的集合。</p><p>LinkedList实现了 <code>Deque</code> 接口，使得 LinkedList 可以用作 <strong>双端队列</strong> 。<code>Node</code> 是LinkedList集合中的元素，提供了前驱指针和后继指针，还提供了一系列操作 <code>头结点</code> 和 <code>尾结点</code> 的方法，具有双端队列的特性。</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/LinkedList%E7%BB%93%E6%9E%84.png" alt="LinkedList结构" /></p><p>双向链表存储的每个节点称为一个 <code>Node</code> ， <code>Node</code> 中保存了 <code>next</code> 和 <code>prev</code> 指针，<code>item</code> 是该节点的值。在插入和删除时，时间复杂度都保持为 <code>O(1)</code></p><blockquote><ul><li><p>优势：<font style="color:red">LinkedList 底层没有 <code>扩容机制</code>，使用 <code>双向链表</code> 存储元素，所以插入和删除元素效率较高，适用于频繁操作元素的场景。</font></p></li><li><p>劣势：<font style="color:red">LinkedList 不具备 <code>随机访问</code> 的特点，查找某个元素只能从 <code>head</code> 或 <code>tail</code> 指针一个一个比较，所以 <strong>查找中间元素是效率很低</strong>。</font></p></li><li><p>查找优化：LinkedList 查找某个下标 <code>index</code> 的元素时做了优化，若 <code>index &lt; (size / 2)</code>，则从 <code>head</code> 往后查找，否则从 <code>tail</code> 开始往前查找，代码如下所示：</p>  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 查找的下标处于链表的前半部分则从头开始找</span><br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 查找的下标处于链表的后半部分则从尾开始找</span><br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></blockquote><h5 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> Vector</h5><p><code>Vector</code> 已经是一种过时的集合了，包括继承它的 <code>Stack</code> 集合也是如此，它们都同<code>HashTable</code>一样被淘汰的原因都是因为 <strong>性能</strong> 低下。</p><blockquote><p>JDK 1.0 时代，ArrayList 还没诞生，大家都是使用 Vector 集合，但由于 Vector 的 <strong>每个操作</strong> 都被 <strong>synchronized</strong> 关键字修饰，即使在线程安全的情况下， 仍然 <strong>进行着无意义的加锁/释放锁</strong>，造成额外的性能开销，做了无用功。</p></blockquote><h5 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> Stack</h5><p><font style="color:red"><code>Stack</code> 是一种 <code>后进先出（LIFO）</code> 型的集合容器。</font>如下图所示，<font style="color:#00FFFF">top 指针指向最后进入容器的元素。弹出元素时会将先栈顶元素开始移除。</font>Stack 继承了 Vector 类，提供了栈顶的压入元素操作（push）和弹出元素（pop），以及查看栈顶元素（peek）等等，但也是由于继承于 Vector，Stack 也渐渐被淘汰了。</p><p>取而代之的是 <code>Deque</code> 接口下的<code>ArrayDeque</code>，该数据结构更加完善，可靠性更好，依靠队列也可以实现 <code>LIFO</code> 的栈操作，所以优先选择 ArrayDeque 实现栈。</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/Stack%E7%BB%93%E6%9E%84.png" alt="Stack结构" /></p><h4 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h4><p>队列是一种特殊的线性表，遵循先进先出、后进后出的基本原则，一般来说，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，但是java的某些队列运行在任何地方插入删除；</p><p>Queue 中提供了两套增加、删除元素的 API，当插入或删除元素失败时，会有两种不同的失败处理策略。</p><table><thead><tr><th>方法及失败策略</th><th>插入方法</th><th>删除方法</th><th>查找方法</th></tr></thead><tbody><tr><td>抛出异常</td><td>add()</td><td>remove()</td><td>get()</td></tr><tr><td>返回失败默认值</td><td>offer()</td><td>poll()</td><td>peek()</td></tr></tbody></table><ul><li><p><code>add()</code> 和 <code>offer()</code> 对比：</p><p>在队列长度大小确定的场景下，队列放满元素后，添加下一个元素时，add() 会抛出 <code>IllegalStateException</code> 异常，而 <code>offer()</code> 会返回 <code>false</code>。但是他们两个方法在插入 <strong>某些不合法的元素</strong> 时会抛出三个相同的异常：<code>ClassCastExceptioin</code>,<code>NullPointerException</code>,<code>IllegalArgumentException</code>。</p></li><li><p><code>remove()</code> 和 <code>poll()</code> 对比：</p><p>在 <strong>队列为空</strong> 的场景下：<code>remove()</code> 会抛出 <code>NoSuchElmentException</code> 异常，而 <code>poll()</code> 则返回 <code>null</code>。</p></li><li><p><code>get()</code> 和 <code>peek()</code> 对比：</p><p>在队列为空的情况，<code>get()</code> 会抛出 <code>NoSuchElementException</code> 异常，而 <code>peek()</code> 则返回 <code>null</code>。</p></li></ul><p>Queue接口下可以细分不同的种类：</p><blockquote><ul><li><p><code>Deque</code>接口：<font style="color:#00FFFF">表示双端队列（Double-ended queue），同时具备 <strong>队列</strong> 和 <strong>栈</strong> 的性质。</font>双端队列可以在头尾都具有入队和出队的功能，即双端队列则可以分别从两端插入元素、两端移除元素。</p></li><li><p><code>AbstractQueue</code>类：AbstractQueue 类中提供了各个 API 的基本实现，主要针对各个不同的处理策略给出基本的方法实现，定义在这里的作用让 子类 根据其 方法规范 （操作失败时抛出异常还是返回默认值）实现具体的业务逻辑。</p></li></ul></blockquote><h5 id="linkedlist-2"><a class="markdownIt-Anchor" href="#linkedlist-2"></a> LinkedList</h5><p>上文已经解释过LinkedList实现了<code>Deque</code> 接口，提供了针对头结点和尾结点的操作，并且每个结点都有 <strong>前驱</strong> 和 <strong>后继</strong> 指针，具备双向队列的所有特性。</p><h5 id="arraydeque"><a class="markdownIt-Anchor" href="#arraydeque"></a> ArrayDeque</h5><p><code>ArrayDeque</code>是由数组组成的双端队列，它是 <strong>无界</strong> 的双端队列，最小的容量是 <code>8</code> （JDK1.8）。在 JDK11 之后默认容量是 <code>16</code>。</p><p>ArrayDeque可以当作栈，也可以当作队列；<font style="color:#00FFFF">作为栈时比 Stack 性能好，作为队列时比 LinkedList 性能好</font>。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">boolean add(E e)</td><td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>在队列尾部添加一个元素</td></tr><tr><td style="text-align:center">boolean offer(E e)</td><td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>在队列尾部添加一个元素，并返回是否成功</td></tr><tr><td style="text-align:center">E poll()</td><td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</td></tr><tr><td style="text-align:center">E element()</td><td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>获取第一个元素，如果没有将抛出异常</td></tr><tr><td style="text-align:center">E peek()</td><td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>获取第一个元素，如果返回null</td></tr><tr><td style="text-align:center">void push(E e)</td><td style="text-align:center"><font style="color:#00FFFF">(栈操作)</font>栈顶添加一个元素</td></tr><tr><td style="text-align:center">E pop()</td><td style="text-align:center"><font style="color:#00FFFF">(栈操作)</font>移除栈顶元素,如果栈顶没有元素将抛出异常</td></tr></tbody></table><blockquote><ul><li><strong>底层结构</strong>：数组 + 双向队列，ArrayDeque的出队入队是通过头尾指针循环，利用数组实现的。</li><li><strong>扩容机制</strong>：ArrayDeque容量不足时是会扩容的，每次扩容容量增加一倍。</li></ul></blockquote><h5 id="priorityqueue"><a class="markdownIt-Anchor" href="#priorityqueue"></a> PriorityQueue</h5><p>PriorityQueue 基于 <strong>优先级堆实现</strong> 的优先级队列。这里的<strong>优先</strong>是指：<b style="color:red">根据某种规则将队列元素进行排序，每次出队时总是取出排序中的最大或者最小元素，这样的特性决定优先队列不完全遵循FIFO规则，其中排序规则可以决策元素的优先级。</b></p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTest</span>()</span> &#123;<br>    Queue&lt;Integer&gt; random = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>    <span class="hljs-comment">//按2，1，3的顺序添加元素</span><br>    random.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>); random.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>); random.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);<br>    System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;输出：&quot;</span> );<br>    <span class="hljs-built_in">int</span> rs = random.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; rs; i++) &#123;<br>       System.<span class="hljs-keyword">out</span>.print(random.<span class="hljs-keyword">remove</span>() + <span class="hljs-string">&quot;,&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码按照FIFO规则结果应该是：输出：2,1,3,</p><p>然而实际输出：输出：</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">1,2,3,<br></code></pre></div></td></tr></table></figure><p><code>PriorityQueue</code>会按照自然顺序对元素进行排序，它要求元素实现 <code>Comparable</code> 接口，所以 <code>PriorityQueue</code> <strong>不允许存储 NULL 元素</strong>。</p><blockquote><ul><li><strong>底层结构</strong>：基于 优先级堆实现 的优先级队列，而堆是采用 <strong>数组</strong> 实现的。</li><li><strong>扩容机制</strong>：实例化时若未指定初始容量，默认容量为11。如果容量小于64，两倍增长扩容；否则增长50%。</li></ul></blockquote><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4><p><code>Set</code> 接口继承了 <code>Collection</code> 接口，是一个<b style="color:red">不包括重复元素</b>的集合，更确切地说，Set 中任意两个元素不会出现 <code>o1.equals(o2)</code>为<code>true</code>的情况，而且 Set <strong>至多</strong> 只能存储一个 <code>null</code> 值元素。</p><p>Set接口下细分的种类：</p><blockquote><ul><li><p><code>SortedSet</code> 接口：在 Set 的基础上扩展了 <strong>排序</strong> 的行为，所以所有实现它的子类都会拥有排序功能。</p></li><li><p><code>AbstractSet</code> 抽象类：定义在这里的方法可以将所有具体 Set 集合的 <strong>相同行为</strong> 在这里实现，<strong>避免子类包含大量的重复代码。</strong></p></li></ul></blockquote><h5 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h5><p><font style="color:red"><code>HashSet</code>是<code>Set</code>的实现类，自然其中不能存储相同的数据，存储数据时是无序的。而且HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。</font>HashSet 底层是借助 <code>HashMap</code> 实现，HashSet 中又没有额外添加同步策略所以HashSet 也是 <strong>线程不安全</strong>。</p><p>观察它的多个构造方法，本质上都是 new 一个 HashMap。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(Math.max((<span class="hljs-type">int</span>) (c.size()/<span class="hljs-number">.75f</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">16</span>));<br>        addAll(c);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity);<br>    &#125;<br><br>    HashSet(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">boolean</span> dummy) &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>其次还能看到一个 <strong>静态常量</strong><code>PRESENT</code>：使用 PRESENT 作为 HashMap 的 value 值，使用 HashSet 的开发者只需要 <strong>关注</strong> 插入的 <code>key</code>，<strong>屏蔽</strong> 了其中 HashMap 的 <code>value</code>。</p><blockquote><ul><li>底层数据结构： HashSet 和 HashMap 一样也是采用 <code>数组 + 链表 + 红黑树</code> 实现</li><li>存入 HashSet 的对象的状态 <strong>最好不要发生变化</strong>，因为有可能改变状态后，在集合内部出现两个元素 <code>o1.equals(o2) == true</code>，破坏了 <code>equals</code> 的含义。</li></ul></blockquote><h5 id="linkedhashset"><a class="markdownIt-Anchor" href="#linkedhashset"></a> LinkedHashSet</h5><p><font style="color:#00FFFF"><code>LinkedHashSet</code>继承自 <code>HashSet</code>，根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</font> LinkedHashSet插入性能略低于 HashSet，但在迭代访问Set里的全部元素时有很好的性能。</p><p>跟随<code>LinkedHashSet</code> 的构造方法可以发现它调用了父类构造方法创建了一个<code>LinkedHashMap</code>，而 <code>LinkedHashMap</code>底层又采用 HashMap + 双向链表 实现的；所以本质上 LinkedHashSet 还是使用 HashMap 实现的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">HashSet(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">boolean</span> dummy) &#123;<br>map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>LinkedHashSet 中也没有添加额外的同步策略，所以 LinkedHashSet 集合<strong>也不是线程安全</strong> 的。</p><blockquote><ul><li>底层数据结构： 继承于 <code>HashSet</code>，初始化时创建了一个LinkedHashMap，所以它是由 HashMap + 双向链表 构成的</li><li>除了具有set集合不重复的特点，同时具有可预测的迭代顺序，也就是我们插入的顺序。</li></ul></blockquote><h5 id="treeset"><a class="markdownIt-Anchor" href="#treeset"></a> TreeSet</h5><p><font style="color:red"><code>TreeSet</code>作用是提供有序的Set集合。TreeSet也是线程不安全的，它基于TreeMap实现，TreeSet和TreeMap一样，它们的元素支持2种排序方式：自然排序或者根据提供的Comparator进行排序。</font></p><p>TreeSet中的元素<strong>必须实现Comparable接口并重写<code>compareTo()</code>方法</strong>，TreeSet判断元素是否重复 、以及确定元素的顺序 靠的都是这个方法；对于未实现Comparable的元素，程序运行时会抛出java.lang.ClassCastException类型转化异常。</p><blockquote><p>① 对于Java类库中定义的类，TreeSet可以直接对其进行存储，如String，Integer等,因为这些类已经实现了Comparable接口);<br />② 对于自定义类，如果不做适当的处理，TreeSet中只能存储一个该类型的对象实例，否则无法判断是否重复。<br />③ 关于<code>compareTo()</code>方法规则：</p><ol><li>如果将compareTo()返回值写死为0，元素值每次比较，都认为是相同的元素，这时就不再向TreeSet中插入除第一个外的新元素。所以TreeSet中就只存在插入的第一个元素。</li><li>如果将compareTo()返回值写死为1，元素值每次比较，都认为新插入的元素比上一个元素大，于是二叉树存储时，会存在根的右侧，读取时就是正序排列的。</li><li>如果将compareTo()返回值写死为-1，元素值每次比较，都认为新插入的元素比上一个元素小，于是二叉树存储时，会存在根的左侧，读取时就是倒序序排列的。</li></ol></blockquote><h2 id="集合工具类-2"><a class="markdownIt-Anchor" href="#集合工具类-2"></a> #集合工具类</h2><h4 id="iteratoriterable-listiterator"><a class="markdownIt-Anchor" href="#iteratoriterable-listiterator"></a> Iterator，Iterable &amp; ListIterator</h4><ul><li><p><code>Iterator</code> 接口：迭代器（Iterator）有时又称为游标（cursor），<font style="color : red">提供一种方法访问一个容器（container）对象中各个元素，而又不暴露该对象的内部细节。</font></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>提供的API接口含义如下：</p><ul><li><code>hasNext()</code> ：判断集合中是否存在下一个对象</li><li><code>next()</code> ：返回集合中的下一个对象，并将访问指针移动一位</li><li><code>remove()</code> ：删除集合中调用 <code>next()</code> 方法返回的对象</li></ul><p>在早期，遍历集合的方式只有一种，通过 <code>Iterator</code> 迭代器操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Iterator&lt;Integer&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>    System.out.println(next);<br>    <span class="hljs-keyword">if</span>(next==<span class="hljs-number">2</span>)&#123;iterator.remove();&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>Iterable</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// JDK1.8</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><font style="color:grey">待编纂。。</font></p></li></ul><h4 id="collections"><a class="markdownIt-Anchor" href="#collections"></a> Collections</h4><p><font style="color:grey">待编纂。。</font></p><h4 id="arrays"><a class="markdownIt-Anchor" href="#arrays"></a> Arrays</h4><p><font style="color:grey">待编纂。。</font></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/helloworld/notes/Java/JVM/"/>
    <url>/helloworld/notes/Java/JVM/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><p><a href="https://blog.kyire.site/2021/05/06/eb9166f8.html">JVM探究</a></p></li><li><p><a href="https://blog.csdn.net/qq_41644234/article/details/117733410">JVM详解-栈&amp;堆</a></p></li><li><p><a href="https://blog.csdn.net/xtayfjpk/article/details/41924283?utm_source=tuicool&amp;utm_medium=referral">深入理解Java虚拟机笔记—运行时栈帧结构</a></p></li><li><p><a href="https://blog.csdn.net/zuodaoyong/article/details/106560472">JVM堆详解</a></p></li><li><p><a href="https://www.joshua317.com/article/189">Java 类和对象在内存中的表现形式</a></p></li><li><p>Java虚拟机详解</p><ol><li><a href="https://www.cnblogs.com/qianguyihao/p/4736162.html">常用JVM配置参数</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4744233.html">GC算法和种类</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4748313.html">垃圾收集器及GC参数</a></li></ol></li><li><p><a href="https://blog.csdn.net/Littewood/article/details/123327233">JVM之本地方法接口和本地方法栈</a></p></li></ul><h2 id="jvm体系结构"><a class="markdownIt-Anchor" href="#jvm体系结构"></a> #JVM体系结构</h2><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/JVM%E4%BD%93%E7%B3%BB.png" alt="JVM体系" /></p><h2 id="类加载过程"><a class="markdownIt-Anchor" href="#类加载过程"></a> #类加载过程</h2><p>  <b style="color:red">类加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象</b>，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。<br />  <b style="color:#00FFFF">类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。</b>除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程" /></p><p><strong>双亲委派机制</strong></p><p>  <b style="color:red">当某个类加载器需要加载某个<code>.class</code>文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。</b></p><p>各种类加载器的区别：</p><p><strong>BootstrapClassLoader（启动类加载器）</strong></p><p><code>c++</code>编写，加载<code>java</code>核心库 <code>java.*</code>,构造<code>ExtClassLoader</code>和<code>AppClassLoader</code>。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作</p><p><strong>ExtClassLoader （标准扩展类加载器）</strong></p><p><code>java</code>编写，加载扩展库，如<code>classpath</code>中的<code>jre</code> ，<code>javax.*</code>或者<br /><code>java.ext.dir</code> 指定位置中的类，开发者可以直接使用标准扩展类加载器。</p><p><strong>AppClassLoader（系统类加载器）</strong></p><p><code>java</code>编写，加载程序所在的目录，如<code>user.dir</code>所在的位置的`class</p><p><strong>CustomClassLoader（用户自定义类加载器）</strong></p><p><code>java</code>编写,用户自定义的类加载器,可加载指定路径的<code>class</code>文件</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt="双亲委派" /></p><p>双亲委派作用：</p><ol><li><b style="color:red">防止重复加载同一个<code>.class</code></b>。通过委托去向上面查找，加载过了，就不用再加载一遍。保证数据安全。</li><li><b style="color:red">保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了</b>。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ol><h2 id="运行时数据区"><a class="markdownIt-Anchor" href="#运行时数据区"></a> #运行时数据区</h2><h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3><p>栈是一种数据结构，只能在一端进行插入和删除操作的特殊线性表。它<b style="color:red">按照后进先出的原则存储数据</b>，<b style="color:#00FFFF">先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据(最后一个数据被第一个读出来)</b>。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p><p><strong>JVM中的栈</strong>：Oracle关于<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html">栈和栈帧</a>提供了如下描述：</p><blockquote><p><u>每个JVM线程拥有一个私有的 Java虚拟机栈，创建线程的同时栈也被创建。一个JVM栈由许多帧组成，称之为&quot;栈帧&quot;。</u>JVM中的栈和C等常见语言中的栈比较类似，都用于保存局部变量和部分计算结果，同时也参与方法调用和返回。</p></blockquote><p>如Oracle官方说明，<strong>每个线程拥有自己的私有栈</strong>，因此在多线程应用中将有多个栈，<strong>每个栈有自己的栈帧</strong>。</p><p><strong>Java中的栈</strong>：</p><ul><li>当一个新的线程创建时，JVM会为这个线程创建一个新的Stack。一个Java Stack在一个个独立的栈帧中存储了线程的状态。<b style="color:red">JVM只会在Java Stack中做两个操作：push 和 pop.</b></li><li>一个线程当前正在执行的方法称之为线程的 <u>当前方法</u>，当前方法对应的栈帧称为 <u>当前帧</u>，当前方法所属的类称为 <u>当前类</u>，当前类的常量池称为 当前常量池。 <strong>在执行一个方法时，JVM会保存当前类和当前常量池的轨迹。当JVM执行 需要操作栈帧中数据的指令时，JVM会在当前栈帧进行处理。</strong></li><li>当一个线程执行一个Java方法时，JVM将创建一个新的栈帧并且把它push到栈顶。此时新的栈帧就变成了当前栈帧，<u>方法执行时，使用栈帧来存储参数、局部变量、中间指令以及其他数据</u>。</li></ul><p><b style="color:red">栈内存，主管程序的运行，生命周期和线程同步</b></p><p><b style="color:red">线程结束，栈内存释放，对于栈来说，不存在垃圾回收</b></p><p><strong>栈&amp;栈帧详解(简单了解)</strong>：</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/Java%E6%A0%88&amp;%E6%A0%88%E5%B8%A7.png" alt="Java栈&amp;栈帧" /></p><ul><li><p><strong>局部变量表</strong></p><p>局部变量表是一组<strong>变量值存储</strong>空间，<b style="color:red">用于存放方法参数和方法内部定义的局部变量</b>。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。</p><blockquote><p>  在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字<code>this</code>来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量<code>Slot</code>，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的<code>Slot</code>。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的<code>Slot</code>就可以交给其它变量使用。<br />  局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。</p></blockquote></li><li><p>操作数栈</p><p>当一个方法刚刚执行的时候，这个方法的操作数栈是空的，**在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。**例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。</p><blockquote><p>   操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意Java数据类型，包括<code>long</code>和<code>double</code>。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个”字宽“占4个字节，对于64位虚拟机来说，一个”字宽“占8个字节。<br />  另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了。</p></blockquote></li><li><p>动态连接</p><p><strong>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用</strong>，持有这个引用是为了支持方法调用过程中的动态连接。</p><blockquote><p>  在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为<strong>动态连接</strong>。</p></blockquote></li><li><p>方法返回地址</p><p>当一个方法被执行后，有两种方式退出这个方法。</p><ol><li><p>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。</p></li><li><p>在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。</p></li></ol><blockquote><p>  无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。<br />  方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。</p></blockquote></li><li><p>附加信息</p><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。</p></li></ul><h3 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h3><ul><li>一个JVM实例只存在一个堆内存，堆也是<b style="color:red">Java内存管理的核心区域。</b></li><li><b style="color:red">Java堆在JVM启动的时候被创建，其空间大小也就确定了。</b>是JVM管理的最大的一块内存空间。</li><li><b style="color:red">堆可以处于物理上不连续的内存空间中，但在逻辑上为连续的。</b></li><li>所有线程共享堆，还可以划分线程私有的缓冲区（TLAB）</li><li><strong>堆内存中主要存放数据是 类的成员变量，实例对象等</strong></li></ul><p><strong>堆空间分代思想</strong>：</p><p>  为什么需要分代？<br />  分代唯一的理由是优化GC(垃圾回收机制)性能，如果没有分代，那所有的对象都在一起，GC的时候要找到哪些对象没用，这样就会在堆的所有区域进行扫描。</p><blockquote><p>Java 7及之前堆内存逻辑上分三部分：<strong>新生区+养老区+<b style="color:red">永久区</b></strong><br />Java 8及之后堆内存逻辑上分为：<strong>新生区+养老区+<b style="color:red">元空间</b></strong></p></blockquote><ul><li><p>新生代（新生区）</p><p>主要是用来存放新生的对象。一般占据堆的1/3空间。</p><p>新生代又分为 <strong>Eden区、ServivorFrom、ServivorTo</strong>三个区。</p><ul><li>Eden区：<b style="color:red">Java新对象的出生地</b><b style="color:#00FFFF">（如果新创建的对象占用内存很大，则直接分配到老年代）</b>。当Eden区内存不够的时候就会触发<b style="color:yellow">MinorGC<sup>1</sup></b>，对新生代区进行一次垃圾回收。</li><li>ServivorTo：保留了一次<b style="color:yellow">MinorGC<sup>1</sup></b>过程中的幸存者。</li><li>ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。</li></ul></li><li><p>老年代（养老区）</p><p>在进行<b style="color:yellow">MajorGC<sup>2</sup></b>前一般都先进行了一次<b style="color:yellow">MinorGC<sup>1</sup></b>，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次<b style="color:yellow">MajorGC<sup>2</sup></b>进行垃圾回收腾出空间。</p></li><li><p>永久代（永久区/元空间）</p><p>指<strong>内存的永久保存区域</strong>，主要存放Class和Meta（元数据）的信息。</p><p>Class在被加载的时候被放入永久区域。它和和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。</p><p><strong>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</strong></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过<b style="color:red">元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</b>因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory，字符串池和类的静态变量放入 堆 中。这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p><p><font style="color:yellow">①：MinorGC，也称轻GC，采用复制算法。</font><br /><font  style="color:yellow">②：MajorGC，也称重GC，采用标记—清除算法。</font></p></li></ul><h3 id="方法区"><a class="markdownIt-Anchor" href="#方法区"></a> 方法区</h3><p>**方法区跟堆一样，又被称为静态区，通常存放常量数据。它存储已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等,它跟堆一样，被所有的线程共享。**但是<b style="color:red">实例变量存在堆内存中，和方法区无关！</b></p><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名称( java.lang.Object除外，其他类型若没有声明父类，默认父类是Object)</li><li>这个类型的修饰符(public、abstract、final的某个子集)</li><li>这个类型直接接口的一个有序列表</li></ul><p><strong>除此之外还方法区（Method Area）存储类信息还有</strong></p><ul><li>类型的常量池( constant pool)</li><li>域(Field)信息</li><li>方法(Method)信息</li><li>除了常量外的所有静态(static)变量</li></ul><h3 id="程序计数器"><a class="markdownIt-Anchor" href="#程序计数器"></a> 程序计数器</h3><p>每个线程都有一个程序计数器，是线程私有的，就是一个指针, 指向方法区中的方法字节码(用来存储指向像一条指令的地址， 也即将要执行的指令代码)，在执行引擎读取下一条指令, 是一个非常小的内存空间，几乎可以忽略不计。</p><p><font style="color:grey">待完善</font></p><h3 id="垃圾回收机制gc"><a class="markdownIt-Anchor" href="#垃圾回收机制gc"></a> 垃圾回收机制(GC)</h3><p>垃圾回收是指<strong>对在系统运行过程当中所产生的一些无用的对象回收，如果这些对象一直占据着内存空间，长期不被释放，可能导致内存溢出(OOM)</strong>。</p><p>Java中，<strong>GC的对象是Java堆和方法区</strong>：</p><blockquote><p>  内存区域中的<strong>程序计数器、虚拟机栈、本地方法栈</strong>这3个区域随着线程而生，线程而灭；<strong>栈中的栈帧</strong>随着方法的进入和退出，每个栈帧中分配多少内存基本是<strong>在类结构确定下来时就已知的。在这几个区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了</strong>。<br />  而<strong>Java堆和方法区</strong>则不同，一个接口中的多个实现类需要的内存可能不同，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，<strong>这部分内存的分配和回收都是动态的</strong>，GC关注的也是这部分内存。</p></blockquote><p>垃圾回收机制算法：<sub>GC算法种类很多，本文只简单介绍几种</sub></p><ul><li><p><strong>引用计数算法</strong></p><p><b style="color:#00FFFF">给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</b></p><p>缺陷：</p><ol><li><p>引用和去引用伴随加法和减法，影响性能。</p></li><li><p><b style="color:red">对于循环引用的对象无法进行回收</b></p></li></ol><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95.png" alt="引用计数算法" /></p></li><li><p><strong>根搜索算法</strong></p><p><b style="color:#00FFFF">设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。</b></p><p>从根（GC Roots）的对象作为起始点，开始向下搜索，搜索所走过的路径称为“<strong>引用链</strong>”，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<b style="color:#00FFFF">此逻辑称为可达性分析</b>。</p><p>而对于<strong>根搜索算法</strong>中的**根(GC Roots)**大致分为以下几种：</p><blockquote><ol><li><p>栈（栈帧中的本地变量表）中引用的对象。<strong>[本地变量表]</strong></p></li><li><p>本地方法栈中JNI（一般说的Native方法）引用的对象。<strong>[本地变量表]</strong></p></li><li><p><strong>方法区</strong>中的常量引用的对象（全局变量）</p></li><li><p><strong>方法区</strong>中的静态成员。</p></li></ol></blockquote><p><b style="color:red">在根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，分别是复制算法、标记-清除算法、标记-整理**算法。这三种算法都扩充了根搜索算法。</b></p></li><li><p><strong>复制算法</strong></p><p>原有的内存空间分为两块，每次只使用其中一块，<b style="color:#00FFFF">在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收</b>。</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法" /></p><p>缺陷：</p><p><strong>复制算法使得每次都只对整个半区进行内存回收</strong>，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。虽然实现简单，运行高效。但是这种算法的代价是将内存缩小为原来的一半。</p></li><li><p><strong>标记-清除算法</strong></p><p>标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：<b style="color:yellow">标记阶段</b>和<b style="color:yellow">清除阶段</b>。一种可行的实现是，在标记阶段，<strong>首先通过根节点，标记所有从根节点开始的可达对象</strong>。因此，未被标记的对象就是未被引用的垃圾对象；然后，在清除阶段，清除所有未被标记的对象。</p><ul><li>标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</li><li>清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</li></ul><p><b style="color:red">当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。</b></p><p><b style="color:#00FFFF">暂停程序运行是必须的！为了防止标记清除算法运行过程中，程序新创建对象进入内存，从而错过标记阶段使这个新对象直接在清除阶段被清除。所以需要停止程序运行！</b></p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记-清除算法" /></p><p>缺陷：</p><ol><li><strong>效率较低（递归与全堆对象遍历）</strong></li><li><strong>这种方式清理出来的空闲内存是不连续的</strong></li></ol></li><li><p><strong>标记-整理算法</strong></p><p>标记-压缩算法适合用于存活对象较多的场合。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记；<b style="color:#00FFFF">但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端；再清理边界外所有的空间。</b></p><ul><li>标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。</li><li>整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</li></ul><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记-整理算法" /></p><p>缺陷：</p><p>标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。</p><p><strong>标记-清除算法、复制算法、标记整理算法的总结：</strong></p><blockquote><p>（1）<strong>效率</strong>：<strong>复制算法</strong>&gt;标记/整理算法&gt;标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。</p><p>（2）<strong>内存整齐度</strong>：复制算法=标记/整理算法&gt;标记/清除算法。</p><p>（3）内存利用率：标记/整理算法=标记/清除算法&gt;复制算法。</p></blockquote></li></ul><h3 id="native"><a class="markdownIt-Anchor" href="#native"></a> Native</h3><ul><li>native :凡是带了native关键字的，说明Java的作用范围达不到了，回去调用底层c语言的库！它的初衷也是为了融合C/C++程序</li><li>调用本地方法本地接口 JNI (Java Native Interface)</li><li>JNI作用:开拓Java的使用，融合不同的编程语言为Java所用!最初: <code>C</code>、<code>C++</code></li><li>它在内存区域中专门开辟了一块标记区域: Native Method Stack，登记native方法</li><li>在最终执行的时候，加载本地方法库中的方法通过JNI</li><li><font style="color:grey">待完善</font></li></ul><h3 id="native-method-stack本地方法栈"><a class="markdownIt-Anchor" href="#native-method-stack本地方法栈"></a> Native Method Stack(本地方法栈)</h3><p><b style="color:#00FFFF">Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</b></p><p><strong>本地方法栈，也是线程私有的。</strong></p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li><p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。</p></li><li><p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</p></li></ul><p>本地方法是使用C语言实现的。</p><p><font style="color:grey">待完善</font></p><p><strong>具体做法：Native Method Stack中登记native方法，在执行引擎(Execution Engine)执行时加载本地方法库</strong></p><p><font style="color:grey">待完善。。</font></p><h2 id="执行引擎"><a class="markdownIt-Anchor" href="#执行引擎"></a> #执行引擎</h2><h3 id="native-interface本地方法接口"><a class="markdownIt-Anchor" href="#native-interface本地方法接口"></a> Native Interface(本地方法接口)</h3><p>简单地讲，一个Native Method是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p><img src="https://c1thulhu.oss-ap-northeast-1.aliyuncs.com/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%A6%82%E8%A6%81%E5%9B%BE.png" alt="本地方法运行概要图" /></p><p><font style="color:grey">待完善。</font></p><h2 id="jvm调优"><a class="markdownIt-Anchor" href="#jvm调优"></a> #JVM调优</h2><p><font style="color:grey">待编纂。。</font></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
