<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/helloworld/notes/%E4%B8%AD%E9%97%B4%E4%BB%B6/NoSql/Redis/"/>
    <url>/helloworld/notes/%E4%B8%AD%E9%97%B4%E4%BB%B6/NoSql/Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><a href="https://www.runoob.com/redis/redis-tutorial.html">Redis 教程-菜鸟教程</a></li><li><a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-overview.html">Redis教程 - Redis知识体系详解</a></li></ul><h2 id="redis介绍"><a class="markdownIt-Anchor" href="#redis介绍"></a> #Redis介绍</h2><p>  Redis是一种内存高速缓存数据库，支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p><p>Redis优点：</p><ul><li>读写新能优异</li><li>数据类型丰富</li><li>特性丰富</li><li>发布订阅</li><li>原子性</li><li>持久化</li><li>分布式</li></ul><h2 id="redis数据类型"><a class="markdownIt-Anchor" href="#redis数据类型"></a> #Redis数据类型</h2><p>  <font style="color:red">首先对redis来说，所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型。</font></p><h3 id="基础数据类型"><a class="markdownIt-Anchor" href="#基础数据类型"></a> 基础数据类型</h3><p>常见的5种数据类型，分别是：String、List、Set、Zset、Hash。</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/redis-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B.jpeg" alt="redis-基础类型" /></p><p>5种类型的特性如下表所示：</p><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td><strong>String字符串</strong></td><td>可以是字符串、整数或浮点数</td><td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td></tr><tr><td><strong>List列表</strong></td><td>一个链表，链表上的每个节点都包含一个字符串</td><td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td></tr><tr><td><strong>Set集合</strong></td><td>包含字符串的无序集合</td><td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td></tr><tr><td><strong>Hash散列</strong></td><td>包含键值对的无序散列表</td><td>包含方法有添加、获取、删除单个元素</td></tr><tr><td><strong>Zset有序集合</strong></td><td>和散列一样，用于存储键值对</td><td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td></tr></tbody></table><ol><li><p><strong>String</strong></p><p><font style="color:red">String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</font></p><p>相关命令：</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>GET</td><td>获取存储在给定键中的值</td><td><code>GET name</code></td></tr><tr><td>SET</td><td>设置存储在给定键中的值</td><td><code>SET name value</code></td></tr><tr><td>DEL</td><td>删除存储在给定键中的值</td><td><code>DEL name</code></td></tr><tr><td>INCR</td><td>将键存储的值加1</td><td><code>INCR key</code></td></tr><tr><td>DECR</td><td>将键存储的值减1</td><td><code>DECR key</code></td></tr><tr><td>INCRBY</td><td>将键存储的值加上整数</td><td><code>INCRBY key amount</code></td></tr><tr><td>DECRBY</td><td>将键存储的值减去整数</td><td><code>DECRBY key amount</code></td></tr></tbody></table><p><font style="color:grey">详细请参考官方文档：<a href="https://redis.io/commands/">https://redis.io/commands/</a></font></p><p>使用场景：</p><ul><li><font style="color:#00FFFF"><strong>缓存</strong>：经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</font></li><li><strong>计数器</strong>：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li><li><strong>session</strong>：常见方案spring session + redis实现session共享。</li></ul></li><li><p><strong>List列表</strong></p><p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p><p>相关命令：</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>RPUSH</td><td>将给定值推入到列表右端</td><td>RPUSH key value</td></tr><tr><td>LPUSH</td><td>将给定值推入到列表左端</td><td>LPUSH key value</td></tr><tr><td>RPOP</td><td>从列表的右端弹出一个值，并返回被弹出的值</td><td>RPOP key</td></tr><tr><td>LPOP</td><td>从列表的左端弹出一个值，并返回被弹出的值</td><td>LPOP key</td></tr><tr><td>LRANGE</td><td>获取列表在给定范围上的所有值</td><td>LRANGE key 0 -1</td></tr><tr><td>LINDEX</td><td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td><td>LINDEX key index</td></tr></tbody></table><p><font style="color:grey">详细请参考官方文档：<a href="https://redis.io/commands/">https://redis.io/commands/</a></font></p><p>应用场景：</p><ul><li><strong>微博TimeLine</strong>: 有人发布微博，用lpush加入时间轴，展示新的列表信息。</li><li><strong>消息队列</strong></li></ul></li><li><p><strong>Set集合</strong></p><p><font style="color:red">Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</font></p><p>相关命令：</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>SADD</td><td>向集合添加一个或多个成员</td><td>SADD key value</td></tr><tr><td>SCARD</td><td>获取集合的成员数</td><td>SCARD key</td></tr><tr><td>SMEMBERS</td><td>返回集合中的所有成员</td><td>SMEMBERS key member</td></tr><tr><td>SISMEMBER</td><td>判断 member 元素是否是集合 key 的成员</td><td>SISMEMBER key member</td></tr></tbody></table><p><font style="color:grey">详细请参考官方文档：<a href="https://redis.io/commands/">https://redis.io/commands/</a></font></p><p>应用场景：</p><ul><li><strong>标签</strong>（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li><li><strong>点赞，或点踩，收藏等</strong>，可以放到set中实现</li></ul></li><li><p><strong>Hash散列</strong></p><p><font style="color:red">Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</font></p><p>相关命令：</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>HSET</td><td>添加键值对</td><td>HSET hash-key sub-key1 value1</td></tr><tr><td>HGET</td><td>获取指定散列键的值</td><td>HGET hash-key key1</td></tr><tr><td>HGETALL</td><td>获取散列中包含的所有键值对</td><td>HGETALL hash-key</td></tr><tr><td>HDEL</td><td>如果给定键存在于散列中，那么就移除这个键</td><td>HDEL hash-key sub-key1</td></tr></tbody></table><p><font style="color:grey">详细请参考官方文档：<a href="https://redis.io/commands/">https://redis.io/commands/</a></font></p><p>应用场景：</p><ul><li><strong>缓存</strong>：相比string更节省空间地维护缓存信息，如用户信息，视频信息等。</li></ul></li><li><p><strong>Zset有序集合</strong></p><p><font style="color:red">Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。<strong>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序</strong>。</font></p><p>有序集合的成员是唯一的, 但分数(score)却可以重复。有序集合是通过两种数据结构实现：</p><ul><li><strong>压缩列表(ziplist)</strong>: ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li><li><strong>跳跃表（zSkiplist)</strong>: 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</li></ul><p>相关命令：</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>ZADD</td><td>将一个带有给定分值的成员添加到有序集合里面</td><td>ZADD zset-key 178 member1</td></tr><tr><td>ZRANGE</td><td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td><td>ZRANGE zset-key 0-1 withccores</td></tr><tr><td>ZREM</td><td>如果给定元素成员存在于有序集合中，那么就移除这个元素</td><td>ZREM zset-key member1</td></tr></tbody></table><p><font style="color:grey">详细请参考官方文档：<a href="https://redis.io/commands/">https://redis.io/commands/</a></font></p><p>应用场景：</p><ul><li><strong>排行榜</strong>：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li></ul></li></ol><h3 id="特殊数据类型"><a class="markdownIt-Anchor" href="#特殊数据类型"></a> 特殊数据类型</h3><ol><li><p><strong>HyperLogLogs</strong></p><p><strong>基数统计</strong>，可以非常省内存地统计各种计数的算法。在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>PFADD</td><td>添加指定元素到 HyperLogLog 中</td><td>PFADD key element [element …]</td></tr><tr><td>PFCOUNT</td><td>返回给定 HyperLogLog 的基数估算值</td><td>PFCOUNT key [key …]</td></tr><tr><td>PFMERGE</td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td><td>PFMERGE destkey sourcekey [sourcekey …]</td></tr></tbody></table></li><li><p><strong>Bitmap</strong></p><p><strong>位存储</strong>，即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。用于统计用户信息：打卡(不打卡)、 登录(未登录) 等<strong>两个状态的数据，都可以使用 Bitmaps</strong>。</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>SETBIT</td><td>添加指定元素到 Bitmap 中</td><td>SETBIT sign key value</td></tr><tr><td>GETBIT</td><td>返回Bitmap中的指定key值元素</td><td>GETBIT sign key</td></tr><tr><td>BITCOUNT</td><td>统计操作</td><td>BITCOUNT sign</td></tr></tbody></table></li><li><p><strong>geospatial</strong></p><p><strong>地理位置</strong>，用于存储地理位置信息，并对存储的信息进行操作</p><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>GEOADD</td><td>将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key(多个坐标以空格分割)</td><td>GEOADD key longitude latitude member …</td></tr><tr><td>GEOPOS</td><td>获取地理位置的坐标</td><td>GEOPOS key member</td></tr><tr><td>GEODIST</td><td>计算两个位置之间的距离</td><td>GEODIST key member1 member2</td></tr><tr><td>GEORADIUS</td><td>根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</td><td></td></tr><tr><td>GEORADIUSBYMEMBER</td><td>根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合</td><td></td></tr><tr><td>GEOHASH</td><td>返回一个或多个位置对象的 geohash 值</td><td></td></tr></tbody></table></li></ol><h2 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> #持久化</h2><h2 id="事件事务"><a class="markdownIt-Anchor" href="#事件事务"></a> #事件&amp;事务</h2>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>NoSql</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
      <tag>中间件</tag>
      
      <tag>NoSql</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列</title>
    <link href="/helloworld/notes/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/helloworld/notes/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><a href="https://www.bilibili.com/video/BV1cb4y1o7zz/">尚硅谷RabbitMQ教程</a></li><li><a href="https://mp.weixin.qq.com/s/WMriUm27CZkiSWEt1f4lig">CodeSheep - RabbitMQ 养成攻略</a></li><li><a href="https://developer.aliyun.com/article/769883#slide-15">超详细的RabbitMQ入门</a></li><li><a href="https://www.rabbitmq.com/getstarted.html">RabbitMQ官方文档</a></li></ul><h2 id="mq介绍"><a class="markdownIt-Anchor" href="#mq介绍"></a> #MQ介绍</h2><p>  <font style = "color:red">MQ(message queue)消息队列，本质上是队列，<strong>FIFO先入先出</strong>，是一种跨进程的通讯机制，用于上下游传递信息。</font>在互联网架构中，MQ是一种非常常见的向下游 “逻辑解耦+物理解耦” 的消息通讯服务。使用MQ后，消息发发送上游只需要依赖MQ，不需要依赖其他服务。</p><h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3><ul><li><p><strong>流量消峰</strong></p><p>  <font style = "color:red"><strong>流量高峰</strong>主要是用于应对大流量的业务，短时间内大量的用户抢占有限的资源所发生的高并发场景。</font>针对于流量进行削峰，最通用的解决方法是用消息队列来<strong>缓冲瞬时流量</strong>，消息队列本质就是一个缓冲区，用于延缓数据请求，队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。</p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0.png" alt="消息队列-流量削峰" style="zoom:80%;" /></li><li><p>应用解耦</p><p>  **由于系统的耦合，当系统中某子系统A调用另一子系统B接口时，如果被调用接口子系统B出现异常就会导致调用接口的子系统A也出现异常。**解决这个问题电商应用中订单下单操作就是一个经典的案例：</p><p>  在用户下单成功后，会将消息发送给消息队列，然后订单系统结束操作，由队列分配消息给其他子系统（支付、库存、物流等）直到所有子系统执行完成，如果存在任意一个子系统执行出现异常而导致未完成成功，队列会继续监督该模块继续执行，直至全部执行成功。</p><p>  <font style="color:#00FFFF"><strong>模块之间的调用十分复杂，为了降低模块与模块之间调用依赖，使用MQ将两系统分开,不直接调用系统接口,减轻两系统依赖关系，确保主站业务的连续性。</strong> </font></p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6.png" alt="消息队列-应用解耦" /></p></li><li><p>异步处理</p><p>  当服务A调用服务B需要花费很长时间执行，但是服务A需要拿到B是否执行完成，传统方式有两种解决方案：1、A过一段时间去调用B查询接口，2、B执行完成后调用A的CallBack接口。两种方式虽然能实现效果，但代码层面都不优雅。通过消息队列能更方便地实现：</p><p>  在A服务调用B服务接口后不用等待完成，而去处理其他请求，当B完成时将处理结果发送给消息队列，再由消息队列去通知A，B处理的结果。</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt="消息队列-异步请求" /></p></li></ul><h2 id="mq分类"><a class="markdownIt-Anchor" href="#mq分类"></a> #MQ分类</h2><ol><li><p>ActiveMQ</p><p>优点：单机<strong>吞吐量万级</strong>，时效性ms级，可用性高，基于主从架构实现高可用性，不容易丢失数据。</p><p>缺点：维护少，高吞吐量场景较少使用。</p></li><li><p>Kafka</p><p><font style="color:red"><strong>大数据杀手锏</strong>，为大数据而生的消息中间件，以<strong>百万级TPS</strong>的吞吐量名声大噪，在数据采集、传输、存储过程中发挥着重要作用</font>，目前被Nefflix、Twitter等大公司所采纳。</p><p>优点：<strong>性能卓越</strong>，<strong>单机写入TPS约在百万条/秒</strong>，最大优点是吞吐量高。时效性ms级可用性高，并且kafka是<strong>分布式</strong>的，一个数据多个副本，少数机器宕机不会造成数据丢失和不可用，消费者采用Pull方式获取数据，消息有序，</p><p>缺点：单机超过64个队列/分区，Load(负载)会出现明显飙高现象，<strong>队列越多，load越高，发送消息时间响应时间变长</strong>；使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但代理宕机后，会出现消息乱序。</p></li><li><p>RocketMQ</p><p>出自阿里巴巴开源产品，用Java实现，设计参考kafka</p><p>优点：<strong>单机吞吐量十万级</strong>，可用性非常高，<strong>分布式架构</strong>，消息可以做到0丢失，MQ功能较为完善，拓展性好，<strong>支持10亿级别的消息堆积</strong>，<strong>不会因为堆积导致性能下降</strong>。</p><p>缺点：<strong>支持的客户端语言不多</strong>，目前是Java和C++。</p></li><li><p>RabbitMQ</p><p><font style="color:red">在<font style="color:yellow">AMQP<sup>1</sup></font>（高级消息队列协议）基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</font></p><p>优点：由于<strong>erlang语言的高并发特性</strong>，性能好；<strong>吞吐量万级</strong>，MQ功能比较完备，健壮、稳定、易用、跨平台、支持多语言等。</p><p>缺点：erlang开发，源码比较难理解，基本职能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护。RabbitMQ吞吐量会低一些，因为其实现机制比较重。  需要学习<strong>比较复杂的接口和协议</strong>，学习和维护成本较高。</p><p><font style="color:yellow">①：AMQP，<strong>高级消息队列协议</strong>（Advanced Message Queue）。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</font></p></li></ol><h2 id="rabbitmq"><a class="markdownIt-Anchor" href="#rabbitmq"></a> #RabbitMQ</h2><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在<strong>易用性、扩展性、高可用性</strong>等方面表现不俗。</p><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><ul><li><strong>可靠性</strong>（Reliability）：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li><li><strong>消息集群</strong>（Clustering）：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li><li><strong>高可用</strong>（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li><li>灵活的路由（Flexible Routing）：在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li><li>多种协议（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li><li>管理界面（Management UI）:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li><li>跟踪机制（Tracing）:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li><li>插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li></ul><h3 id="rabbitmq架构"><a class="markdownIt-Anchor" href="#rabbitmq架构"></a> RabbitMQ架构</h3><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/RabbitMQ%E6%9E%B6%E6%9E%84.png" alt="RabbitMQ架构" /></p><ul><li><p><strong>Message</strong>：是服务器与应用程序之间传递的数据，由**消息头(Properties)和消息体(Body)**组成.。</p><p>消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 <code>routing-key</code>（路由键）、<code>priority</code>（相对于其他消息的优先权）、<code>delivery-mode</code>（指出该消息可能需要持久性存储）等。</p></li><li><p><strong>Publisher</strong>：消息的生产者，也是一个<strong>向交换器发布消息</strong>的客户端应用程序。</p></li><li><p><strong>Connection</strong>：网络连接，比如一个 <code>TCP</code> 连接。</p></li><li><p><strong>Channel</strong>：信道，多路复用连接中的一条独立的<strong>双向数据流</strong>通道。</p><p>信道是建立在真实的 <code>TCP</code> 连接内地虚拟连接，<code>AMQP</code> 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。<font style="color:#00FFFF">因为对于操作系统来说建立和销毁 <code>TCP</code>都是非常昂贵的开销，所以引入了信道的概念，以<strong>复用</strong>一条 <code>TCP</code> 连接。</font></p></li><li><p><strong>Broker</strong>：表示消息队列服务器<strong>实体</strong>。</p></li><li><p><strong>Virtual Host</strong>：虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是<strong>共享</strong>相同的身份认证和加密环境的<strong>独立服务器域</strong>。</p></li><li><p><strong>Exchange</strong>：交换器，用来<strong>接收</strong>生产者发送的消息并将这些消息路由给服务器中的队列。</p></li><li><p><strong>Binding</strong>：绑定，用于消息队列和交换器之间的<strong>关联</strong>。</p><p>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的<strong>路由表</strong>。</p></li><li><p><strong>Queue</strong>：队列，是RabbitMQ的内部对象，用于存储消息消息的<strong>容器</strong>，也是消息的终点。一个消息可投入<strong>一个或多个</strong>队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p></li><li><p><strong>Consumer</strong>：消息的消费者，表示一个从消息队列中取得消息的<strong>客户端应用程序</strong>。</p></li></ul><h3 id="rabbitmq安装"><a class="markdownIt-Anchor" href="#rabbitmq安装"></a> RabbitMQ安装</h3><h4 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h4><ul><li><p>安装<code>ErLang</code>语言</p><ol><li><p>ErLang官网下载安装包：<a href="https://www.erlang.org/downloads%EF%BC%8C%E5%AE%89%E8%A3%85%E6%97%B6%E5%85%A8%E9%83%A8%E9%BB%98%E8%AE%A4%E4%B8%8B%E4%B8%80%E6%AD%A5%EF%BC%9B">https://www.erlang.org/downloads，安装时全部默认下一步；</a></p></li><li><p>配置环境变量：</p><p>ERLANG_HOME erlang安装目录</p><p>Path %ERLANG_HOME%\bin</p></li><li><p>验证安装</p></li></ol></li><li><p>安装<code>RabbitMQ</code></p><ol><li><p>在<code>RabbitMQ</code>官方安装地址中下载安装包：<a href="https://www.rabbitmq.com/download.html%EF%BC%8C%E5%AE%89%E8%A3%85%E6%97%B6%E5%85%A8%E9%83%A8%E9%BB%98%E8%AE%A4%E4%B8%8B%E4%B8%80%E6%AD%A5%EF%BC%9B">https://www.rabbitmq.com/download.html，安装时全部默认下一步；</a></p></li><li><p>在<code>RabbitMQ</code>安装目录下的<code>sbin</code>文件夹中打开<code>cmd</code>输入如下命令安装管理页面插件：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></div></td></tr></table></figure></li><li><p>然后执行<code>rabbitmq-server.bat</code>启动脚本，可在windows服务中查看<code>RabbitMQ</code>服务正在运行，</p><p>在浏览器输入http://localhost:15672访问<code>RabbitMQ</code>管理页面，默认初始账号密码：guest/guest</p></li></ol></li></ul><h4 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h4><h3 id="rabbitmq使用示例"><a class="markdownIt-Anchor" href="#rabbitmq使用示例"></a> RabbitMQ使用示例</h3>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>AMQP</tag>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/helloworld/notes/%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/Docker/"/>
    <url>/helloworld/notes/%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/Docker/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><a href="https://blog.kyire.site/2021/12/12/e33c148b.html">Docker容器-基础</a></li><li><a href="https://www.pdai.tech/md/devops/docker/docker-00-overview.html">容器化-Docker</a></li><li><a href="https://www.runoob.com/docker/docker-tutorial.html">Docker教程</a></li><li><a href="https://docs.docker.com/engine/">Docker官方文档</a></li></ul><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> #介绍</h2><p>  Docker 是一个开源的应用容器引擎，基于<font style="color:yellow">Go语言<sup>1</sup></font>并遵循<code>Apache2.0</code>协议开源。<font style="color:red">Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的<code>Linux</code>机器上</font>，也可以实现<font style="color:yellow">虚拟化<sup>2</sup></font>。<br />  <strong>容器是完全使用沙箱机制</strong>，相互之间不会有任何接口（类似 iPhone 的 app）,<font style="color:red">更重要的是容器性能开销极低。</font></p><p><font style="color:yellow">①：又称Golang，是Google开发的一种静态强类型、编译型语言。</font><br /><font style="color:yellow">②：虚拟化（Virtualization）是一种<strong>资源管理技术</strong>。它是将计算机的各种实体资源，如：服务器、网络、内存等，予以抽象、转换后呈现出来，<strong>打破实体结构间的不可切割的障碍，使用户可以用更好的方式来利用这些资源</strong>。<strong>目的是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，并带来降低成本、方便管理和容错容灾等好处。</strong></font></p><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li><p>简化配置</p><p>这是Docker公司宣传的<strong>Docker的主要使用场景</strong>。<font style="color:red">虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），<strong>Docker在降低额外开销的情况下提供了同样的功能</strong>。</font>它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。</p></li><li><p>提高开发效率</p><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。Docker非常适合**持续集成和持续交付(CI/CD)**工作流程</p></li><li><p>快速部署</p><p>Docker 是基于容器的平台，允许<strong>高度可移植的工作负载</strong>。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。Docker 的<strong>可移植性和轻量级的特性</strong>，还可以轻松地完成动态管理的工作负担，并根据业务需求指示，<strong>实时扩展或拆除应用程序和服务</strong>。</p></li><li><p>隔离应用</p></li></ul><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><ul><li><strong><code>Web</code>应用的自动化打包和发布</strong>。</li><li><strong>自动化测试和持续集成、发布</strong>。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的<code>OpenShift</code>或<code>Cloud Foundry</code>平台来搭建自己的 <code>PaaS</code> 环境。</li></ul><h2 id="docker架构"><a class="markdownIt-Anchor" href="#docker架构"></a> #Docker架构</h2><p>Docker 使用<strong>客户端-服务器 (C/S) 架构模式</strong>，使用远程<code>API</code>来管理和创建Docker容器。<br />Docker包括三个基础概念：</p><ul><li><strong>镜像(Image)</strong>：Docker 镜像（Image）</li><li><strong>容器(Container)</strong>：<font style="color:#00FFFF">镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</font><font style="color:red">Docker 容器通过 Docker 镜像来创建。</font></li><li><strong>仓库(Repository)</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul><p>Docker图示：<img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/docker%E6%9E%B6%E6%9E%84.svg" alt="docker架构" /></p><table><thead><tr><th style="text-align:left">概念</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Docker 镜像(Images)</td><td style="text-align:left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td style="text-align:left">Docker 容器(Container)</td><td style="text-align:left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td style="text-align:left">Docker 客户端(Client)</td><td style="text-align:left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td></tr><tr><td style="text-align:left">Docker 主机(Host)</td><td style="text-align:left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td style="text-align:left">Docker Registry</td><td style="text-align:left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td></tr><tr><td style="text-align:left">Docker Machine</td><td style="text-align:left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr></tbody></table><h2 id="安装docker"><a class="markdownIt-Anchor" href="#安装docker"></a> #安装Docker</h2><p><a href="https://docs.docker.com/engine/install/">Docker engine</a>构成的组件：Docker 客户端(Docker Client)、Docker 守护进程(<code>Docker daemon</code>)、<code>containerd</code>以及<code>runc</code>，它们共同负责容器的创建和运行。</p><p>Docker官方手册将介绍了所有平台的安装：<a href="https://docs.docker.com/desktop/%EF%BC%8C%E6%9C%AC%E6%96%87%E5%8F%AA%E6%BC%94%E7%A4%BA">https://docs.docker.com/desktop/，本文只演示</a><code>CentOS</code></p><h3 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h3><p>CentOS7操作系统服务器，或者使用虚拟机，虚拟机推荐使用 微软的<a href="https://learn.microsoft.com/zh-cn/windows-server/virtualization/hyper-v/hyper-v-on-windows-server"><code>hyper-v</code></a>或是 Oracle的<a href="https://www.virtualbox.org/"><code>VirtualBox</code></a><br />镜像下载站：</p><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></li><li><a href="https://mirrors.aliyun.com/">https://mirrors.aliyun.com/</a></li></ul><h3 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h3><ol><li><p>卸载旧版本，主要是确保对于已经安装过Docker的机器安装最新的Docker。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo yum remove  docker <br>                 docker-client \<br>                 docker-client-latest \<br>                 docker-common \<br>                 docker-latest \<br>                 docker-latest-logrotate \<br>                 docker-logrotate \<br>                 docker-engine<br></code></pre></div></td></tr></table></figure></li><li><p>安装所需的依赖库，<code>yum-utils</code> 提供了 <code>yum-config-manager</code>，并且 <code>device mapper</code> 存储驱动程序需要 <code>device-mapper-persistent-data</code> 和 <code>lvm2</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo yum install -y yum-utils \<br>    device-mapper-persistent-data \<br>    lvm2<br></code></pre></div></td></tr></table></figure></li><li><p>设置仓库，新主机上首次安装 <code>Docker Engine-Community</code> 之前，需要设置 Docker 仓库，使用以下命令设置稳定的Docker仓库：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo yum-config-manager \<br>    --add-repo \<br>    https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></div></td></tr></table></figure><p><font style="color:red">在国内，官方源地址会比较慢，<strong>推荐使用国内的源地址</strong></font>：</p><ul><li>阿里云：<a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></li><li>清华大学：<a href="https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo">https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</a></li></ul></li><li><p>安装Docker Engine-Community，安装docker相关的 <code>docker-ce</code>、<code>containerd</code>和<code>docker-compose</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></div></td></tr></table></figure><p>该命令安装默认为最新版，也可以安装指定版本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出并排序您存储库中可用的版本，按版本号（从高到低）对结果进行排序</span><br>yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r<br><br>docker-ce.x86_64  3:19.03.14-3.el7                      docker-ce-stable<br>docker-ce.x86_64  3:19.03.1-3.el7                       docker-ce-stable<br>docker-ce.x86_64  3:19.03.13-3.el7                      docker-ce-stable<br>docker-ce.x86_64  3:19.03.12-3.el7                      docker-ce-stable<br>...<br><br><span class="hljs-comment"># 在根据列出的版本名称</span><br>sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin<br><span class="hljs-comment"># 示例</span><br>sudo yum install docker-ce-19.03.14 docker-ce-cli-19.03.14 containerd.io docker-compose-plugin<br></code></pre></div></td></tr></table></figure></li><li><p>启动docker</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">systemctl start docker<br></code></pre></div></td></tr></table></figure></li><li><p>验证安装</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker version<br></code></pre></div></td></tr></table></figure><p>也可以使用<code>docker run hello-world</code>命令验证安装：</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Docker-run%20hello-world.png" alt="Docker-run hello-world" /></p></li></ol><h3 id="docker镜像加速"><a class="markdownIt-Anchor" href="#docker镜像加速"></a> Docker镜像加速</h3><p>国内从 <code>DockerHub</code> 拉取镜像有时会遇到困难，此时可以配置镜像加速器。<code>Docker</code> 官方和国内很多云服务商都提供了国内加速器服务：</p><ul><li>阿里云的加速器：<a href="https://help.aliyun.com/document_detail/60750.html">https://help.aliyun.com/document_detail/60750.html</a></li><li>网易加速器：<a href="http://hub-mirror.c.163.com">http://hub-mirror.c.163.com</a></li><li>Docker官方中国加速器：<a href="https://registry.docker-cn.com">https://registry.docker-cn.com</a></li></ul><p>对于使用 <font style="color:yellow"><code>systemd</code><sup>3</sup></font> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br></code></pre></div></td></tr></table></figure><p>之后再重启服务</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></div></td></tr></table></figure><p><font style="color:yellow">③：<code>systemd</code>是linux下的一种init软件，是linux系统操作中不可缺少的程序之一。现在广泛用于Fedora 21、Ubuntu（Ubuntu 15.04以上）、Centos等linux操作系统上</font></p><h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> #常用命令</h2><h3 id="帮助命令"><a class="markdownIt-Anchor" href="#帮助命令"></a> 帮助命令</h3><ul><li><code>docker version</code>，显示docker的版本信息</li><li><code>docker info</code>，显示docker的系统信息，包括镜像和容器</li><li><code>docker --help</code>，列出docker所有命令，使用<code>docker [命令] --help</code>可以查看该命令的参数和描述，示例：<code>docker version --help</code></li></ul><h3 id="镜像命令"><a class="markdownIt-Anchor" href="#镜像命令"></a> 镜像命令</h3><ul><li><p><code>docker images</code>，列出本机所有镜像</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker images<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>hello-world         latest              fce289e99eb9        13 months ago       13.3kB<br></code></pre></div></td></tr></table></figure><p>本机镜像列表表头说明：</p><table><thead><tr><th>表头</th><th>说明</th></tr></thead><tbody><tr><td>REPOSITORY</td><td>表示镜像的仓库源</td></tr><tr><td>TAG</td><td>镜像的标签, 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本</td></tr><tr><td>IMAGE ID</td><td>镜像ID</td></tr><tr><td>CREATED</td><td>镜像创建时间</td></tr><tr><td>SIZE</td><td>镜像大小</td></tr></tbody></table></li><li><p><code>docker search</code>，搜索镜像</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker search mysql --<span class="hljs-built_in">limit</span> 5<br>NAME           DESCRIPTION                                STARS   OFFICIAL  AUTOMATED<br>mysql          MySQL is a widely used, open-source rel…   13234   [OK]<br>mariadb        MariaDB Server is a high performing ope…   5062    [OK]<br>phpmyadmin     phpMyAdmin - A web interface <span class="hljs-keyword">for</span> MySQL …   640     [OK]<br>percona        Percona Server is a fork of the MySQL r…   588               [OK]<br>bitnami/mysql  Bitnami MySQL Docker Image                 77<br></code></pre></div></td></tr></table></figure><p>搜索镜像列表表头说明：</p><table><thead><tr><th>表头</th><th>说明</th></tr></thead><tbody><tr><td>NAME</td><td>镜像仓库源的名称</td></tr><tr><td>DESCRIPTION</td><td>镜像的描述</td></tr><tr><td>STARS</td><td>类似 Github 里面的 star，表示点赞、喜欢的意思</td></tr><tr><td>OFFICIAL</td><td>是否 docker 官方发布</td></tr><tr><td>AUTOMATED</td><td>自动构建</td></tr></tbody></table><p><code>docker search</code>常用参数说明：</p><blockquote><p><code>--filter filter</code>， <code>--filter</code> 参数可以设定过滤条件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker search mysql --filter <span class="hljs-string">&quot;is-official=true&quot;</span><br>docker search mysql --filter=stars=50<br></code></pre></div></td></tr></table></figure><table><thead><tr><th>过滤条件</th><th>值类型</th><th>描述</th></tr></thead><tbody><tr><td><code>stars</code></td><td><code>int</code></td><td>镜像具有的<code>star</code>数量</td></tr><tr><td><code>is-automated</code></td><td><code>boolean</code></td><td>镜像是否自动构建</td></tr><tr><td><code>is-official</code></td><td><code>boolean</code></td><td>是否为官方镜像</td></tr></tbody></table><p><code>--limit int</code>，设定搜索返回的最大结果数。默认是<code>--limit 25</code></p><p><code>--formart string</code>，使用<code>Go</code>模板格式化搜索结果输出</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">docker search --format <span class="hljs-string">&quot;&#123;&#123;.Name&#125;&#125;:&#123;&#123;.Description&#125;&#125;&quot;</span><br></code></pre></div></td></tr></table></figure><p>Go模板占位符示例：</p><table><thead><tr><th>占位符</th><th>描述</th></tr></thead><tbody><tr><td><code>.Name</code></td><td>镜像名称</td></tr><tr><td><code>.Description</code></td><td>镜像描述</td></tr><tr><td><code>.StarCount</code></td><td>镜像的<code>stars</code>数量</td></tr><tr><td><code>.IsOfficial</code></td><td>显示<code>&quot;OK&quot;</code>，则镜像是官方的</td></tr><tr><td><code>.IsAutomated</code></td><td>显示<code>&quot;OK&quot;</code>，则镜像的构建是自动的</td></tr></tbody></table></blockquote></li><li><p><code>docker pull</code>，拉取镜像，<code>docker pull &lt;镜像名&gt;</code></p></li><li><p><code>docker rmi</code>，删除镜像，<code>docker rmi &lt;镜像名&gt;</code></p></li><li><p><code>apt-get update</code>，更新镜像</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 更新镜像之前，我们需要使用运行一个容器</span><br>docker run -t -i ubuntu:15.10<br><span class="hljs-comment"># 然后在运行的容器内进行apt-get update更新</span><br>apt-get update<br></code></pre></div></td></tr></table></figure></li><li><p><code>docker build</code>，生成镜像</p><p>创建镜像时，我们需要先创建一个<code>Dockerfile</code>文件，示例：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">FROM centos<br>MAINTAINER C1thulhu&lt;the.blade.of.sin@gmail.com&gt;<br>RUN yum -y install vi<br>RUN yum -y install net-tools<br></code></pre></div></td></tr></table></figure><p>Dockerfile保留字指令：</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>FROM</td><td>基础镜像，指定一个已经存在的镜像作为模板，必须以 FROM 开头</td></tr><tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr><td>RUN</td><td>容器构建时需要运行的命令，包含两种格式<code>shell</code>和<code>exec</code></td></tr><tr><td>EXPOSE</td><td>当前容器对外暴露出的端口</td></tr><tr><td>WORKDIR</td><td>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</td></tr><tr><td>USER</td><td>指定该镜像以什么样的用户去执行，如果都不指定，默认是 root</td></tr><tr><td>ENV</td><td>用来在构建镜像过程中设置环境变量</td></tr><tr><td>VOLUME</td><td>容器数据卷，用于数据保存和持久化工作</td></tr><tr><td>CMD</td><td>指定容器启动后的要干的事情</td></tr><tr><td>ENTRYPOINT</td><td>也是用来指定一个容器启动时要运行的命令</td></tr></tbody></table><p><code>Dockerfile</code>中开头<code>#</code>开头为注释，<code>\</code>为换行符(注释中换行符无效)，<font style="color:red">每一条指令都会在镜像中创建一个新的层</font>，所以执行多个<code>RUN</code>时可以通过<code>\</code>换行接<code>&amp;&amp;</code>：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">RUN yum -y install wget \<br>    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \<br>    &amp;&amp; tar -xvf redis.tar.gz<br></code></pre></div></td></tr></table></figure></li><li><p>镜像的导入与导出</p><p>导入：</p><p><code>docker save</code>，</p><p>导出：</p><p><code>docker load</code>，</p></li></ul><h3 id="容器命令"><a class="markdownIt-Anchor" href="#容器命令"></a> 容器命令</h3><ul><li><code>docker run [可选参数] image</code>，新建容器并启动</li><li><code>docker ps -a</code>，查看容器</li><li><code>docker stop</code>，容器停止与重启</li></ul><h3 id="其他常用命令"><a class="markdownIt-Anchor" href="#其他常用命令"></a> 其他常用命令</h3>]]></content>
    
    
    <categories>
      
      <category>部署工具</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署工具</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/helloworld/notes/Java/Spring/SpringBoot/"/>
    <url>/helloworld/notes/Java/Spring/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><a href="https://www.pdai.tech/md/spring/springboot/springboot.html">SpringBoot详解</a></li><li><a href="https://blog.csdn.net/weixin_42039228/article/details/124740925">@ConfigurationProperties使用详解</a></li><li><a href="https://www.cnblogs.com/Fooo/p/11724709.html">@RequestMapping详解</a></li><li><a href="https://blog.csdn.net/qq_43842093/article/details/121175080">@RequestParam详解</a></li><li><a href="https://blog.csdn.net/u013257679/article/details/52295106/">@Autowired详解</a></li></ul><h2 id="springboot介绍"><a class="markdownIt-Anchor" href="#springboot介绍"></a> #SpringBoot介绍</h2><p>  虽然Spring的组件代码是轻量级的，但它的配置却是重量级，除此之外，项目的依赖管理也是一件耗时耗力的事情。一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。<br />  而SpringBoot对上述Spring的缺点进行的改善和优化，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，从而大大提高了开发的效率。<font style="color:red">SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式。</font></p><h2 id="常用注解"><a class="markdownIt-Anchor" href="#常用注解"></a> #常用注解</h2><ul><li><p>@SpringBootApplication，定义在main方法入口类处，用于启动Spring boot项目</p></li><li><p>@SpringBootConfiguration</p></li><li><p>@EnableAutoConfiguration，让Spring boot根据类路径中的jar包依赖当前项目进行自动配置</p></li><li><p>@ImportResource，加载xml配置，一般是放在启动main类上</p></li><li><p>@Value，application.properties定义属性，直接使用@Value注入即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br> <span class="hljs-meta">@Value(&quot;$&#123;push.start:0&#125;&quot;)</span>    如果缺失，默认值为<span class="hljs-number">0</span><br>     <span class="hljs-keyword">private</span> Long  id;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>@ConfigurationProperties(prefix=“person”)，主要用来把<code>properties</code>配置文件转化为<code>bean</code>来使用的，该注解有三种使用场景：</p><ol><li><p><code>@ConfigurationProperties</code>和<code>@Component</code>注解到<code>bean</code>定义类上，这里<code>@Component</code>代指同一类实例化<code>Bean</code>的注解；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;user1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-comment">// 省略getter/setter方法</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>使用<code>@ConfigurationProperties</code>和<code>@Bean</code>注解在配置类的<code>Bean</code>定义方法上，以数据源配置为例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceConfig</span> &#123;<br><br><span class="hljs-meta">@Primary</span><br><span class="hljs-meta">@Bean(name = &quot;primaryDataSource&quot;)</span><br><span class="hljs-meta">@ConfigurationProperties(prefix=&quot;spring.datasource.primary&quot;)</span><br><span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">primaryDataSource</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> DataSourceBuilder.create().build();<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>使用@ConfigurationProperties注解到普通类，然后再通过@EnableConfigurationProperties定义为Bean。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;user1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-comment">// 省略getter/setter方法</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里User对象并没有使用@Component相关注解。</p><p>而该User类对应的使用形式如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;User.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码中，通过<code>@EnableConfigurationProperties</code>对<code>User</code>进行实例化时，便会使用到<code>@ConfigurationProperties</code>的功能，对属性进行匹配赋值。</p></li></ol></li><li><p>@EnableConfigurationProperties()，<code>@EnableConfigurationProperties</code>的作用是把<code>springboot</code>配置文件中的值与我们的<code>xxxProperties.java</code>的属性进行绑定，需要配合<code>@ConfigurationProperties</code>使用。</p></li><li><p>@RequestMapping(&quot;/api2/copper&quot;)，用来映射web请求(访问路径和参数)、处理类和方法，可以注解在类或方法上。<font style="color:red"><strong>注解在方法上的路径会继承注解在类上的路径</strong></font>。</p><p><font style="color:#00FFFF">参数：</font></p><ul><li><font style="color:#00FFFF">value：请求的实际地址，指定的地址可以是URI Template 模式；</font></li><li><font style="color:#00FFFF">method：请求的method类型， GET、POST、PUT、DELETE等；</font></li><li><font style="color:#00FFFF">consumes： 处理请求的提交内容类型（Content-Type），例如application/json, text/html；</font></li><li><font style="color:#00FFFF">produces: 定制返回的response的媒体类型和字符集，或需返回值是json对象；</font></li><li><font style="color:#00FFFF">params：request中必须包含某些参数值时，才让该方法处理；</font></li><li><font style="color:#00FFFF">headers：request中必须包含某些指定的header值，才能让该方法处理请求。</font></li></ul></li><li><p>@RequestParam()，<font style="color:red">获取request请求的参数值映射到控制层方法的参数上。</font></p><p><font style="color:#00FFFF">参数：</font></p><ul><li><font style="color:#00FFFF">value，请求中传入参数的名称，如果不设置后台接口的value值，则会默认为该变量名；</font></li><li><font style="color:#00FFFF">defaultValue，参数默认值，如果请求中没有同名的参数时，该变量默认为此值。(可以使用SpEL表达式)；</font></li><li><font style="color:#00FFFF">required，该参数是否为必传项，默认是true，表示请求中一定要传入对应的参数，<strong>否则会报404错误</strong>。设置为false时，值为null，对于基本数据变量，需要使用包装类来声明。</font></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;CopperVO&gt; <span class="hljs-title function_">getOpList</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">             <span class="hljs-meta">@RequestParam(value = &quot;pageIndex&quot;, required = false)</span> Integer pageIndex,</span><br><span class="hljs-params">                                <span class="hljs-meta">@RequestParam(value = &quot;pageSize&quot;, required = false)</span> Integer pageSize)</span> &#123;<br> <br>  &#125;<br></code></pre></div></td></tr></table></figure></li><li><p>@ResponseBody()，将返回值对象转为json格式或者xml格式的数据，比如Ajax接口。</p></li><li><p>@Bean()，表示方法产生一个由Spring管理的bean，属性的名称语义与Spring xml配置文件中的标签配置的一样</p><p><font style="color:#00FFFF">参数：</font></p><ul><li><font style="color:#00FFFF">value，用来修改被标注bean在IOC容器中的id属性；</font></li><li><font style="color:#00FFFF">name ，用来修改被标注bean在IOC容器中的id属性；</font></li><li><font style="color:#00FFFF">initMethod ，指定初始化方法。</font></li></ul></li><li><p>@Service()，标注业务层组件。</p></li><li><p>@Controller()，标注控制层组件(如struts中的action)。</p></li><li><p>@RestController()，组合@Controller和@ResponseBody。</p></li><li><p>@Repository()，标注数据访问组件，即DAO组件。</p></li><li><p>@Component()，泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p></li><li><p>@PostConstruct()，<strong>Java自带的注解</strong>，在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法。</p></li><li><p>@PathVariable()，只支持一个属性value，类型是为String，代表绑定的属性名称。默认不传递时，绑定为同名的形参。用来获得请求url中的动态参数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>     <span class="hljs-meta">@RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET)</span>  <br>     <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLogin</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> String userId,  </span><br><span class="hljs-params">         <span class="hljs-meta">@PathVariable(&quot;roleId&quot;)</span> String roleId)</span>&#123;<br>           <br>         System.out.println(<span class="hljs-string">&quot;User Id : &quot;</span> + userId);  <br>         System.out.println(<span class="hljs-string">&quot;Role Id : &quot;</span> + roleId);  <br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;  <br>     <br>     &#125;  <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>@ComponentScan()，注解会告知Spring扫描指定的包来初始化Spring</p></li><li><p>@Autowired()，可以对成员变量、方法和构造函数进行标注，来完成自动装配的工作，@Autowired标注可以放在<strong>成员变量</strong>上，也可以放在<strong>成员变量的set方法</strong>上，也可以放在<strong>任意方法</strong>上表示，自动执行当前方法，如果方法有参数，会在IOC容器中自动寻找同类型参数为其传值。</p><p>@Autowired等同于Spring配置<code>default-autowire</code>都是主要用于Spring的IOC的依赖注入。</p><p>四种模式：</p><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">no</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">byName</td><td style="text-align:center">根据属性名自动装配。此选项将检查容器并根据名字查找与属性完全一致的Bean，并将其属性自动装配</td></tr><tr><td style="text-align:center">byType</td><td style="text-align:center">如果容器中存在与指定属性类型相同的bean，将自动装配该属性。如果存在多个该类型bean，就会抛出异常。若没有相匹配的bean，则无事发生<font style="color:#00FFFF">(可以通过设置<code>dependency-check=&quot;objects&quot;</code>让Spring抛出异常)</font>。</td></tr><tr><td style="text-align:center">constructor</td><td style="text-align:center">与<code>byType</code>类似，区别在于它应用于构造器参数，如果没找到与构造器参数类型一致的bean，则抛出异常</td></tr><tr><td style="text-align:center">autodetect</td><td style="text-align:center">通过bean类的自省机制(introspection)来决定使用<code>constructor</code>还是<code>byType</code>。如果发现默认的构造器，则使用<code>byType</code>的方式</td></tr></tbody></table></li><li><p>@Configuration()，用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被<code>AnnotationConfigApplicationContext</code>或<code>AnnotationConfigWebApplicationContext</code>类进行扫描，并用于构建bean定义，初始化Spring容器。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(&quot;name&quot;)</span><span class="hljs-comment">//表示这是一个配置信息类,可以给这个配置类也起一个名称</span><br><span class="hljs-meta">@ComponentScan(&quot;spring4&quot;)</span><span class="hljs-comment">//类似于xml中的&lt;context:component-scan base-package=&quot;spring4&quot;/&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><span class="hljs-comment">//自动注入，如果容器中有多个符合的bean时，需要进一步明确</span><br>    <span class="hljs-meta">@Qualifier(&quot;compent&quot;)</span><span class="hljs-comment">//进一步指明注入bean名称为compent的bean</span><br>    <span class="hljs-keyword">private</span> Compent compent;<br><br>    <span class="hljs-meta">@Bean</span><span class="hljs-comment">//类似于xml中的&lt;bean id=&quot;newbean&quot; class=&quot;spring4.Compent&quot;/&gt;</span><br>    <span class="hljs-keyword">public</span> Compent <span class="hljs-title function_">newbean</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compent</span>();<br>    &#125;   <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>@Order()，参数值越小优先级超高，越先运行</p></li><li><p>… 本文介绍的注解很局限，实际对注解的运用还需具体问题具体分析。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/helloworld/notes/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/"/>
    <url>/helloworld/notes/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><a href="https://www.pdai.tech/md/devops/tool/tool-maven.html">Maven项目构建</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200">廖雪峰：Maven基础</a></li><li><a href="http://mvnbook.com/index.html">Mybatis中文网：Maven教程</a></li><li><a href="https://www.runoob.com/maven/maven-tutorial.html">菜鸟教程：Maven教程</a></li></ul><h2 id="maven介绍"><a class="markdownIt-Anchor" href="#maven介绍"></a> #Maven介绍</h2><p>  每个项目工程在开发时，我们需要<font style="color:red"><strong>确定引入哪些依赖包</strong></font>，比如我们需要用到<code>commons logging</code>、<code>log4j</code>等，我们就必须把这些jar包放入<code>classpath</code>。同时每个项目工程都有非常<font style="color:red"><strong>繁琐的目录结构</strong></font>，每个目录都有不同的作用，比如<code>src</code>目录存放Java源码，<code>resources</code>目录存放配置文件等，此外还需要<font style="color:red"><strong>配置环境</strong></font>。而且还必须能<font style="color:red"><strong>通过命令行工具进行编译</strong></font>，才能够让项目在一个独立的服务器上编译、测试、部署。</p><p>这些工作难度不大，但是非常琐碎且耗时。我们需要的是一个标准化的Java项目管理和构建工具，而Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有：</p><ul><li>提供了一套标准化的项目结构；</li><li>提供了一套依赖管理机制；</li><li>提供了一套标准化的构建流程（编译，测试，打包……）。</li></ul><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><p>Maven 官方下载地址：<a href="http://maven.apache.org/download.cgi%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E5%90%8E%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%A7%A3%E5%8E%8B%E5%8D%B3%E5%8F%AF%E3%80%82%E6%88%91%E4%BB%AC%E8%BF%98%E9%9C%80%E8%A6%81%E7%BB%99Maven%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%BA%E4%BA%86%E5%9C%A8">http://maven.apache.org/download.cgi，下载完后，直接解压即可。我们还需要给Maven配置环境变量，环境变量是为了在</a><code>cmd</code>中能执行Maven命令：</p><ol><li><p>新建Maven环境变量MAVEN_HOME</p><p>变量名：MAVEN_HOME</p><p>变量值：D:\Workspace\apache-maven-3.8.5 <font style="color:#00FFFF">(Maven安装路径)</font></p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Maven%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE_1.png" alt="Maven环境配置_1" /></p></li><li><p>编辑Path变量，新增：%MAVEN_HOME%\bin</p><p>变量名：Path</p><p>变量值：%MAVEN_HOME%\bin</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Maven%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE_2.png" alt="Maven环境配置_2" /></p></li><li><p>当项目比较大时，使用的Maven生成项目需要占用大量内存，如果超过Java默认最大可用内存，则会报<code>java.lang.OutOfMemeoryError</code>错误。为此我们可以设置MAVEN_OPTS环境变量为Maven分配内存大小。</p><p>变量名：MAVEN_OPTS</p><p>变量值：-Xms128m -Xmx512m <font style="color:#00FFFF">(Xms为初始内存，即最小内存，Xmx为最大内存)</font></p></li><li><p>验证：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">C:\Users\think&gt; mvn -v<br>Apache Maven 3.8.6 (84538c9988a25aec085021c365c560670ad80f63)<br>Maven home: E:\Workspace\apache-maven-3.8.6<br>Java version: 1.8.0_171, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk1.8.0_171\jre<br>Default locale: zh_CN, platform encoding: GBK<br>OS name: <span class="hljs-string">&quot;windows 10&quot;</span>, version: <span class="hljs-string">&quot;10.0&quot;</span>, <span class="hljs-built_in">arch</span>: <span class="hljs-string">&quot;amd64&quot;</span>, family: <span class="hljs-string">&quot;windows&quot;</span><br></code></pre></div></td></tr></table></figure></li></ol><h2 id="maven项目目录结构"><a class="markdownIt-Anchor" href="#maven项目目录结构"></a> #Maven项目目录结构</h2><p>使用Maven的普通Java项目的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asci">project<br>├── src<br>│   ├── main<br>│   │   ├── java<br>│   │   └── resources<br>│   └── test<br>│       ├── java<br>│       └── resources<br>├── pom.xml<br>└── target<br></code></pre></div></td></tr></table></figure><p>根目录是项目名<code>project</code>，<code>src/main/java</code>存放Java源码，<code>src/main/resources</code>存放资源文件；<code>src/test/java</code>存放测试源码，<code>src/test/resources</code>存放测试资源文件，项目描述文件<code>pom.xml</code>，<code>target</code>存放所有编译、打包生成的文件。</p><p>其中最关键的是项目描述文件<code>pom.xml</code>，它的内容类似于如下格式：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>在Maven中任何项目输出都可以成为构件(包括项目本身)，<font style="color:red">每个构件都有自己的<strong>唯一坐标</strong></font>，由<code>groupId</code>，<code>artifactId</code> 和 <code>version</code> 等信息构成：</p><ul><li><code>groupId</code>：<strong>当前Maven构件隶属的组织名</strong>。<font style="color:red">(必填)</font><font style = "color:#00FFFF"><code>groupId</code>一般分为多段，通常情况下，第一段为域，第二段为公司名称。域又分为 org、com、cn 等，其中 org 为非营利组织，com 为商业组织，cn 表示中国。以 apache 开源社区的 tomcat 项目为例，这个项目的 groupId 是 org.apache，它的域是org（因为tomcat是非营利项目），公司名称是apache，artifactId是tomcat。</font></li><li><code>artifactId</code>：<strong>项目的唯一的标识符</strong>，实际对应项目的名称，就是项目根目录的名称。<font style="color:red">(必填)</font></li><li><code>version</code>：<strong>当前版本</strong>。<font style="color:red">(必填)</font></li><li><code>packaging</code>：<strong>打包方式</strong>，比如 jar，war… <font style="color:red">(必填)</font></li><li><code>classifier</code>：<strong>classifier通常用于区分从同一POM构建的具有不同内容的构件。它是可选的</strong>，它可以是任意的字符串，附加在版本号之后。</li></ul><h2 id="依赖管理"><a class="markdownIt-Anchor" href="#依赖管理"></a> #依赖管理</h2><p>  我们的项目依赖第三方的jar包，如JUnit，JavaMail，MySQL驱动等等。过去采用通过搜索引擎搜索到项目的官网，然后手动下载zip包，解压，再放入classpath，这个过程非常繁琐。</p><p>而Maven解决了依赖管理的问题，例如A包依赖B包，当我们在Maven中声明A包作为依赖时，Maven会自动导入A包，并将其依赖的B包也导入。如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。</p><h3 id="依赖关系"><a class="markdownIt-Anchor" href="#依赖关系"></a> 依赖关系</h3><p>Maven定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：</p><table><thead><tr><th style="text-align:center">scope</th><th style="text-align:left">说明</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">compile</td><td style="text-align:left">编译时需要用到该jar包<font style = "color:#00FFFF">（默认）</font></td><td style="text-align:center">commons-logging</td></tr><tr><td style="text-align:center">test</td><td style="text-align:left">编译Test时需要用到该jar包</td><td style="text-align:center">junit</td></tr><tr><td style="text-align:center">runtime</td><td style="text-align:left">编译时不需要，但运行时需要用到</td><td style="text-align:center">mysql</td></tr><tr><td style="text-align:center">provided</td><td style="text-align:left">编译时需要用到，但运行时由JDK或某个服务器提供</td><td style="text-align:center">servlet-api</td></tr></tbody></table><ul><li><p>默认的<code>compile</code>是最常用的，Maven会把这种类型的依赖直接放入classpath</p></li><li><p><code>test</code>依赖表示仅在测试时使用，正常运行时并不需要。最常用的<code>test</code>依赖就是JUnit：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>runtime</code>依赖表示编译时不需要，但运行时需要。最典型的<code>runtime</code>依赖是JDBC驱动，例如MySQL驱动：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>provided</code>依赖表示时需要，但运行时不需要。最典型的<code>provided</code>依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><p>对于某个依赖，Maven需要<code>groupId</code>，<code>artifactId</code> 和 <code>version</code>3个变量才能确定唯一的jar包。</p><h3 id="仓库"><a class="markdownIt-Anchor" href="#仓库"></a> 仓库</h3><p>在Maven安装目录下，找到<code>/lib/maven-model-builder-$&#123;version&#125;.jar</code>这个jar包，在这个jar包中可以找到超级POM文件：<code>\org\apache\maven\model\pom-4.0.0.xml</code>，它是所有Maven POM的父POM，所有Maven项目继承该配置，你可以在这个POM中发现如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Central Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>这里面配置的是Maven中央仓库，主要放置公共jar包，是由Apache Maven社区创建的。所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。</p><p><font style="color:#00FFFF">Maven并不会每次都从中央仓库下载jar包。jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的<code>.m2</code>目录）</font>，所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。</p><p><font style="color:red">关于搜索Maven依赖，可以直接在https://mvnrepository.com/中搜索到对应的<strong>唯一坐标</strong>。</font></p><p>关于 Maven 远程仓库地址的配置方式有两种：</p><ol><li>直接在项目的 pom.xml 文件中进行修改<font style="color:red">（不推荐，尤其是在多人协助的开发过程中非常的费事费力）</font>；</li><li>将 Maven 的远程仓库统一的配置到 Maven 的 Settings.xml 的配置文件中。</li></ol><p>Maven中央仓库地址大全：</p><p>1、阿里中央仓库</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>2、<a href="http://maven.apache.org">maven.apache.org</a> 中央仓库</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>central-repos<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Central Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>3、<a href="http://spring.io">spring.io</a> 中央仓库</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>springsource-repos<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>SpringSource Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://repo.spring.io/release/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> #生命周期</h2><h3 id="项目构建生命周期"><a class="markdownIt-Anchor" href="#项目构建生命周期"></a> 项目构建生命周期</h3><p>构建就是软件项目生产的整个过程，这个过程应该包括：</p><ul><li>文档和代码的生成（有些项目会使用代码自动生成工具，比如数据库访问代码的逆向工程）</li><li>代码的编译、测试和打包</li><li>打包好的代码进行分发或者部署</li></ul><p>这个过程通过生命周期来贯穿，一个典型的 Maven 构建（build）生命周期是由以下几个阶段的序列组成的：</p><pre><code class=" mermaid">flowchart LR开始--&gt;validate--&gt;compile--&gt;Test--&gt;package--&gt;verify--&gt;install--&gt;deploy</code></pre><table><thead><tr><th style="text-align:left">阶段</th><th style="text-align:left">处理</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">验证 <code>validate</code></td><td style="text-align:left">验证项目</td><td style="text-align:left">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td style="text-align:left">编译 <code>compile</code></td><td style="text-align:left">执行编译</td><td style="text-align:left">源代码编译在此阶段完成</td></tr><tr><td style="text-align:left">测试 <code>Test</code></td><td style="text-align:left">测试</td><td style="text-align:left">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td style="text-align:left">包装 <code>package</code></td><td style="text-align:left">打包</td><td style="text-align:left">创建JAR/WAR包如在 <code>pom.xml</code> 中定义提及的包</td></tr><tr><td style="text-align:left">检查 <code>verify</code></td><td style="text-align:left">检查</td><td style="text-align:left">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td style="text-align:left">安装 <code>install</code></td><td style="text-align:left">安装</td><td style="text-align:left">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td style="text-align:left">部署 <code>deploy</code></td><td style="text-align:left">部署</td><td style="text-align:left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table><h3 id="maven标准生命周期"><a class="markdownIt-Anchor" href="#maven标准生命周期"></a> Maven标准生命周期</h3><p>项目除了构建以外，还包括<strong>构建之前的项目清理</strong>，以及<strong>构建之后项目文档的创建</strong>。所以，Maven有三套相互独立的生命周期，分别是<code>clean</code>、<code>default</code>和<code>site</code>。每个生命周期包含一些阶段，阶段是有顺序的，后面的阶段依赖于前面的阶段。</p><p>一个完整的项目构建过程通常包括清理、编译、测试、打包、集成测试、验证、部署等步骤，Maven从中抽取了一套完善的、易扩展的生命周期。Maven 有以下三个标准的生命周期：</p><ul><li><code>clean</code>：项目清理的处理；</li><li><code>default</code>(或 <code>build</code>)：项目部署的处理；</li><li><code>site</code>：项目站点文档创建的处理。</li></ul><h3 id="maven-clean生命周期"><a class="markdownIt-Anchor" href="#maven-clean生命周期"></a> Maven Clean生命周期</h3><p>清洁（clean）生命周期包括以下三个阶段：</p><ul><li>预清洁（<code>pre-clean</code>）：执行实际项目清理之前所需的流程</li><li>清洁（<code>clean</code>） ：删除以前构建生成的所有文件</li><li>后清洁（<code>post-clean</code>）：执行完成项目清理所需的流程</li></ul><p><font style="color:#00FFFF">在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行</font>，也就是说，如果执行 <code>mvn clean</code> 将运行<code>pre-clean</code>和 <code>clean</code>两个生命周期阶段；如果执行<code>mvn post-clean</code>则运行<code>pre-clean</code>, <code>clean</code>, <code>post-clean</code>三个生命周期阶段。</p><h2 id="多模块项目"><a class="markdownIt-Anchor" href="#多模块项目"></a> #多模块项目</h2><p>  为了便于后期的维护，我们一般会进行分层开发。比如<strong>JavaWeb中最常见的情况就是分为：domain（域模型层）、dao（数据库访问层）、service（业务逻辑层）、web（表现层）</strong>。这样分层之后，各个层之间的职责会比较明确，后期维护起来也相对比较容易，可以使用 Maven 来构建以上的各个层。常见的 Java Web 项目结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ascii">system-parent<br>├── pom.xml<br>├── system-domain<br>│   ├── pom.xml<br>├── system-dao<br>│   ├── pom.xml<br>├── system-service<br>│   ├── pom.xml<br>└── system-web<br>    └── pom.xml<br></code></pre></div></td></tr></table></figure><h3 id="maven多模块项目搭建"><a class="markdownIt-Anchor" href="#maven多模块项目搭建"></a> Maven多模块项目搭建</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mvn archetype:generate -DgroupId=cn.maventest -DartifactId=system-parent -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=<span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p>或者在<code>IDEA</code>，<code>Eclipse</code>开发工具中直接创建Maven项目。</p><p>命令完成后当前目录会生成一个<code>system-parent</code>的标准Maven项目，将其中<code>src</code>目录删除，然后修改pom.xml文件，将<code>&lt;packaging&gt;jar&lt;/packaging&gt;</code> 修改为 <code>&lt;packaging&gt;pom&lt;/packaging&gt;</code>表示这是一个被继承的模块：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.maventest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>system-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>system-parent<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>然后再在<code>system-parent</code>目录下创建新的子模块：</p><ul><li><p>创建<code>system-domain</code>模块</p><p>也是按创建Maven的形式创建，创建后 system-parent 目录中的 pom.xml 文件会自动添加</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>system.domain<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>修改 system-domain 目录中的 pom.xml 文件，把<code>&lt;groupId&gt;</code>和``<version><code>标签去掉，加上</code><packaging> jar </packaging><code>， 因为子模块的</code>groupId<code>和</code>version<code>会继承</code>system-parent<code>，</code>packaging`设置打包方式为 jar。修改过后的 pom.xml 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.maventest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>system-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>system-domain<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>system-domain<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.apache.org<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>创建<code>system-dao</code>模块</p><p>pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.maventest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>system-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>system-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>system-dao<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.apache.org<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--system-dao需要使用到system-domain中的类，所以需要添加对system-domain模块的依赖--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.maventest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>system-domain<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>创建<code>system-service</code>模块，与<code>system-dao</code>类似只有pom文件中依赖不同：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  system-service依赖system-dao和system-domain，</span><br><span class="hljs-comment">  但是我们只需添加system-dao的依赖即可，因为system-dao已经依赖了system-domain</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.maventest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>system-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>system-web</code>模块是命令有些区别：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mvn archetype:generate -DgroupId=cn.maventest -DartifactId=system-web -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=<span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p>这种方式会在<code>\system-web\src\main\webapp</code>目录中还生成了一个简单的index.jsp，里面的内容为：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在<code>system-web\src\main\webapp\WEB-INF</code>目录中生成了web.xml文件，pom文件和其他模块类似，区别主要在于：</p><ol><li>添加对system-service模块的依赖</li><li><code>&lt;packaging&gt;</code>打包方式配置为war</li><li>最终运行的是 system-web 模块，所以需要对该模块添加插件</li></ol><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>system-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.maventest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>system-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>system-web Maven Webapp<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.apache.org<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--system-web依赖system-service--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.maventest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>system-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>system-web<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>启动</p><p>命令方式：使用<code>mvn clean install</code>编译，然后直接使用<code>mvn tomcat:run</code>启动。</p><p>开发工具：以IDEA为例，直接点击Maven侧边框的<code>system-web</code>&gt;<code>Lifecycle</code>&gt;<code>clean</code>再<code>validate</code>，然后将再在IDEA中配置tomcat，添加<code>Deployment</code>&gt;<code>+</code>&gt;<code>Artifacts</code>&gt;<code>system-web:war</code>然后直接在IDEA中启动服务。</p></li><li><p>示例下载：</p><p><a href="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_RES/system-parent.zip" download="system-parent.zip">Maven多模块示例</a></p></li></ul><h3 id="maven项目模板"><a class="markdownIt-Anchor" href="#maven项目模板"></a> Maven项目模板</h3><p>  我们创建Maven项目用到的命令<code>mvn archetype:generate</code>就是指的项目模板，它的任务是根据模板创建一个项目结构。我们之前创建子模块就是使用的<code>quickstart</code>作为原型。</p>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Excel操作</title>
    <link href="/helloworld/notes/Java/API/Excel%E6%93%8D%E4%BD%9C/"/>
    <url>/helloworld/notes/Java/API/Excel%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p>参考文章：</p><ul><li><a href="https://blog.kyire.site/2021/08/05/13a54546.html">Java 操作Excel之POI与EasyExcel</a></li><li><a href="https://www.bilibili.com/video/BV1Ua4y1x7BK">【狂神说Java】POI及EasyExcel</a></li></ul><h2 id="excel常用的api"><a class="markdownIt-Anchor" href="#excel常用的api"></a> #Excel常用的API</h2><ul><li><p><strong>Jakarta POI</strong> 是一套用于访问微软格式文档的Java API。Jakarta POI有很多组件组成，其中有用于操作Excel格式文件的HSSF和用于操作Word的HWPF。<br />  官方主页：<a href="http://poi.apache.org/index.html">http://poi.apache.org/index.html</a><br />  API 文档：<a href="http://poi.apache.org/apidocs/index.html">http://poi.apache.org/apidocs/index.html</a></p></li><li><p><strong>EasyExcel</strong>是阿里巴巴开源的一个excel处理框架，以使用简单，节省内存著称，EasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从磁盘上一行行读取数据，逐个解析。</p><p>EasyExcel采用一行一行的解析模式，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）<br />  官方主页：<a href="https://alibaba-easyexcel.github.io/">https://alibaba-easyexcel.github.io/</a></p><p>  API 文档：<a href="https://alibaba-easyexcel.github.io/docs/current/">https://alibaba-easyexcel.github.io/docs/current/</a></p></li></ul><h2 id="poi"><a class="markdownIt-Anchor" href="#poi"></a> #POI</h2><p>POI是目前比较流行的 Java 处理 excel 框架，但是其缺点是 <strong>数据量大容易造成 OOM 异常</strong></p><p>POI基本结构：</p><table><thead><tr><th style="text-align:center">组件</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">HSSF</td><td style="text-align:center"><font style="color:red">提供读写[Microsoft Excel](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> Excel)格式档案的功能（03 版本 excel）</font></td></tr><tr><td style="text-align:center">XSSF</td><td style="text-align:center"><font style="color:red">提供读写<a href="https://baike.baidu.com/item/OOXML">Microsoft Excel OOXML</a>格式档案的功能（07 版本 excel）</font></td></tr><tr><td style="text-align:center">HWPF</td><td style="text-align:center">提供读写[Microsoft Word](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> Word)格式档案的功能</td></tr><tr><td style="text-align:center">HSLF</td><td style="text-align:center">提供读写[Microsoft PowerPoint](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> PowerPoint)格式档案的功能</td></tr><tr><td style="text-align:center">HDGF</td><td style="text-align:center">提供读写[Microsoft Visio](<a href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> Visio)格式档案的功能</td></tr></tbody></table><p>POI操作EXCEL文件的组件有两种分别针对两种不同格式的Excel文件：</p><p>pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--xLs(03)--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--xLsx(07)--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi-ooxml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="读取操作"><a class="markdownIt-Anchor" href="#读取操作"></a> 读取操作</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * POI读取Excel</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadExcelTest</span> &#123;<br><br>    <span class="hljs-comment">// 生成文件路径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\Work\\IntelliJ IDEA\\testspace\\&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取03版本的excel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRead03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 通过文件路径得到文件输入流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(PATH + <span class="hljs-string">&quot;员工信息表_03.xls&quot;</span>);<br><br>        <span class="hljs-comment">// 通过文件输入流拿到工作簿</span><br>        <span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSSFWorkbook</span>(fileInputStream);<br><br>        <span class="hljs-comment">// 通过工作簿获取工作表</span><br>        <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> workbook.getSheetAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 拿到行数，通过循环读取数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rowCount</span> <span class="hljs-operator">=</span> sheet.getPhysicalNumberOfRows();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">rowNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; rowNum &lt; rowCount; rowNum++) &#123;<br>            <span class="hljs-comment">// 通过工作表读取行，并取到对应的列数</span><br>            <span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> sheet.getRow(rowNum);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cellCount</span> <span class="hljs-operator">=</span> row.getPhysicalNumberOfCells();<br>            <span class="hljs-comment">// 通过行读取单元格</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cellNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cellNum &lt; cellCount; cellNum++) &#123;<br>                <span class="hljs-type">Cell</span> <span class="hljs-variable">cell</span> <span class="hljs-operator">=</span> row.getCell(cellNum);<br>                <span class="hljs-comment">// 读取 excel 表格中的数据时要注意类型</span><br>                System.out.print(cell.getStringCellValue()+<span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取07版本的excel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRead07</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 通过文件路径得到文件输入流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(PATH + <span class="hljs-string">&quot;员工信息表_07.xlsx&quot;</span>);<br><br>        <span class="hljs-comment">// 通过文件输入流拿到工作簿</span><br>        <span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>(fileInputStream);<br><br>        <span class="hljs-comment">// 通过工作簿获取工作表</span><br>        <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> workbook.getSheetAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 拿到行数，通过循环读取数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rowCount</span> <span class="hljs-operator">=</span> sheet.getPhysicalNumberOfRows();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">rowNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; rowNum &lt; rowCount; rowNum++) &#123;<br>            <span class="hljs-comment">// 通过工作表读取行，并取到对应的列数</span><br>            <span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> sheet.getRow(rowNum);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cellCount</span> <span class="hljs-operator">=</span> row.getPhysicalNumberOfCells();<br>            <span class="hljs-comment">// 通过行读取单元格</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cellNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cellNum &lt; cellCount; cellNum++) &#123;<br>                <span class="hljs-type">Cell</span> <span class="hljs-variable">cell</span> <span class="hljs-operator">=</span> row.getCell(cellNum);<br>                <span class="hljs-comment">// 读取 excel 表格中的数据时要注意类型</span><br>                System.out.print(cell.getStringCellValue()+<span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="写入操作"><a class="markdownIt-Anchor" href="#写入操作"></a> 写入操作</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * POI写入Excel</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteExcelTest</span> &#123;<br><br>    <span class="hljs-comment">// 生成文件路径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\\Work\\IntelliJ IDEA\\testspace\\&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 写入03版本的excel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWrite03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建工作簿</span><br>        <span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSSFWorkbook</span>();<br><br>        <span class="hljs-comment">// 创建工作表</span><br>        <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> workbook.createSheet(<span class="hljs-string">&quot;员工信息表&quot;</span>);<br><br>        <span class="hljs-comment">// 创建第一行</span><br>        <span class="hljs-type">Row</span> <span class="hljs-variable">row1</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 创建单元格</span><br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell11</span> <span class="hljs-operator">=</span> row1.createCell(<span class="hljs-number">0</span>);<br>        cell11.setCellValue(<span class="hljs-string">&quot;姓名&quot;</span>);<br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell12</span> <span class="hljs-operator">=</span> row1.createCell(<span class="hljs-number">1</span>);<br>        cell12.setCellValue(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">// 创建第二行</span><br>        <span class="hljs-type">Row</span> <span class="hljs-variable">row2</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 创建单元格</span><br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell21</span> <span class="hljs-operator">=</span> row2.createCell(<span class="hljs-number">0</span>);<br>        cell21.setCellValue(<span class="hljs-string">&quot;出生日期&quot;</span>);<br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell22</span> <span class="hljs-operator">=</span> row2.createCell(<span class="hljs-number">1</span>);<br>        cell22.setCellValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>().toString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br><br>        <span class="hljs-comment">// 生成表 io流 -- 03版本使用xls后缀名</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(PATH + <span class="hljs-string">&quot;员工信息表_03.xls&quot;</span>);<br>        workbook.write(fileOutputStream);<br><br>        <span class="hljs-comment">// 关闭流</span><br>        fileOutputStream.close();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 写入07版本的excel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWrite07</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建工作簿</span><br>        <span class="hljs-type">Workbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>();<br><br>        <span class="hljs-comment">// 创建工作表</span><br>        <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> workbook.createSheet(<span class="hljs-string">&quot;员工信息表&quot;</span>);<br><br>        <span class="hljs-comment">// 创建第一行</span><br>        <span class="hljs-type">Row</span> <span class="hljs-variable">row1</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 创建单元格</span><br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell11</span> <span class="hljs-operator">=</span> row1.createCell(<span class="hljs-number">0</span>);<br>        cell11.setCellValue(<span class="hljs-string">&quot;姓名&quot;</span>);<br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell12</span> <span class="hljs-operator">=</span> row1.createCell(<span class="hljs-number">1</span>);<br>        cell12.setCellValue(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">// 创建第二行</span><br>        <span class="hljs-type">Row</span> <span class="hljs-variable">row2</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 创建单元格</span><br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell21</span> <span class="hljs-operator">=</span> row2.createCell(<span class="hljs-number">0</span>);<br>        cell21.setCellValue(<span class="hljs-string">&quot;出生日期&quot;</span>);<br>        <span class="hljs-type">Cell</span> <span class="hljs-variable">cell22</span> <span class="hljs-operator">=</span> row2.createCell(<span class="hljs-number">1</span>);<br>        cell22.setCellValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTime</span>().toString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br><br>        <span class="hljs-comment">// 生成表 io流 -- 07版本使用xlsx后缀名</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(PATH + <span class="hljs-string">&quot;员工信息表_07.xlsx&quot;</span>);<br>        workbook.write(fileOutputStream);<br><br>        <span class="hljs-comment">// 关闭流</span><br>        fileOutputStream.close();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="高级操作"><a class="markdownIt-Anchor" href="#高级操作"></a> 高级操作</h3><p>POI还支持对Excel表格的一些复杂操作，如合并单元格，修改单元格样式等。详细操作参考文档：<a href="https://poi.apache.org/components/spreadsheet/quick-guide.html">https://poi.apache.org/components/spreadsheet/quick-guide.html</a></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Workbook</span> <span class="hljs-variable">wb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HSSFWorkbook</span>();<br><span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> wb.createSheet(<span class="hljs-string">&quot;new sheet&quot;</span>);<br><span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">1</span>);<br><span class="hljs-type">Cell</span> <span class="hljs-variable">cell</span> <span class="hljs-operator">=</span> row.createCell(<span class="hljs-number">1</span>);<br>cell.setCellValue(<span class="hljs-string">&quot;This is a test&quot;</span>);<br><span class="hljs-comment">//合并单元格</span><br>sheet.addMergedRegion(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CellRangeAddress</span>(<br>        <span class="hljs-number">1</span>, <span class="hljs-comment">//first row (0-based)</span><br>        <span class="hljs-number">1</span>, <span class="hljs-comment">//last row  (0-based)</span><br>        <span class="hljs-number">1</span>, <span class="hljs-comment">//first column (0-based)</span><br>        <span class="hljs-number">2</span>  <span class="hljs-comment">//last column  (0-based)</span><br>));<br><br><span class="hljs-comment">// 创建一个新字体</span><br><span class="hljs-type">Font</span> <span class="hljs-variable">font</span> <span class="hljs-operator">=</span> wb.createFont();<br>font.setFontHeightInPoints((<span class="hljs-type">short</span>)<span class="hljs-number">24</span>);<br>font.setFontName(<span class="hljs-string">&quot;Courier New&quot;</span>);<br>font.setItalic(<span class="hljs-literal">true</span>);<br>font.setStrikeout(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//赋给CellStyle作为样式使用</span><br><span class="hljs-type">CellStyle</span> <span class="hljs-variable">style</span> <span class="hljs-operator">=</span> wb.createCellStyle();<br>style.setFont(font);<br><span class="hljs-comment">//将样式赋给单元格</span><br>cell.setCellStyle(style);<br></code></pre></div></td></tr></table></figure><h2 id="easyexcel"><a class="markdownIt-Anchor" href="#easyexcel"></a> #EasyExcel</h2><p>EasyExcel 是 Alibaba 开源的一个 excel 处理框架，特点是 <strong>使用简单、节约内存</strong>。</p><p>pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入easyexcel依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easyexcel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>与POI不同，EasyExcel操作 <code>03</code> 版本的 <code>excel</code>，只需要在读写操作时传入 <code>excelType</code> 参数</p><h3 id="对象实体类示例"><a class="markdownIt-Anchor" href="#对象实体类示例"></a> 对象实体类示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@EqualsAndHashCode</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexOrNameData</span> &#123;<br>    <span class="hljs-comment">// 强制读取第三列 这里不建议 index 和 name 同时用，要么一个对象只用index，要么一个对象只用name去匹配</span><br>    <span class="hljs-meta">@ExcelProperty(index = 2)</span><br>    <span class="hljs-keyword">private</span> Double doubleData;<br>    <span class="hljs-comment">// 用名字去匹配，这里需要注意，如果名字重复，会导致只有一个字段读取到数据</span><br>    <span class="hljs-meta">@ExcelProperty(&quot;字符串标题&quot;)</span><br>    <span class="hljs-keyword">private</span> String string;<br>    <span class="hljs-meta">@ExcelProperty(&quot;日期标题&quot;)</span><br>    <span class="hljs-keyword">private</span> Date date;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Excel表示例：</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/ExcelDemo.png" alt="ExcelDemo" /></p><h3 id="读取操作-2"><a class="markdownIt-Anchor" href="#读取操作-2"></a> 读取操作</h3><h4 id="数据持久层"><a class="markdownIt-Anchor" href="#数据持久层"></a> 数据持久层</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *假设这个是DAO存储。当然还要这个类让spring管理，当然你不用需要存储，也不需要这个类。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoDAO</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(List&lt;DemoData&gt; list)</span> &#123;<br>    <span class="hljs-comment">// 如果是mybatis,尽量别直接调用多次insert,自己写一个mapper里面新增一个方法batchInsert,所有数据一次性插入</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="读取监听器"><a class="markdownIt-Anchor" href="#读取监听器"></a> 读取监听器</h4><p><font style="color:red"><strong>DemoDataListener 不能被spring管理，要每次读取excel都要new，然后里面用到spring可以构造方法传进。</strong></font></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoDataListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReadListener</span>&lt;DemoData&gt; &#123;<br>    <span class="hljs-comment">// 每隔5条存储数据库，实际使用中可以100条，然后清理list ，方便内存回收</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BATCH_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 缓存的数据</span><br>    <span class="hljs-keyword">private</span> List&lt;DemoData&gt; cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);<br>    <span class="hljs-comment">// 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。</span><br>    <span class="hljs-keyword">private</span> DemoDAO demoDAO;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoDataListener</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数</span><br>        demoDAO = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoDAO</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoDataListener</span><span class="hljs-params">(DemoDAO demoDAO)</span> &#123;<br>        <span class="hljs-built_in">this</span>.demoDAO = demoDAO;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这个每一条数据解析都会来调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(DemoData data, AnalysisContext context)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));<br>        cachedDataList.add(data);<br>        <span class="hljs-comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span><br>        <span class="hljs-keyword">if</span> (cachedDataList.size() &gt;= BATCH_COUNT) &#123;<br>            saveData();<br>            <span class="hljs-comment">// 存储完成清理 list</span><br>            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 所有数据解析完成了 都会来调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterAllAnalysed</span><span class="hljs-params">(AnalysisContext context)</span> &#123;<br>        <span class="hljs-comment">// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span><br>        saveData();<br>        log.info(<span class="hljs-string">&quot;所有数据解析完成！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加上存储数据库</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveData</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125;条数据，开始存储数据库！&quot;</span>, cachedDataList.size());<br>        demoDAO.save(cachedDataList);<br>        log.info(<span class="hljs-string">&quot;存储数据库成功！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="操作代码"><a class="markdownIt-Anchor" href="#操作代码"></a> 操作代码</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1.创建excel对应的实体对象</span><br><span class="hljs-comment"> * 2.由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器</span><br><span class="hljs-comment"> * 3.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleRead</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 写法1：不用额外写一个DemoDataListener</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> TestFileUtil.getPath() + <span class="hljs-string">&quot;demo&quot;</span> + File.separator + <span class="hljs-string">&quot;ExcelDemo.xlsx&quot;</span>;<br>    <span class="hljs-comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span><br>    <span class="hljs-comment">// 这里每次会读取100条数据 然后返回过来 直接调用使用数据就行</span><br>    EasyExcel.read(fileName, DemoData.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageReadListener</span>&lt;DemoData&gt;(dataList -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (DemoData demoData : dataList) &#123;<br>            log.info(<span class="hljs-string">&quot;读取到一条数据&#123;&#125;&quot;</span>, JSON.toJSONString(demoData));<br>        &#125;<br>    &#125;)).sheet().doRead();<br>    <br>    <span class="hljs-comment">// 写法2：使用DemoDataListener</span><br>    fileName = TestFileUtil.getPath() + <span class="hljs-string">&quot;demo&quot;</span> + File.separator + <span class="hljs-string">&quot;ExcelDemo.xlsx&quot;</span>;<br>    <span class="hljs-comment">// 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span><br>    <span class="hljs-comment">// EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).sheet().doRead();</span><br>    <br>    <span class="hljs-comment">// 或者可以指定sheet,一个文件一个reader</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ExcelReader</span> <span class="hljs-variable">excelReader</span> <span class="hljs-operator">=</span> EasyExcel.read(fileName, DemoData.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoDataListener</span>()).build()) &#123;<br>            <span class="hljs-comment">// 构建一个sheet 这里可以指定名字</span><br>            <span class="hljs-type">ReadSheet</span> <span class="hljs-variable">readSheet</span> <span class="hljs-operator">=</span> EasyExcel.readSheet(<span class="hljs-number">0</span>).build();<br>            <span class="hljs-comment">// 读取一个sheet</span><br>            excelReader.read(readSheet);<br>        &#125;<br></code></pre></div></td></tr></table></figure><h3 id="写入操作-2"><a class="markdownIt-Anchor" href="#写入操作-2"></a> 写入操作</h3><h4 id="操作代码-2"><a class="markdownIt-Anchor" href="#操作代码-2"></a> 操作代码</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EasyExcelWrite</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleWrite</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> PATH + <span class="hljs-string">&quot;ExcelDemo.xlsx&quot;</span>;<br>        <span class="hljs-comment">// 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span><br>        <span class="hljs-comment">// 如果这里想使用 03版本 则 传入excelType参数即可</span><br>        EasyExcel.write(fileName, DemoData.class).sheet(<span class="hljs-string">&quot;模板&quot;</span>).doWrite(data());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8版本特性</title>
    <link href="/helloworld/notes/Java/JDK8%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"/>
    <url>/helloworld/notes/Java/JDK8%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p>参考文章：</p><ul><li><a href="https://blog.kyire.site/2021/06/17/397c083a.html#Stream-API">Java8 新特性</a></li><li><a href="https://www.pdai.tech/md/java/java8/java8-stream.html#%E7%90%86%E8%A7%A3%E6%B3%A8%E8%A7%A3-functioninterface">函数式编程</a></li><li><a href="https://www.runoob.com/java/java8-streams.html">Java 8 Stream</a></li><li><a href="https://www.pdai.tech/md/java/java8/java8-optional.html#">Optional解析</a></li></ul><h2 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> #函数式编程</h2><p><font style="color:red">面向对象编程是对数据进行抽象；函数式编程是对行为进行抽象。</font></p><h3 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> lambda表达式</h3><p>lambda表达式在Java中又称为闭包或匿名函数，lambda仅能放入如下代码:</p><ul><li>预定义使用了<code>@Functional</code>注释的函数式接口，自带一个抽象函数的方法。例如，<code>Predicate</code>、<code>Function</code>、<code>Consumer</code> 或 <code>Supplier</code>，都那么可以向其传lambda表达式。</li><li>SAM(Single Abstract Method <strong>单个抽象方法</strong>)类型。例如，若一个方法接收<code>Runnable</code>、<code>Comparable</code>或者 <code>Callable</code> 接口，都有单个抽象方法，可以传入lambda表达式</li></ul><p>这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。</p><p>lambda表达式限制只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; primes = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;);<br><span class="hljs-type">int</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">//修改域外变量会报编译时错误</span><br>primes.forEach(element -&gt; &#123; factor++; &#125;);<br><span class="hljs-comment">//访问而不作修改是可以的</span><br>primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;);<br></code></pre></div></td></tr></table></figure><h4 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用</h4><p>lambda表达式内可以使用<code>方法引用</code>，仅当该方法不修改lambda表达式提供的参数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">list.forEach(n -&gt; System.out.println(n)); <br><span class="hljs-comment">// 方法引用</span><br>list.forEach(System.out::println);  <br><span class="hljs-comment">//若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式</span><br>list.forEach((String n) -&gt; System.out.println(<span class="hljs-string">&quot;n:&quot;</span> + n));<br></code></pre></div></td></tr></table></figure><p>方法引用可以有四种情况：</p><ol><li><p>构造引用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Supplier&lt;Thread&gt; thread = Thread::<span class="hljs-keyword">new</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>对象::实例方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>Collections.addAll(list,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br>list.forEach(System.out::println);<br></code></pre></div></td></tr></table></figure><p><font style="color:red">这种方式<code>Lambda</code>表达式的形参列表与实例方法的实参列表类型，个数需对应，如：</font></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">list.forEach(e -&gt; System.out.println(e));<br></code></pre></div></td></tr></table></figure><p>其中的**第一个<code>e</code>**是形参，**第二个<code>e</code>**是实参，二者需一致。</p></li><li><p>类名::静态方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Double&gt; stream = Stream.generate(Math::random);<br></code></pre></div></td></tr></table></figure></li><li><p>类名::实例方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">TreeSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(String::compareTo);<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="stream-parallelstream"><a class="markdownIt-Anchor" href="#stream-parallelstream"></a> Stream &amp; parallelStream</h3><p>每个Stream都有两种模式: 顺序执行和并行执行。</p><p>顺序流:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List &lt;Person&gt; people = list.getStream.collect(Collectors.toList());<br></code></pre></div></td></tr></table></figure><p>并行流:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List &lt;Person&gt; people = list.getStream.parallel().collect(Collectors.toList());<br></code></pre></div></td></tr></table></figure><p>当使用<strong>顺序方式</strong>去遍历时，每个item读完后再读下一个item。而使用<strong>并行</strong>去遍历时，数组会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。如果是多核配置，理论上并行流则会比顺序流快上一倍。</p><blockquote><p>特点：</p><ul><li><p><code>stream</code>不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果；</p></li><li><p><code>stream</code>不会改变数据源，通常情况下会产生一个新的集合；</p></li><li><p><code>stream</code>具有延迟执行特性，只有调用终端操作时，中间操作才会执行；</p><ul><li><code>终端操作</code>：会消费流，这种操作会产生一个结果的，如果一个流被消费过了，那它就不能被重用的。</li><li><code>中间操作</code>：中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。</li></ul><p>中间操作不是立即发生的，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。</p></li><li><p><code>stream</code>不可复用，对一个已经进行过终端操作的流再次调用，会抛出异常。</p></li></ul></blockquote><p>获取Stream流：</p><ul><li>所有的 Collection 集合都可以通过 stream 默认方法获取流（顺序流）；</li><li>所有的 Collection 集合都可以通过parallelStream获取并行流</li><li>Stream 接口的静态方法 of 可以获取数组对应的流。</li><li>Arrays的静态方法stream也可以获取流</li></ul><h4 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h4><h5 id="foreach"><a class="markdownIt-Anchor" href="#foreach"></a> forEach</h5><p><font style="color:red">用于遍历的方法</font>，参数传入一个函数式接口：Consumer</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;一&quot;</span>, <span class="hljs-string">&quot;二&quot;</span>, <span class="hljs-string">&quot;三&quot;</span>);<br>stream.forEach(item‐&gt; System.out.println(item));<br></code></pre></div></td></tr></table></figure><h5 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> filter</h5><p>用于过滤，通过 filter 方法将一个流转换成另一个子集流。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Integer&gt; stream1 = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">//对流中元素过滤，设定筛选条件</span><br>Stream&lt;Integer&gt; stream2 = stream1.filter(name -&gt; &#123;<br>    <span class="hljs-keyword">if</span>(name&gt;<span class="hljs-number">1</span>&amp;&amp;name&lt;<span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;);<br><span class="hljs-comment">//遍历过滤后的流</span><br>stream2.forEach(name -&gt; System.out.println(name));<br><br></code></pre></div></td></tr></table></figure><h5 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h5><p>如果需要将流中的元素映射到另一个流中，可以使用 map 方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建一个整数类型的流</span><br>Stream&lt;Integer&gt; stream1 = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">//把stream1流中的int类型全部转成String类型，而且可以对值做出一些修改</span><br>Stream&lt;String&gt; stream2 = stream1.map((Integer value) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;value：&quot;</span>+value;<br>&#125;);<br><br>stream2.forEach(name -&gt; System.out.println(name));<br></code></pre></div></td></tr></table></figure><h5 id="count"><a class="markdownIt-Anchor" href="#count"></a> count</h5><p>流提供 count 方法来计数其中的元素个数，该方法返回一个long值代表元素个数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">//count方法常用于与其他筛选元素的方法组合起来</span><br><span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> stream.filter(name -&gt; &#123;<br>    <span class="hljs-keyword">if</span>(name&gt;<span class="hljs-number">1</span>&amp;&amp;name&lt;<span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;).count();<br></code></pre></div></td></tr></table></figure><h5 id="concat"><a class="markdownIt-Anchor" href="#concat"></a> concat</h5><p>如果有两个流，希望合并成为一个流，那么可以使用 <strong>Stream 接口的静态方法 <code>concat</code></strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Integer&gt; streamA = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>Stream&lt;Integer&gt; streamB = Stream.of(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">//合并成一个新的流</span><br>Stream&lt;Integer&gt; result = Stream.concat(streamA, streamB);<br></code></pre></div></td></tr></table></figure><h5 id="sorted"><a class="markdownIt-Anchor" href="#sorted"></a> sorted</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = List.of(<span class="hljs-number">124</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">51</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 按照自然排序</span><br>integers.stream().sorted().forEach(System.out::println);<br><br>List&lt;Integer&gt; integers2 = List.of(<span class="hljs-number">124</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">51</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 定制排序(大到小)，需要传入Comparator接口（如果流中的是引用类型，只能用定制排序）</span><br>integers2.stream().sorted((e1,e2) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> e2-e1;<br>&#125;).forEach(System.out::println);<br><span class="hljs-comment">// 定制排序(大到小)简写</span><br>integers2.stream().sorted((e1,e2) -&gt; e2-e1).forEach(System.out::println);<br></code></pre></div></td></tr></table></figure><p><font style="color:grey">Stream的方法很多，这里只简要介绍了部分简单的使用。</font></p><table><thead><tr><th>操作</th><th>类型</th><th>返回类型</th><th>使用的类型/函数式接口</th><th>函数描述符</th></tr></thead><tbody><tr><td><code>filter</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td><code>distinct</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td></td><td></td></tr><tr><td><code>skip</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>long</code></td><td></td></tr><tr><td><code>map</code></td><td>中间</td><td><code>Stream&lt;R&gt;</code></td><td><code>Function&lt;T, R&gt;</code></td><td><code>T -&gt; R</code></td></tr><tr><td><code>flatMap</code></td><td>中间</td><td><code>Stream&lt;R&gt;</code></td><td><code>Function&lt;T,Stream&lt;R&gt;&gt;</code></td><td><code>T -&gt; Stream&lt;R&gt;</code></td></tr><tr><td><code>limit</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>long</code></td><td></td></tr><tr><td><code>sorted</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>Comparator&lt;T&gt;</code></td><td><code>(T, T) -&gt; int</code></td></tr><tr><td><code>anyMatch</code></td><td>终端</td><td><code>boolean</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td><code>noneMatch</code></td><td>终端</td><td><code>boolean</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td><code>allMatch</code></td><td>终端</td><td><code>boolean</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td><code>findAny</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td></td><td></td></tr><tr><td><code>findFirst</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td></td><td></td></tr><tr><td><code>forEach</code></td><td>终端</td><td><code>void</code></td><td><code>Consumer&lt;T&gt;</code></td><td><code>T -&gt; void</code></td></tr><tr><td><code>collect</code></td><td>终端</td><td><code>R</code></td><td><code>Collector&lt;T, A, R&gt;</code></td><td></td></tr><tr><td><code>reduce</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>(T, T) -&gt; T</code></td></tr><tr><td><code>count</code></td><td>终端</td><td><code>long</code></td><td></td><td></td></tr></tbody></table><h3 id="functionalinterfa"><a class="markdownIt-Anchor" href="#functionalinterfa"></a> FunctionalInterfa</h3><p><font style="color:red">只包含了一个抽象方法的接口，称为函数式接口（可以有多个非抽象方法）。</font>可以使用<code>@FunctionalInterface</code>注解自定义声明。</p><blockquote><p>JDK 1.8 之前已有的函数式接口：</p><ul><li><p>java.lang.Runnable</p></li><li><p>java.util.concurrent.Callable</p></li><li><p>java.security.PrivilegedAction</p></li><li><p>java.util.Comparator</p></li><li><p>java.io.FileFilter</p></li><li><p>java.nio.file.PathMatcher</p></li><li><p>java.lang.reflect.InvocationHandler</p></li><li><p>java.beans.PropertyChangeListener</p></li><li><p>java.awt.event.ActionListener</p></li><li><p>javax.swing.event.ChangeListener</p></li></ul><p>JDK 1.8 新增加的函数接口：</p><ul><li>java.util.function</li></ul></blockquote><p>如果一个类型被这个注解修饰，那么编译器会要求这个类型必须满足如下条件:</p><ul><li>这个类型必须是一个interface，而不是其他的注解类型、枚举enum或者类class</li><li>这个类型必须满足function interface的所有要求，如你个包含两个抽象方法的接口增加这个注解，会有编译错误。</li></ul><p><font style="color:red">编译器会自动把满足<code>function interface</code>要求的接口自动识别为<code>function interface</code>，所以你不需要对接口增加@FunctionInterface注解。</font></p><h4 id="自定义函数接口"><a class="markdownIt-Anchor" href="#自定义函数接口"></a> 自定义函数接口</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TestInterface test=()-&gt;System.out.println(<span class="hljs-string">&quot;Test&quot;</span>);;<br>        test.test();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="四大函数接口"><a class="markdownIt-Anchor" href="#四大函数接口"></a> 四大函数接口</h4><blockquote><ul><li>消费型接口: Consumer&lt; T&gt; void accept(T t)有参数，无返回值的抽象方法；</li><li>供给型接口: Supplier &lt; T&gt; T get() 无参有返回值的抽象方法；</li><li>断定型接口: Predicate<T> boolean test(T t):有参，但是返回值类型是固定的boolean；</li><li>函数型接口: Function&lt;T,R&gt; R apply(T t)有参有返回值的抽象方法；</li></ul></blockquote><h2 id="optional"><a class="markdownIt-Anchor" href="#optional"></a> #Optional</h2><p>Java 8中引入的一个新类<code>Optional</code>。Javadoc对<code>Optional</code>类的描述如下:</p><blockquote><p>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p></blockquote><ul><li><p><code>of</code>方法通过工厂方法创建<code>Optional</code>类。需要注意的是，创建对象时传入的参数不能为<code>null</code>。如果传入参数为<code>null</code>，则抛出<code>NullPointerException</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//调用工厂方法创建Optional实例</span><br>Optional&lt;String&gt; name = Optional.of(<span class="hljs-string">&quot;Sanaulla&quot;</span>);<br><span class="hljs-comment">//传入参数为null，抛出NullPointerException.</span><br>Optional&lt;String&gt; someNull = Optional.of(<span class="hljs-literal">null</span>);<br></code></pre></div></td></tr></table></figure></li><li><p><code>ofNullable</code>与<code>of</code>方法相似，唯一的区别是<strong>可以接受参数为<code>null</code>的情况</strong>，如果指定的值为null，则返回一个空的Optional。示例如下:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//下面创建了一个不包含任何值的Optional实例</span><br><span class="hljs-type">Optional</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> Optional.ofNullable(<span class="hljs-literal">null</span>);<br></code></pre></div></td></tr></table></figure></li><li><p><code>isPresent</code>，如果值存在返回true，否则返回false；</p></li><li><p><code>get</code>，如果Optional有值则将其返回，否则抛出NoSuchElementException；</p></li><li><p><code>ifPresent</code>，如果Optional实例有值则为其调用**<code>consumer</code>接口**，否则不做处理；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//ifPresent方法接受lambda表达式作为参数。</span><br><span class="hljs-comment">//lambda表达式对Optional的值调用consumer进行处理。</span><br>name.ifPresent((value) -&gt; &#123;<br>  System.out.println(<span class="hljs-string">&quot;The length of the value is: &quot;</span> + value.length());<br>&#125;);<br></code></pre></div></td></tr></table></figure></li><li><p><code>orElse</code>，如果有值则将其返回，否则返回orElse方法传入的参数。</p></li><li><p><code>orElseGet</code>与<code>orElse方法</code>类似，区别在于得到的默认值。<code>orElse</code>方法将传入的字符串作为默认值，<code>orElseGet</code>方法可以接受**<code>Supplier</code>接口**的实现用来生成默认值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//orElseGet可以接受一个lambda表达式生成默认值。</span><br>System.out.println(name.orElseGet(() -&gt; <span class="hljs-string">&quot;Default Value&quot;</span>));<br></code></pre></div></td></tr></table></figure></li><li><p><code>orElseThrow</code>，在<code>orElseGet</code>方法中，我们传入一个<code>Supplier</code>接口。然而，在<code>orElseThrow</code>中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">//orElseThrow与orElse方法类似。与返回默认值不同，</span><br>  <span class="hljs-comment">//orElseThrow会抛出lambda表达式或方法生成的异常 </span><br>  empty.orElseThrow(ValueAbsentException::<span class="hljs-keyword">new</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>  System.out.println(ex.getMessage());<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ValueAbsentException</code>定义：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueAbsentException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ValueAbsentException</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ValueAbsentException</span><span class="hljs-params">(String msg)</span> &#123;<br>    <span class="hljs-built_in">super</span>(msg);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No value present in the Optional instance&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>map</code>，如果有值，则对其执行调用<code>mapping</code>函数得到返回值。如果返回值不为null，则创建包含<code>mapping</code>返回值的<code>Optional</code>作为<code>map</code>方法返回值，否则返回空<code>Optional</code>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。</span><br><span class="hljs-comment">//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。</span><br>Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());<br>System.out.println(upperName.orElse(<span class="hljs-string">&quot;No value found&quot;</span>));<br></code></pre></div></td></tr></table></figure></li><li><p><code>flatMap</code>与<code>map</code>类似，区别在于<code>mapping</code>函数的返回值不同。<code>map</code>方法的<code>mapping</code>函数返回值可以是任何类型T，而<code>flatMap</code>方法的<code>mapping</code>函数必须是Optional。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//在map函数返回之前会包装为Optional，但flatMap方法中的lambda表达式返回值必须是Optionl实例。 </span><br>upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));<br>System.out.println(upperName.orElse(<span class="hljs-string">&quot;No value found&quot;</span>));<span class="hljs-comment">//输出SANAULLA</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>filter</code>，如果有值并且满足断言条件返回包含该值的<code>Optional</code>，否则返回空<code>Optional</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/helloworld/notes/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/hexo/"/>
    <url>/helloworld/notes/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/hexo/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p>参考文章：</p><ul><li><a href="https://blog.kyire.site/2021/02/06/8fe2b6a8.html">Hexo+Gitee 搭建个人博客</a></li><li><a href="https://blog.kyire.site/2022/06/16/47488464.html">使用 GitHub Actions 自动发布Hexo博客</a></li><li><a href="https://hexo.io/zh-cn/docs/">hexo文档</a></li></ul><h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> #环境搭建</h2><h3 id="git"><a class="markdownIt-Anchor" href="#git"></a> Git</h3><ul><li><p>在Windows上使用git，可以从Git官网直接下载<a href="https://git-scm.com/downloads">安装程序</a>，然后按默认选项安装即可。</p></li><li><p>安装完成后，在cmd界面输入<code>git --version</code>，如果正常返回git版本号，就说明安装成功。</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">C:\Users\Admin&gt; git <span class="hljs-literal">--version</span><br>git version <span class="hljs-number">2.33</span>.<span class="hljs-number">1</span>.windows.<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure></li><li><p>桌面单击右键打开快捷菜单上会直接显示<code>Git Bash Here</code>选项，用来快速打开git。</p></li></ul><h3 id="nodejs"><a class="markdownIt-Anchor" href="#nodejs"></a> Node.js</h3><p><code>Hexo</code>是基于 Node.js 制作的静态博客，我们要用到 Node.js 里面的<a href="https://www.npmjs.cn/">npm</a>(node package manager)包管理器来安装插件。</p><ul><li><p>首先从<a href="https://nodejs.org/">Node.js官网</a>下载对应平台的安装程序，同样也可以直接按照默认选项安装即可。</p></li><li><p>安装成功后，在cmd界面输入<code>node -v</code>和<code>npm -v</code>以验证是否成功：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">C:\Users\Admin&gt;node <span class="hljs-literal">-v</span><br>v14.<span class="hljs-number">17.6</span><br><br>C:\Users\Admin&gt;npm <span class="hljs-literal">-v</span><br><span class="hljs-number">6.14</span>.<span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="hexo"><a class="markdownIt-Anchor" href="#hexo"></a> Hexo</h3><p>安装Hexo，我们需要借助 <code>npm</code> 工具来安装，但是因为npm的远程服务器在国外，所以有时候难免出现访问过慢，甚至无法访问的情况。<br />我们可以使用淘宝的cnpm代替解决这个问题，而修改方法有两种：</p><ol><li><p>直接安装cnpm 安装淘宝提供的cnpm，并更改服务器地址为淘宝的国内地址如：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> cnpm <span class="hljs-literal">--registry</span>=https://registry.npm.taobao.org<br></code></pre></div></td></tr></table></figure><p>通过<code>cnpm -v</code>命令查看版本号验证是否安装成功；</p><p>这种方式在需要下载安装包时用<code>cnpm</code>替代<code>npm</code>，如：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">cnpm install <span class="hljs-literal">-g</span> hexo<span class="hljs-literal">-cli</span><br></code></pre></div></td></tr></table></figure></li><li><p>替换npm仓库地址为淘宝镜像地址：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></div></td></tr></table></figure><p>通过<code>npm config get registry</code>查看版本号验证是否更改成功。</p></li></ol><p>安装 Hexo命令：<code>cnpm install -g hexo-cli</code> 或 <code>npm install -g hexo-cli</code>，</p><p>并且通过<code>Hexo -v</code>验证是否安装成功。</p><h2 id="初始化hexo"><a class="markdownIt-Anchor" href="#初始化hexo"></a> #初始化Hexo</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">hexo init &lt;folder&gt;<br><span class="hljs-built_in">cd</span> &lt;folder&gt;<br>npm install<br></code></pre></div></td></tr></table></figure><p>初始化创建的项目如下：<br />.<br />|-- node_modules <font style="color:yellow">(依赖包)</font><br />|-- scaffolds <font style="color:yellow">(生成文章的模板)</font><br />|-- source <font style="color:yellow">(资源文件夹)</font><br />|   |--  _posts <font style="color:yellow">(存放文章文件夹)</font><br />|-- themes <font style="color:yellow">(主题)</font><br />|-- _config.yml  <font style="color:yellow">(配置文件)</font><br />|-- package.json <font style="color:yellow">(应用程序的信息)</font></p><p>其中source文件夹中<code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。<br />所以source中也可以存放一些静态资源如图片等。</p><p><strong>运行</strong></p><p>通过<code>hexo server</code>命令打开hexo服务，默认使用http://localhost:4000/访问。</p><p>默认访问界面如下：</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/hexo-%E5%88%9D%E5%A7%8B%E7%95%8C%E9%9D%A2.png" alt="hexo-初始界面" /></p><h2 id="hexo指令"><a class="markdownIt-Anchor" href="#hexo指令"></a> #Hexo指令</h2><h3 id="hexo-init"><a class="markdownIt-Anchor" href="#hexo-init"></a> hexo init</h3><p>初始化Hexo，init后可接文件路径如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">hexo init D:\Data\Project\Test<br></code></pre></div></td></tr></table></figure><h3 id="hexo-server"><a class="markdownIt-Anchor" href="#hexo-server"></a> hexo server</h3><p>启动服务器。可缩写为<code>hexo s</code>默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-p</code>, <code>--port</code></td><td style="text-align:left">重设端口</td></tr><tr><td style="text-align:left"><code>-s</code>, <code>--static</code></td><td style="text-align:left">只使用静态文件</td></tr><tr><td style="text-align:left"><code>-l</code>, <code>--log</code></td><td style="text-align:left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="hexo-clean"><a class="markdownIt-Anchor" href="#hexo-clean"></a> hexo clean</h3><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="hexo-generate"><a class="markdownIt-Anchor" href="#hexo-generate"></a> hexo generate</h3><p>生成静态文件。可缩写为 <code>hexo g</code></p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-d</code>, <code>--deploy</code></td><td style="text-align:left">文件生成后立即部署网站</td></tr><tr><td style="text-align:left"><code>-w</code>, <code>--watch</code></td><td style="text-align:left">监视文件变动</td></tr><tr><td style="text-align:left"><code>-b</code>, <code>--bail</code></td><td style="text-align:left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td style="text-align:left"><code>-f</code>, <code>--force</code></td><td style="text-align:left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td style="text-align:left"><code>-c</code>, <code>--concurrency</code></td><td style="text-align:left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h3 id="hexo-deploy"><a class="markdownIt-Anchor" href="#hexo-deploy"></a> hexo deploy</h3><p>部署网站。可缩写为<code>hexo d</code></p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-g</code>, <code>--generate</code></td><td style="text-align:left">部署之前预先生成静态文件</td></tr></tbody></table><p>以上5个命令足以用于部署个人静态网站，更详细的指令使用请参考<a href="https://hexo.io/zh-cn/docs/commands">hexo官方文档</a></p><h2 id="部署网站"><a class="markdownIt-Anchor" href="#部署网站"></a> #部署网站</h2><ul><li>首先需要创建一个git仓库并复制仓库地址：</li></ul><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/hexo-%E5%88%9B%E5%BB%BAgit%E4%BB%93%E5%BA%93.png" alt="hexo-创建git仓库" /></p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/hexo-git%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80.png" alt="image-20220621181615257" /></p><ul><li>打开 Hexo 的配置文件<code>_config.yml</code></li></ul><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: https://github.com/C1thulhu/MyBlog.git <span class="hljs-comment">#仓库的url</span><br>  branch: master<br></code></pre></div></td></tr></table></figure><ul><li>安装Hexo插件</li></ul><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">cnpm install hexo<span class="hljs-literal">-deployer-git</span> <span class="hljs-literal">--save</span>  <span class="hljs-comment">#通过cpnm安装git插件</span><br>git config <span class="hljs-literal">--global</span> user.email <span class="hljs-string">&#x27;******@qq.com&#x27;</span>  <span class="hljs-comment">#设置git邮箱（git的注册邮箱）</span><br>git config <span class="hljs-literal">--global</span> user.name <span class="hljs-string">&#x27;****&#x27;</span>            <span class="hljs-comment">#设置用户名（git的y注册昵称）</span><br></code></pre></div></td></tr></table></figure><ul><li>上传</li></ul><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">hexo d  <span class="hljs-comment">#上传到git的远端仓库</span><br><span class="hljs-comment"># 在上传时，需要再次输入git的用户名username和密码password</span><br></code></pre></div></td></tr></table></figure><p>上传会将生成的静态文件(public文件夹)提交到git仓库中。</p><p>上传后github会自动部署页面：</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/hexo-github%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%A1%B5%E9%9D%A2.png" alt="hexo-github自动部署页面" /></p><h2 id="hexo主题"><a class="markdownIt-Anchor" href="#hexo主题"></a> #Hexo主题</h2><p>此博客使用主题为 <a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></p><p>你可以在hexo官网找到各种各样的博客主题：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><h2 id="github-actions自动发布博客"><a class="markdownIt-Anchor" href="#github-actions自动发布博客"></a> #GitHub Actions自动发布博客</h2><h3 id="github-actions"><a class="markdownIt-Anchor" href="#github-actions"></a> GitHub Actions</h3><p><code>GitHub Actions</code> 是一个持续集成和持续交付 (<code>CI/CD</code>) 平台，可用于自动执行构建、测试和部署管道。 我们可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。</p><h3 id="环境搭建-2"><a class="markdownIt-Anchor" href="#环境搭建-2"></a> 环境搭建</h3><ul><li>私有Hexo源码仓库：<code>blog-source</code></li><li><code>Github</code>公共静态页面仓库：<code>MyBlog</code></li></ul><h4 id="密钥配置"><a class="markdownIt-Anchor" href="#密钥配置"></a> 密钥配置</h4><ol><li><p>生成ssh密钥对</p><p>执行命令：<code>ssh-keygen -f blog-source-key -t rsa -C &quot;username@example.com&quot;</code>，邮箱是GitHub绑定邮箱。<font style="color:red"><strong>Enter passphrase时不要键入，直接回车！</strong></font>命令执行后会生成两个文件：<code>blog-source-key</code>(私钥) 和 <code>blog-source-key.pub</code>(公钥)</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/ssh%E5%AF%86%E9%92%A5.jpg" alt="ssh密钥" /></p></li><li><p>添加公钥至公共静态页面仓库</p><p><code>MyBlog</code>仓库&gt;<code>Settings</code>&gt; <code>Deploy keys</code>&gt; <code>Add deploy key</code></p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E5%85%AC%E9%92%A5%E9%85%8D%E7%BD%AE.png" alt="公钥配置" /></p><p><code>Title</code>只要符合规范都可以，<code>Key</code>值填<code>blog-source-key.pub</code>中的内容，<font style = "color:red">需要勾选Allow write access！</font></p></li><li><p>添加私钥到博客源码仓库中</p><p><code>blog-source</code>仓库&gt;<code>Settings</code>&gt;<code>Secrets</code>&gt;<code>Actions</code>&gt;<code>New repository secret</code></p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E7%A7%81%E9%92%A5%E9%85%8D%E7%BD%AE.png" alt="私钥配置" /></p><p>同公钥配置<code>Name</code>只要符合规范任意命名，<code>Secret</code>填<code>helloworld-key</code>中的内容</p></li><li><p>添加Gitee 账号密码到博客源码仓库中，同私钥配置，<code>Name</code>按规范命名<code>Secret</code>填gitee密码。</p></li></ol><h4 id="配置github-actions"><a class="markdownIt-Anchor" href="#配置github-actions"></a> 配置GitHub Actions</h4><p>在博客源码仓库中编写<code>workflow</code>文件，创建<code>.github</code>&gt;<code>workflow</code>&gt;<code>deploy.yml</code>文件在仓库根目录，<code>yaml</code>文件可以任意命名。</p><p><code>deploy.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">deploy</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">paths-ignore:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;.github/**&#x27;</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">A</span> <span class="hljs-string">job</span> <span class="hljs-string">to</span> <span class="hljs-string">deploy</span> <span class="hljs-string">blog.</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v1</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">submodules:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">node</span> <span class="hljs-string">modules</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v1</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">cache</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>        <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          $&#123;&#123; runner.os &#125;&#125;-node-</span><br><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>      <span class="hljs-attr">if:</span> <span class="hljs-string">steps.cache.outputs.cache-hit</span> <span class="hljs-type">!=</span> <span class="hljs-string">&#x27;true&#x27;</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">ci</span><br><br>    <span class="hljs-comment"># Deploy hexo blog website.</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>      <span class="hljs-attr">id:</span> <span class="hljs-string">deploy</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">sma11black/hexo-action@v1.0.4</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-comment"># 用于访问 GitHub 静态页面仓库的部署密钥（私钥）。</span><br>        <span class="hljs-attr">deploy_key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.BLOG_SOURCE</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-comment"># 用于部署的 github 帐户的用户名。</span><br>        <span class="hljs-attr">user_name:</span> <span class="hljs-string">C1thulhu</span><br>        <span class="hljs-comment"># 用于部署的 github 帐户的用户电子邮件。</span><br>        <span class="hljs-attr">user_email:</span> <span class="hljs-number">1841103203</span><span class="hljs-string">@qq.com</span><br>        <span class="hljs-attr">commit_msg:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">github.event.head_commit.message</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Get</span> <span class="hljs-string">the</span> <span class="hljs-string">output</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        echo &quot;$&#123;&#123; steps.deploy.outputs.notify &#125;&#125;&quot;</span><br><span class="hljs-string"></span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
      <category>git</category>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>hexo</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git详解</title>
    <link href="/helloworld/notes/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E8%AF%A6%E8%A7%A3/"/>
    <url>/helloworld/notes/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><a href="https://www.pdai.tech/md/devops/tool/tool-git.html">Git详解</a></li><li><a href="https://www.cnblogs.com/1050619969kong/p/15612577.html">git详解–原理及常用操作 </a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰：Git 教程</a></li><li><a href="https://learngitbranching.js.org/">git在线学习网站</a></li></ul><h2 id="git介绍"><a class="markdownIt-Anchor" href="#git介绍"></a> #git介绍</h2><p><font style="color:red"><strong>git是一个分布式版本控制系统，因此git的操作大部分都是在本地。</strong></font>每个git项目的根目录下都有一个.git目录，它是git默默进行版本控制时读写的“数据库”。有几个概念需要提一下：</p><ul><li>工作区：代码所在的目录，就是自己电脑中能够看到的目录</li><li>暂存区：又称stage或者index。一般存放在.git/index文件中，所以我们把暂存区也叫作索引index</li><li>本地库：又称repository，此目录内的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”</li><li>远程库：远程库是指的代码托管平台上的库，是为不同开发者之间协同开发而存在的。</li></ul><h2 id="代码托管平台"><a class="markdownIt-Anchor" href="#代码托管平台"></a> #代码托管平台</h2><p>常用的git代码托管平台主要有github、gitlab和gitee，它们都是基于git实现的在线代码托管仓库。</p><ul><li><p>github，有私有仓库和公有仓库之分，私有仓库需要收费。</p></li><li><p>gitlab</p><p>gitlab 让开发者对他们的代码仓库拥有更多的控制权，相对于github：</p><ol><li>允许免费设置仓库权限</li><li>允许用户选择分享一个project的部分代码</li><li>允许用户设置project的获取权限</li><li>可以设置获取到团队整体的改进进度</li><li>通过innersourcing 让不在权限范围内的人访问不到该资源</li></ol></li><li><p>gitee，由开源中国社区推出的基于git的代码托管服务平台</p></li></ul><p>通常我们使用git都会用到图形化工具一方面简化了使用git命令的操作，另一方面提高了工作效率。<br />常用的git图形化工具有<code>GitHub for Desktop</code>，<code>TortoiseGit</code>，<code>Source Tree</code>等。</p><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> #配置</h2><p><code>git config</code>是关于配置操作命令，我们可以通过<code>git config --list</code>查看配置项，git中配置文件主要分为三个级别：</p><ul><li><p>仓库级</p><p>在所创建仓库下 的<code>.git</code>文件夹下的<code>config</code>文件就是本地配置文件。我们可以使用<code>git config --loacl</code>来读写此文件，仓库级配置文件是优先级最高的。</p></li><li><p>用户级</p><p>在Linux系统中，用户级配置文件路径是<code>~/.gitconfig</code>或 <code>~/.config/git/config</code>两种情况，Windows中路径是<code>C:\Users\$USER\.gitconfig</code>。可以使用传递 <code>git config --global</code>来读写此文件，其优先级仅此于仓库级配置文件。</p></li><li><p>系统级</p><p>在 Git 应用安装目录下 /etc/gitconfig 文件，包含系统上每一个用户及他们仓库的通用配置。使用 <code>git config --system</code> 就能读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</p></li></ul><p>查看所有的配置以及它们所在的文件：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git config --list --show-origin<br></code></pre></div></td></tr></table></figure><h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> #常用命令</h2><h3 id="版本库"><a class="markdownIt-Anchor" href="#版本库"></a> 版本库</h3><p>版本库又名仓库(<strong>repository</strong>)，<font style="color:red">这个库里的所有文件都可以被 git 管理，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在 回退 到某个时刻</font>。</p><ul><li><p>创建</p><p>创建方式1：</p><ol><li><p>版本库在目录文件夹下使用**<code>git init</code>可以创建本地仓库**</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git init<br>Initialized empty Git repository <span class="hljs-keyword">in</span> D:\MyRepository<br></code></pre></div></td></tr></table></figure><p>git会提示你在该路径下创建了一个空的git仓库，而且会生成一个<code>.git</code>目录<font style="color:#00FFFF">(该目录默认是隐藏的)</font>，是git用来跟踪管理版本库的。</p><p>创建本地库后，还需要用<code>git add .</code> <code>git commit -m &quot;desc&quot;</code>才能初始化。</p></li><li><p>使用<code>git remote add origin &lt;远程仓库url&gt;</code>命令将本地库关联远程库。</p></li><li><p>然后用<code>git branch -M &lt;远程仓库主分支名&gt;</code>先统一和远程仓库主分支相同的新的本地分支名</p></li><li><p>第一次还要先拉取远程库中的README.md和.gitignore等文件<code>git pull origin &lt;分支名&gt;</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git pull notes master<br>From https://github.com/C1thulhu/notes<br> * branch            master     -&gt; FETCH_HEAD<br>fatal: refusing to merge unrelated histories<br></code></pre></div></td></tr></table></figure><p>如果拉取报错<code>refusing to merge unrelated histories</code>，意味着本地库已存在的内容与远程库有差异，可以通过<code>git pull origin &lt;分支名&gt; --allow-unrelated-histories</code>来解决。</p></li><li><p><code>git status</code>查询代码拉取是否成功，<code>git branch -a</code>查询本地分支。</p></li><li><p>最后使用<code>git push --set-upstream origin master</code>命令绑定远程库。</p></li></ol><p>创建方式2：</p><ol><li>在github之类的代码托管平台上创建库。</li><li>使用<code>git clone &lt;远程仓库url&gt;</code>从远端拉取到本地。</li></ol></li></ul><h3 id="提交同步"><a class="markdownIt-Anchor" href="#提交同步"></a> 提交&amp;同步</h3><p>提交代码通常需要三步：</p><ol><li>将增删改的文件通过<code>git add</code>变为<strong>暂存状态</strong></li><li>使用<code>git commit</code>，将修改内容提交到本地库</li><li>最后使用<code>git push</code>将本地库推提交到远程仓库</li></ol><p>注意！如果是多人开发时要注意在使用<code>git push</code>命令之前先用<code>git pull</code>以防止出现将别人修改的代码覆盖的情况。<br />其次！<code>git commit -m &quot;msg&quot;</code>中<code>-m</code>是指本次提交的说明，最好是有意义的，比如修改了什么bug或者更新的什么功能，这是开发人员应有的规范。</p><p><code>git pull</code>同步命令是将远程库里的代码拉取到本地库，<font style="color:#00FFFF">最好在每次修改代码之前先用<code>git pull</code>拉取一遍，确保修改时本地库处于最新版本</font>。</p><p><strong>提交冲突</strong>是很常见的使用git时会发生的问题，冲突发现的原因主要是<font style="color:red">在合并文件时同一个文件的同一个位置已经被修改了，并且内容不同。</font></p><p>当冲突发生时，可以使用<code>git status</code>查看冲突文件，在文件中git会用</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>提交的代码<br>=======<br>他人修改的代码<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br></code></pre></div></td></tr></table></figure><p>的方式标注冲突，直接将<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>修改为正常的代码再次提交就可以解决冲突。<br />或者回退到之前版本。</p><h3 id="撤销回退"><a class="markdownIt-Anchor" href="#撤销回退"></a> 撤销&amp;回退</h3><ol><li><p>查看修改，</p><p><strong>查看工作区修改</strong>：<code>git diff</code> ，列出所有工作区的修改，后接相对路径可以查看该路径下的修改，如：<code>git diff xx/xx.java xx/xxx.java</code>列出某(几)个文件的修改</p><p><strong>查看暂存区修改</strong>：<code>git diff --cached</code>命令可以显示暂存区和本地仓库的差异</p><p><strong>查看本地库修改</strong>：<code>git diff master origin/master</code>查看本地仓库与本地远程仓库的差异</p><p><strong>查看远程库修改</strong>：<code>git log</code>查看提交记录</p></li><li><p>撤销</p><p><strong>工作区撤销</strong>，<code>git checkout</code>撤销未<code>git add</code>到暂存区的修改，后接<code>.</code>是针对当前文件夹下所有的修改，后接相对路径可以撤销某几个文件的修改。</p><p><code>git clean -f</code>撤销新增的文件；<code>git clean -df</code> 撤销新增的文件和文件夹。</p><p><strong>暂存区撤销</strong>，即已经执行过<code>git add</code>未执行<code>git commit</code></p><p><code>git reset</code>暂存区的修改恢复到工作区；<code>git reset --hard</code>回到未修改状态，清空暂存区和工作区。</p><p><strong>本地库撤销</strong>，即执行过<code>git commit</code>，但未使用<code>git push</code>提交到远程库</p><p><code>git reset --hard origin/master</code>回退到与本地远程仓库一致；<font style="color:yellow"><code>git reset --hard HEAD^</code><sup>1</sup></font>回退到本地仓库上一个版本，<font style="color:yellow"><code>git reset --hard &lt;hash code&gt;</code> <sup>2</sup></font>回退到任意版本。</p><p><font style="color:yellow">①：<code>HEAD</code>指向的就是指当前版本，<code>HEAD^</code>表示回退的方向，<code>HEAD~</code>表示回退的步数，比如：<code>git reset --hard HEAD^2~1</code>表示回退到第二分支的上一个版本。</font></p><p><font style="color:yellow">②：git每次提交到远程库都会有对应的hash值，相当于id用于区分每次提交记录，可以通过<code>git log</code>查询。</font></p><p><strong>远程库撤销</strong>，将本地库撤销到想回退的版本，然后再使用<code>git push -f orgin master</code>强制覆盖远程分支，如果本地库是关联着远程库可以省略分支名：<code>git push -f</code></p></li></ol><h3 id="分支"><a class="markdownIt-Anchor" href="#分支"></a> 分支</h3><p>  我们已经知道每次提交代码时git会把它们串成一条时间线，而这条时间线就是一个分支。git中存在一个主分支，即<code>master</code>分支，在主分支中会存在一个指针<code>master</code>指向当前最新版本，每次提交<code>master</code>分支都会前移一步。<br />  当创建一个分支时，Git新建了一个指针，假设这个指针叫<code>dev</code>，指向与<code>master</code>指针相同的节点，与<code>master</code>一样的每次提交<code>dev</code>会向前移一步，而<code>master</code>指针不动。<br />  我们每次提交时，本地也会有一个指针<code>HEAD</code>，指向本地当前版本，切换分支时就是将<code>HEAD</code>指针指向git的不同分支指针上，每次提交时<code>HEAD</code>和分支指针会一起移动。</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/git%E6%8C%87%E9%92%88.png" alt="git指针" /></p><ol><li><p>创建&amp;切换：</p><p>通过<code>git checkout -b dev</code>命令创建并切换到<code>dev</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git checkout -b dev<br>Switched to a new branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></div></td></tr></table></figure><p>它相当于<code>git branch dev</code>和<code>git checkout dev</code>两条命令。</p><p><code>git checkout &lt;分支名&gt;</code>虽然也能用于切换分支，但是却和撤销修改<code>git checkout -- &lt;file&gt;</code>是同一种命令。实际上<code>git switch</code>才是切换分支的正确命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建并切换到dev分支</span><br>$ git switch -c dev<br><span class="hljs-comment"># 直接切换到已有的master分支</span><br>$ git switch master<br></code></pre></div></td></tr></table></figure><p><code>git switch</code>是git自2.23版本更新才提供的新命令，它的使用比<code>git checkout</code>要更容易熟悉git分支操作。</p></li><li><p>查看分支：</p><p><code>git branch</code>命令可以查看所有分支，由<code>*</code>号标注的代表是当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git branch<br>* dev<br>  master<br></code></pre></div></td></tr></table></figure></li><li><p>合并分支：</p><p><code>git merge</code>命令用于合并指定分支到当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git merge dev<br>Updating d46f35e..b17d20e<br>Fast-forward<br> readme.txt | 1 +<br> 1 file changed, 1 insertion(+)<br></code></pre></div></td></tr></table></figure><p>合并后，会提示修改了哪些文件，同时还会提示合并的方式，上述示例提示是<font style="color:red"><strong><code>Fast-forward</code>模式，这种模式下合并也称作“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。，删除分支后，会丢掉分支信息，</strong></font>。通过<code>git log --graph --pretty=oneline --abbrev-commit</code>查看提交记录会发现和正常提交没什么区别，但是和直接在<code>master</code>分支上工作更安全。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit<br>* 178657f (HEAD -&gt; master, notes/dev, dev) branch push <span class="hljs-built_in">test</span><br>* 4980d79 (notes/master) init my notes<br></code></pre></div></td></tr></table></figure><p>我们可以使用<code>--no-ff</code>方式的<code>git merge</code>，表示禁用<code>Fast-forward</code>模式：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git merge --no-ff -m <span class="hljs-string">&quot;merge with no-ff&quot;</span> dev<br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> readme.txt | 1 +<br> 1 file changed, 1 insertion(+)<br></code></pre></div></td></tr></table></figure><p>这时我们会发现禁用<code>Fast-forward</code>模式的提交记录会有区别：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit<br>*   ba8a543 (HEAD -&gt; master) merge with no-ff<br>|\<br>| * fef1d39 (notes/dev, dev) no Fast forward merge <span class="hljs-built_in">test</span><br>|/<br>* 178657f branch push <span class="hljs-built_in">test</span><br></code></pre></div></td></tr></table></figure><p>当<code>master</code>分支和<code>dev</code>分支都有了各自的提交时，合并的时候不会以<code>Fast-forward</code>模式方式，只能试图把各自的修改合并起来，但这种合并很可能会有冲突，比如<code>master</code>分支和<code>dev</code>分支的同一段代码都有不同的改动时。</p><p>这时必须手动解决冲突，同正常冲突一样用<code>git status</code>查看冲突位置，再将被git<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标注的冲突代码修改后在提交就可以了。</p><p><code>git log --graph</code>可以查看完整分支合并图。</p><ul><li><p>Bug分支</p><p>每个Bug都可以通过一个新的临时分支来修复，修复后再将临时分支删除，这样就可以不影响主分支的开发工作。</p></li><li><p>Feature分支</p><p>添加一个新功能时，最好新建一个feature分支，可以与主分支隔离，互不干扰</p></li></ul></li><li><p>删除分支：</p><p>有时合并后需要删除已经合并的分支，我们可以通过<code>git branch -d &lt;分支名&gt;</code>删除分支：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git branch -d dev<br>Deleted branch dev (was b17d20e).<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> #扩展</h2><h3 id="github-actions"><a class="markdownIt-Anchor" href="#github-actions"></a> Github Actions</h3>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaIO</title>
    <link href="/helloworld/notes/Java/API/JavaIO/"/>
    <url>/helloworld/notes/Java/API/JavaIO/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><p><a href="https://www.runoob.com/java/java-file.html">Java File</a></p></li><li><p><a href="https://blog.kyire.site/2021/04/04/13a54546.html">Java-IO流</a></p></li><li><p><a href="http://www.yiidian.com/java-io/what-is-java-io.html">Java IO流教程（一点教程）</a></p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945227202752">廖雪峰的官方网站-IO</a></p></li><li><p><a href="https://blog.csdn.net/weixin_32265569/article/details/108355392">设计模式—装饰者模式</a></p></li><li><p><a href="https://blog.csdn.net/weixin_51712663/article/details/124562360">io流详细解读</a></p></li><li><p><a href="https://blog.csdn.net/K_520_W/article/details/123389551">java之BIO简介</a></p></li></ul><h2 id="file"><a class="markdownIt-Anchor" href="#file"></a> #File</h2><p>Java的标准库<code>java.io</code>提供了<code>File</code>对象来操作文件和目录。<font style="color:#00FFFF">File 类不能访问文件内容本身，如果需要访问文件内容本身，则需要使用输入/输出流。</font></p><p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。<font style="color:yellow">注意Windows平台使用<code>\</code>作为路径分隔符，在Java字符串中需要用<code>\\</code>表示一个<code>\</code>。Linux平台使用<code>/</code>作为路径分隔符。</font>例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Window平台</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Windows\\test.text&quot;</span>);<br><span class="hljs-comment">//Linux平台</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/usr/bin/test.text&quot;</span>);<br><br><span class="hljs-comment">//相对路径(假设当前目录为&quot;C:\Windows&quot;) .表示当前目录 ..表示上级目录</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;docs\\Test.text&quot;</span>);    <span class="hljs-comment">//绝对路径是 C:\Windowsdocs\Test.text</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;.\\docs\\Test.text&quot;</span>); <span class="hljs-comment">//绝对路径是 C:\Windowsdocs\Test.text</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;..\\Downloads&quot;</span>);      <span class="hljs-comment">//绝对路径是 C:\Downloads</span><br></code></pre></div></td></tr></table></figure><p>File方法归类：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">String getName()</td><td style="text-align:center">返回由此抽象路径名表示的文件或目录的名称</td><td style="text-align:center">void deleteOnExit()</td><td style="text-align:center">在虚拟机终止时，请求删除此抽象路径名表示的文件或目录</td></tr><tr><td style="text-align:center">String getParent()</td><td style="text-align:center">获取当前路径下父路径名则返回，没有则返回null</td><td style="text-align:center">String[] list()</td><td style="text-align:center">获取当前路径下的目录中的所有文件和目录的名称</td></tr><tr><td style="text-align:center">File getParentFile()</td><td style="text-align:center">获取当前路径下的父级目录，没有则返回null</td><td style="text-align:center">String[] list(FilenameFilter filter)</td><td style="text-align:center">满足指定过滤器的当前路径下的目录中的所有文件和目录的名称</td></tr><tr><td style="text-align:center">String getPath()</td><td style="text-align:center">将此路径名转换为一个路径名字符串</td><td style="text-align:center">File[] listFiles()</td><td style="text-align:center">获取当前路径下目录中的文件和目录的路径</td></tr><tr><td style="text-align:center">boolean isAbsolute()</td><td style="text-align:center">是否为绝对路径名</td><td style="text-align:center">File[] listFiles(FileFilter filter)</td><td style="text-align:center">满足指定过滤器的当前路径下目录中的文件和目录的路径</td></tr><tr><td style="text-align:center">String getAbsolutePath()</td><td style="text-align:center">获取绝对路径名</td><td style="text-align:center">boolean mkdir()</td><td style="text-align:center">创建此路径名指定的目录</td></tr><tr><td style="text-align:center">boolean canRead()</td><td style="text-align:center">是否可以读取此路径名表示的文件</td><td style="text-align:center">boolean mkdirs()</td><td style="text-align:center">创建此路径名指定的目录，包括必需但不存在的父目录</td></tr><tr><td style="text-align:center">boolean canWrite()</td><td style="text-align:center">是否可以修改此路径名表示的文件</td><td style="text-align:center">boolean renameTo(File dest)</td><td style="text-align:center">重新命名当前路径名表示的文件。</td></tr><tr><td style="text-align:center">boolean exists()</td><td style="text-align:center">文件或目录是否存在</td><td style="text-align:center">boolean setLastModified(long time)</td><td style="text-align:center">设置由此路径名所指定的文件或目录的最后一次修改时间</td></tr><tr><td style="text-align:center">boolean isDirectory()</td><td style="text-align:center">是否是一个目录</td><td style="text-align:center">boolean setReadOnly()</td><td style="text-align:center">标记此路径名指定的文件或目录，以便只可对其进行读操作</td></tr><tr><td style="text-align:center">boolean isFile()</td><td style="text-align:center">是否是一个标准文件</td><td style="text-align:center">static File createTempFile(String prefix, String suffix, File directory)</td><td style="text-align:center">在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称</td></tr><tr><td style="text-align:center">long lastModified()</td><td style="text-align:center">获取此路径名表示的文件最后一次被修改的时间</td><td style="text-align:center">static File createTempFile(String prefix, String suffix)</td><td style="text-align:center">在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称</td></tr><tr><td style="text-align:center">long length()</td><td style="text-align:center">获取此路径名表示的文件的长度</td><td style="text-align:center">int compareTo(File pathname)</td><td style="text-align:center">按字母顺序比较两个抽象路径名</td></tr><tr><td style="text-align:center">boolean createNewFile()</td><td style="text-align:center">当且仅当不存在具有此路径名指定的名称的文件时，原子地创建由此路径名指定的一个新的空文件</td><td style="text-align:center">int compareTo(Object o)</td><td style="text-align:center">按字母顺序比较抽象路径名与给定对象</td></tr><tr><td style="text-align:center">boolean delete()</td><td style="text-align:center"></td><td style="text-align:center">boolean equals(Object obj)</td><td style="text-align:center">测试此抽象路径名与给定对象是否相等</td></tr><tr><td style="text-align:center">String toString()</td><td style="text-align:center">此路径名的路径名字符串</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="io"><a class="markdownIt-Anchor" href="#io"></a> #IO</h2><p><font style="color:red">Java I/O（输入和输出）用于处理输入并产生输出，Java使用<code>Stream</code>(流)的概念来加快I/O操作的速度。</font>java.io软件包包含输入和输出操作所需的所有类。我们可以通过Java I/O API 在Java中执行文件处理。</p><p><font style="color:#00FFFF"><code>Stream</code>是数据序列。在Java中，流由字节组成。之所以称其为流，是因为它就像不断流动的水流一样。</font></p><p><font style="color:yellow">在Java中，会自动为我们创建3个流。所有这些流都随控制台附带。</font></p><ul><li><font style="color:yellow">System.out：标准输出流</font></li><li><font style="color:yellow"><a href="http://System.in">System.in</a>：  标准输入流</font></li><li><font style="color:yellow">System.err：标准错误流</font></li></ul><p>IO流可以根据处理数据类型的不同分为：字符流和字节流，或数据流向不同分为：输入流和输出流。</p><table><thead><tr><th style="text-align:center"><strong>分类</strong></th><th style="text-align:center"><strong>字节输入</strong></th><th style="text-align:center"><strong>字节输出</strong></th><th style="text-align:center"><strong>字符输入</strong></th><th style="text-align:center"><strong>字符输出</strong></th></tr></thead><tbody><tr><td style="text-align:center">抽象基类</td><td style="text-align:center">InputStream</td><td style="text-align:center">OutputStream</td><td style="text-align:center">Reader</td><td style="text-align:center">Writer</td></tr><tr><td style="text-align:center">访问文件</td><td style="text-align:center">FileInputStream</td><td style="text-align:center">FileOutputStream</td><td style="text-align:center">FileReader</td><td style="text-align:center">FileWriter</td></tr><tr><td style="text-align:center">访问数组</td><td style="text-align:center">ByteArrayInputStream</td><td style="text-align:center">ByteArrayOutputStream</td><td style="text-align:center">CharArrayReader</td><td style="text-align:center">CharArrayWriter</td></tr><tr><td style="text-align:center">访问管道</td><td style="text-align:center">PipedInputStream</td><td style="text-align:center">PipedOutputStream</td><td style="text-align:center">PipedReader</td><td style="text-align:center">PipedWriter</td></tr><tr><td style="text-align:center">访问字符串</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">StringReader</td><td style="text-align:center">StringWriter</td></tr><tr><td style="text-align:center">缓存流</td><td style="text-align:center">BufferedInputStream</td><td style="text-align:center">BufferedOutputStream</td><td style="text-align:center">BufferedReader</td><td style="text-align:center">BufferedWriter</td></tr><tr><td style="text-align:center">转换流</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">InputStreamReader</td><td style="text-align:center">OutputStreamReader</td></tr><tr><td style="text-align:center">对象流</td><td style="text-align:center">ObjectInputStream</td><td style="text-align:center">ObjectOutputStream</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">过滤流</td><td style="text-align:center">FilterInputStream</td><td style="text-align:center">FilterOutputStream</td><td style="text-align:center">FilterReader</td><td style="text-align:center">FilterWriter</td></tr><tr><td style="text-align:center">打印流</td><td style="text-align:center"></td><td style="text-align:center">PrintStream</td><td style="text-align:center"></td><td style="text-align:center">PrintWriter</td></tr><tr><td style="text-align:center">推回输入流</td><td style="text-align:center">PushbackInputStream</td><td style="text-align:center"></td><td style="text-align:center">PushbackInputReader</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">特殊流</td><td style="text-align:center">DataInputStream</td><td style="text-align:center">DataOutputStream</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">序列流</td><td style="text-align:center">SequenceInputStream</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>InputStream示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * InputStream使用示例：</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        input = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/test.txt&quot;</span>);<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-keyword">while</span> ((n = input.read()) != -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 利用while同时读取并判断</span><br>            System.out.println(n);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (input != <span class="hljs-literal">null</span>) &#123; input.close(); &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 用try ... finally来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的try(resource)的语法，</span><br><span class="hljs-comment"> * 只需要编写try语句，让编译器自动为我们关闭资源 如下：</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/test.txt&quot;</span>)) &#123;<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-keyword">while</span> ((n = input.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(n);<br>        &#125;<br>    &#125; <span class="hljs-comment">//编译器在此自动为我们写入finally并调用close()</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>  <font style="color:red">实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</font></p><h3 id="装饰者模式"><a class="markdownIt-Anchor" href="#装饰者模式"></a> 装饰者模式</h3><p><font style="color:red"><strong>装饰模式（Decorator）</strong>，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更灵活。<br /></font><br /><font style="color:grey">详细了解转至<a href="https://blog.csdn.net/weixin_32265569/article/details/108355392">设计模式—装饰者模式</a></font>，下文也会详细指出io中运用的装饰者模式。</p><p><strong>初计初衷：</strong></p><p>通常可以使用继承来实现功能的扩展，<font style="color:#00FFFF">如果这些需要扩展的功能的种类很繁多，那么继承势必生成很多子类，增加系统的复杂性；同时使用继承实现功能拓展，我们必须可预见这些拓展功能，这些功能是编译时就确定了的，是静态的。</font></p><h3 id="inputstream"><a class="markdownIt-Anchor" href="#inputstream"></a> Inputstream</h3><p><code>InputStream</code>就是Java标准库提供的最基本的输入流，抽象类<code>InputStream</code>中重要方法设计如下：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">abstract int read()</td><td style="text-align:center">读取下一个字节，如果没有则返回-1</td></tr><tr><td style="text-align:center">int read(byte b[])</td><td style="text-align:center">将读取到的数据放在 byte 数组中，该方法实际上调用read(byte b[], int off, int len)方法</td></tr><tr><td style="text-align:center">int read(byte b[], int off, int len)</td><td style="text-align:center">从第 off 位置读取<b>最多(实际可能小于)</b> len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的; 此方法会一直阻止，直到输入数据可用、检测到stream结尾或引发异常为止。</td></tr><tr><td style="text-align:center">void close()</td><td style="text-align:center">读取完，关闭流，释放资源</td></tr><tr><td style="text-align:center">long skip(long n)</td><td style="text-align:center">跳过指定个数的字节不读取</td></tr><tr><td style="text-align:center">int available()</td><td style="text-align:center">返回可读的字节数量</td></tr><tr><td style="text-align:center">synchronized void reset()</td><td style="text-align:center">重置读取位置为上次 mark 标记的位置</td></tr><tr><td style="text-align:center">synchronized void mark(int readlimit)</td><td style="text-align:center">标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断</td></tr><tr><td style="text-align:center">boolean markSupported()</td><td style="text-align:center">判断当前流是否支持标记流，和上面两个方法配套使用</td></tr><tr><td style="text-align:center">byte[] readAllBytes()</td><td style="text-align:center">JDK9新增：读取 InputStream 中的所有剩余字节，调用readNBytes(Integer.MAX_VALUE)方法</td></tr><tr><td style="text-align:center">int readNBytes(byte[] b, int off, int len)</td><td style="text-align:center">JDK9新增：从输入流读取请求的字节数并保存在byte数组中； 此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</td></tr><tr><td style="text-align:center">long transferTo(OutputStream out)</td><td style="text-align:center">JDK9新增：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中</td></tr><tr><td style="text-align:center">byte[] readNBytes(int len)</td><td style="text-align:center">JDK11更新：读取 InputStream 中的剩余字节的指定上限大小的字节内容；此方法会一直阻塞，直到读取了请求的字节数、检测到流结束或引发异常为止。此方法不会关闭输入流。</td></tr></tbody></table><p>InputStream及其派生类实现关系：</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/io-inputstream.png" alt="io-inputstream" /></p><h4 id="fileinputstream"><a class="markdownIt-Anchor" href="#fileinputstream"></a> FileInputStream</h4><p><strong>FileInputStream</strong>：从文件系统中的文件获取输入字节，获取的文件可用性取决于主机环境。</p><p><strong>构造方法：</strong></p><ol><li>FileInputStream(String name)</li></ol><p>通过打开与实际文件的连接来创建 FileInputStream ，该文件由文件系统中的路径名 name命名。</p><ol start="2"><li>FileInputStream(File file)</li></ol><p>通过打开与实际文件的连接来创建 FileInputStream ，该文件由文件系统中的 File对象 file命名。</p><ol start="3"><li>FileInputStream(FileDescriptor ds)</li></ol><p>使用文件描述符 fdObj创建 FileInputStream ，该文件描述符表示与文件系统中实际文件的现有连接。</p><p><strong>特点：</strong></p><p><font style="color:#00FFFF">FileInputStream 多用于读取诸如图像数据之类的原始字节流。使用其中<code>read()</code>方法读取中文会乱码（3字节），而使用<code>read(byte[] b)</code>方法并且不是截断读取才不会乱码。</font></p><h4 id="filterinputstream"><a class="markdownIt-Anchor" href="#filterinputstream"></a> FilterInputStream</h4><p>过滤输入流的主要功能是为基础流提供一些额外的功能。对FilterInputStream来说,常见的子类有BufferedInputStream，PushBackInputStream以及DataInputStream等，其子类总结为:</p><ul><li><p>BufferedInputStream</p><p><font style="color:red">缓冲输入流，由于基础输入流一个字节一个字节读取，频繁与磁盘进行交互，造成读取速度较低。缓冲流的存在就是先将数据读取到缓冲流(内存中)，然后一次性从内存中读取多个字符。提高读取的效率。</font></p></li><li><p>PushbackInputStream</p><p><font style="color:red">回退输入流，java中读取数据的方式是顺序读取，如果某个数据不需要读取，需要程序处理。PushBackInputStream就可以将某些不需要的数据回退到缓冲中。</font></p></li><li><p>DataInputStream</p><p><font style="color:red">数据输入流，以机器无关的方式读取Java的基本类型。</font></p></li></ul><p>FilterInputStream是io流中装饰者模式的主要体现：</p><p>以<code>BufferedInputStream</code>举例，当<code>FileInputStream</code>需要额外实现一个缓冲功能，就可以直接将<code>FileInputStream</code>传入<code>BufferedInputStream</code>的有参构造方法中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/test.txt&quot;</span>));<br></code></pre></div></td></tr></table></figure><p>而BufferedInputStream继承自FilterInputStream，构造方法也是直接将传入的<code>InputStream</code>赋给父类，</p><p>BufferedInputStream构造方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>(in, DEFAULT_BUFFER_SIZE);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">super</span>(in);<br>        <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>        &#125;<br>        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[size];<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>FilterInputStream构造方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStream</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> InputStream in;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">FilterInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总的来说，JDK首先将<code>InputStream</code>分为两大类：</p><p>一类是直接提供数据的基础<code>InputStream</code>，如FileInputStream、ObjectInputStream等，另一类是提供额外附加功能都继承自FilterInputStream的<code>InputStream</code>，如BufferedInputStream、DataInputStream等；当需要给InputStream附加额外的功能时，将需要增强的InputStream传给提供额外附加功能<code>InputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//给FileInputStream附加缓冲功能</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/test.txt&quot;</span>));<br><br><span class="hljs-comment">//可以给InputStream附加多个功能</span><br><span class="hljs-type">PushbackInputStream</span> <span class="hljs-variable">pushbackInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushbackInputStream</span>(bufferedInputStream);<br></code></pre></div></td></tr></table></figure><h4 id="pipedinputstream"><a class="markdownIt-Anchor" href="#pipedinputstream"></a> PipedInputStream</h4><p>java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流，使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用</p><blockquote><p>大致流程：<br />我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；线程B通过读取PipedInputStream中的数据。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//使用connect方法连接PipedInputStream与PipedOutputStream方式</span><br>PipedInputStream pipedInputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PipedInputStream</span>();<br>PipedOutputStream pipedOutputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PipedOutputStream</span>();<br><span class="hljs-keyword">try</span> &#123;<br>pipedInputStream.connect(pipedOutputStream);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>pipedInputStream.connect(pipedOutputStream)</code>或者<code>pipedOutputStream.connect(pipedInputStream)</code>效果是一样的，但是要注意 <strong>只能选择其中的一个而不能两个connect同时调用</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//不使用connect方法连接PipedInputStream与PipedOutputStream方式</span><br>PipedInputStream pipedInputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PipedInputStream</span>();<br>PipedOutputStream pipedOutputStream=<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>pipedOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PipedOutputStream</span>(pipedInputStream);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><font style='color:red'><strong>在一个线程里使用PipedInpuStream和PipedOutputStream会造成死锁。</strong></font></p><h3 id="reader"><a class="markdownIt-Anchor" href="#reader"></a> Reader</h3><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">int read()</td><td style="text-align:center">读取下一个字节，如果没有则返回-1</td></tr><tr><td style="text-align:center">int read(char cbuf[])</td><td style="text-align:center">将读取到的数据放在 char 数组中，该方法实际上调用read(char cbuf[], int off, int len)方法</td></tr><tr><td style="text-align:center">int read(java.nio.CharBuffer target)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">int read(char cbuf[], int off, int len)</td><td style="text-align:center">从第 off 位置读取<b>最多(实际可能小于)</b> len 长度字节的数据放到 char 数组中，流是以 -1 来判断是否读取结束的; 此方法会一直阻止，直到输入数据可用、检测到stream结尾或引发异常为止。</td></tr><tr><td style="text-align:center">long skip(long n)</td><td style="text-align:center">跳过指定个数的字符不读取</td></tr><tr><td style="text-align:center">boolean ready()</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">void reset()</td><td style="text-align:center">重置读取位置为上次 mark 标记的位置</td></tr><tr><td style="text-align:center">void mark(int readAheadLimit)</td><td style="text-align:center">标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断</td></tr><tr><td style="text-align:center">boolean markSupported()</td><td style="text-align:center">判断当前流是否支持标记流，和上面两个方法配套使用</td></tr><tr><td style="text-align:center">void close()</td><td style="text-align:center">读取完，关闭流，释放资源</td></tr></tbody></table><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/io-reader.png" alt="io-reader" /></p><h4 id="inputstreamreader"><a class="markdownIt-Anchor" href="#inputstreamreader"></a> InputStreamReader</h4><ul><li>FileReader</li></ul><h4 id="filterreader"><a class="markdownIt-Anchor" href="#filterreader"></a> FilterReader</h4><ul><li>PushbackReader</li></ul><h4 id="bufferedreader"><a class="markdownIt-Anchor" href="#bufferedreader"></a> BufferedReader</h4><ul><li>LineNumberReader</li></ul><h3 id="outputstream"><a class="markdownIt-Anchor" href="#outputstream"></a> Outputstream</h3><p>与<code>InputStream</code>相反，<code>OutputStream</code>是Java标准库提供的最基本的输出流，抽象类OutputStream中重要方法设计如下：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">abstract void write(int b)</td><td style="text-align:center">写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。</td></tr><tr><td style="text-align:center">void write(byte b[])</td><td style="text-align:center">将数组中的所有字节写入，实际调用的是write(byte b[], int off, int len)方法。</td></tr><tr><td style="text-align:center">void write(byte b[], int off, int len)</td><td style="text-align:center">将 byte 数组从 off 位置开始，len 长度的字节写入</td></tr><tr><td style="text-align:center">void flush()</td><td style="text-align:center">强制刷新，将缓冲中的数据写入; 默认是空实现，供子类覆盖</td></tr><tr><td style="text-align:center">void close()</td><td style="text-align:center">关闭输出流，流被关闭后就不能再输出数据了; 默认是空实现，供子类覆盖</td></tr></tbody></table><p>OutputStream及其派生类实现关系：</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/io-outputstream.png" alt="img" /></p><h4 id="fileoutputstream"><a class="markdownIt-Anchor" href="#fileoutputstream"></a> FileOutputStream</h4><p><strong>FileOutputStream</strong>：从文件系统中的文件获取输出字节，文件是否可用或能否可以被创建取决于基础平台，特别是某些平台一次只允许一个 FileOutputStream（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。</p><p><strong>构造方法：</strong></p><ol><li><p>FileOutputStream(String name)</p></li><li><p>FileOutputStream(String name, boolean append)</p></li><li><p>FileOutputStream(File file)</p></li><li><p>FileOutputStream(File file, boolean append)</p></li><li><p>FileOutputStream(FileDescriptor fdObj)</p><p>源码中构造方法中只有<code>FileOutputStream(FileDescriptor fdObj)</code>和其他构造方法不同，其他构造方法本质上都是调用了<code>FileOutputStream(File file, boolean append)</code>构造方法。</p></li></ol><p><strong>特点：</strong></p><p><font style="color:#00FFFF">在FileOutputStream中，append为true表示<font style="color:yellow"> 追加模式<sup>1</sup></font>，false为<font style="color:yellow"> 覆盖模式<sup>2</sup> </font>，默认false。</font></p><p><font style="color:yellow">①：追加模式是指写入时往文件原本内容中追加；</font></p><p><font style="color:yellow"> ②：覆盖模式是指写入文件时覆盖文件原本内容。</font></p><h4 id="filteroutputstream"><a class="markdownIt-Anchor" href="#filteroutputstream"></a> FilterOutputStream</h4><p>同<code>FilterInputStream</code>一样，<code>FilterOutputStream</code> 类本身只是简单地重写那些将所有请求传递给所包含输出流的 <code>OutputStream</code> 的所有方法。<code>FilterOutputStream</code> 的子类可进一步地重写这些方法中的一些方法，并且还可以提供一些额外的方法和字段。</p><ul><li><p>PrintStream</p></li><li><p>BufferedOutputStream</p><p><font style="color:red">缓冲输出流</font></p></li><li><p>DataOutputStream</p><p>允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型</p></li></ul><h3 id="writer"><a class="markdownIt-Anchor" href="#writer"></a> Writer</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">void write(int c)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">void write(char cbuf[])</td><td style="text-align:center">将数组中的所有字符写入，实际调用的是write(char cbuf[], int off, int len)方法。</td></tr><tr><td style="text-align:center">void write(String str)</td><td style="text-align:center">将数组中的所有字符串写入，实际调用的也是write(char cbuf[], int off, int len)方法。</td></tr><tr><td style="text-align:center">void write(char cbuf[], int off, int len)</td><td style="text-align:center">将 char 数组从 off 位置开始，len 长度的字节写入</td></tr><tr><td style="text-align:center">void flush()</td><td style="text-align:center">强制刷新，将缓冲中的数据写入; 默认是空实现，供子类覆盖</td></tr><tr><td style="text-align:center">void close()</td><td style="text-align:center">关闭输出流，流被关闭后就不能再输出数据了; 默认是空实现，供子类覆盖</td></tr><tr><td style="text-align:center">Writer append(CharSequence csq)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Writer append(CharSequence csq, int start, int end)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Writer append(char c)</td><td style="text-align:center"></td></tr></tbody></table><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/io-writer.png" alt="io-writer" /></p><h2 id="bio"><a class="markdownIt-Anchor" href="#bio"></a> #BIO</h2><p>BIO可以理解为<code>Block-io</code>(阻塞IO)，或是<code>Base-io</code>(基础IO)，BIO是<strong>同步并阻塞</strong>(传统阻塞型)的，服务器实现模式为<strong>一个连接一个线程</strong>，即客户端<strong>有连接请求</strong>时服务器端就需要<strong>启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销。</p><blockquote><ul><li>客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。</li><li>服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。</li></ul></blockquote><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/BIO.png" alt="BIO" /></p><ul><li><p>伪异步IO</p><p>当使用线程来处理BIO问题时：</p><ol><li>当服务器收到客户端的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端Y的请求。</li><li>客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式/观察模式(等其他设计模式)通知主线程。</li></ol><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E4%BC%AA%E5%BC%82%E6%AD%A5IO.png" alt="伪异步IO" /></p><p>伪异步IO局限性</p><ol><li>虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知accept()的方式还是单个的。<font style="color:red">服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来。</font></li><li><font style="color:red">创建一个线程是有较大的资源消耗的。</font>JVM创建一个线程的时候，即使这个线程不做任何的工作，JVM都会分配一个堆栈空间。这个空间的大小默认为128K（默认值可以通过-Xss参数调节），如果使用<code>ThreadPoolExecutor</code>线程池来缓解线程的创建问题，但是又会造成<code>BlockingQueue</code>积压任务的持续增加，同样消耗了大量资源。</li><li><font style="color:red">linux系统中，可以创建的线程是有限的。</font>通过<code>cat /proc/sys/kernel/threads-max</code>命令查看可以创建的最大线程数，虽然可以修改最大线程数，但是<font style="color:red">linux中线程越多，CPU切换所需时间越长</font>。</li></ol></li></ul><h2 id="nio"><a class="markdownIt-Anchor" href="#nio"></a> #NIO</h2><p><strong>同步非阻塞</strong>，服务器实现模式为<strong>一个线程处理多个请求</strong>(连接)，即客户端发送的连接请求都会注册到<strong>多路复用器</strong>上，多路复用器<strong>轮询</strong>到连接有I/O请求就进行处理</p><h2 id="aio"><a class="markdownIt-Anchor" href="#aio"></a> #AIO</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/helloworld/notes/Database/MySQL/"/>
    <url>/helloworld/notes/Database/MySQL/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><a href="https://www.pdai.tech/md/db/sql-lan/sql-lan.html">SQL语法基础</a></li><li><a href="https://www.runoob.com/mysql/mysql-tutorial.html">MySQL教程 | 菜鸟教程</a></li><li></li></ul><h2 id="mysql数据类型"><a class="markdownIt-Anchor" href="#mysql数据类型"></a> #MySQL数据类型</h2><h3 id="数值类型"><a class="markdownIt-Anchor" href="#数值类型"></a> 数值类型</h3><p>MySQL 支持所有标准 SQL 数值数据类型。</p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 bytes</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 bytes</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 bytes</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 bytes</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 bytes</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 bytes</td><td>单精度<br/>浮点数值</td></tr><tr><td>DOUBLE</td><td>8 bytes</td><td>双精度<br/>浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>小数值</td></tr></tbody></table><h3 id="时间类型"><a class="markdownIt-Anchor" href="#时间类型"></a> 时间类型</h3><p>表示时间值的时间类型有DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>DATE</td><td>3 bytes</td><td>日期值</td><td>YYYY-MM-DD</td></tr><tr><td>TIME</td><td>3 bytes</td><td>时间值或持续时间</td><td>HH:MM:SS</td></tr><tr><td>YEAR</td><td>1 bytes</td><td>年份值</td><td>YYYY</td></tr><tr><td>DATETIME</td><td>8 bytes</td><td>混合日期和时间值</td><td>YYYY-MM-DD hh:mm:ss</td></tr><tr><td>TIMESTAMP</td><td>4 bytes</td><td>混合日期和时间值，时间戳</td><td>YYYY-MM-DD hh:mm:ss</td></tr></tbody></table><h3 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h3><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">CHAR</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">定长字符串</td></tr><tr><td style="text-align:left">VARCHAR</td><td style="text-align:left">0-65535 bytes</td><td style="text-align:left">变长字符串</td></tr><tr><td style="text-align:left">TINYBLOB</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:left">TINYTEXT</td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">短文本字符串</td></tr><tr><td style="text-align:left">BLOB</td><td style="text-align:left">0-65 535 bytes</td><td style="text-align:left">二进制形式的长文本数据</td></tr><tr><td style="text-align:left">TEXT</td><td style="text-align:left">0-65 535 bytes</td><td style="text-align:left">长文本数据</td></tr><tr><td style="text-align:left">MEDIUMBLOB</td><td style="text-align:left">0-16 777 215 bytes</td><td style="text-align:left">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:left">MEDIUMTEXT</td><td style="text-align:left">0-16 777 215 bytes</td><td style="text-align:left">中等长度文本数据</td></tr><tr><td style="text-align:left">LONGBLOB</td><td style="text-align:left">0-4 294 967 295 bytes</td><td style="text-align:left">二进制形式的极大文本数据</td></tr><tr><td style="text-align:left">LONGTEXT</td><td style="text-align:left">0-4 294 967 295 bytes</td><td style="text-align:left">极大文本数据</td></tr></tbody></table><h2 id="sql基础语法"><a class="markdownIt-Anchor" href="#sql基础语法"></a> #SQL基础语法</h2><ul><li><p>创建</p><p>数据库的创建与使用</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE test;<br>USE test;<br></code></pre></div></td></tr></table></figure><p>表的创建</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table1 (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  col1 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,<br>  col2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NULL</span>,<br>  col3 <span class="hljs-type">DATE</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`));<br>  <br># 复制表，包括表结构和数据<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> newtable <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1;<br></code></pre></div></td></tr></table></figure></li><li><p>插入</p><p>普通插入</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table1(col1, col2)<br><span class="hljs-keyword">VALUES</span>(val1, val2);<br></code></pre></div></td></tr></table></figure><p>插入检索的数据</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table2(col1, col2)<br><span class="hljs-keyword">SELECT</span> col1, col2<br><span class="hljs-keyword">FROM</span> table1;<br></code></pre></div></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 使用更新和删除操作时一定要用 <span class="hljs-keyword">WHERE</span> 子句，不然会把整张表的数据都破坏。可以先用 <span class="hljs-keyword">SELECT</span> 语句进行测试，防止错误删除。<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br># <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 可以清空表，也就是删除所有行。<br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> table1;<br></code></pre></div></td></tr></table></figure></li><li><p>更新</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table1<br><span class="hljs-keyword">SET</span> col <span class="hljs-operator">=</span> val<br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 普通查询<br><span class="hljs-keyword">SELECT</span> col1,col2 <span class="hljs-keyword">FROM</span> table1;<br></code></pre></div></td></tr></table></figure><ul><li><strong>WHERE</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 尽量使用 <span class="hljs-keyword">SQL</span> 语句来过滤不必要的数据，如果数据非常大，会导致通过网络传输了多余的数据，从而浪费了网络带宽。<br><span class="hljs-keyword">SELECT</span> col1,col2 <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> col <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></div></td></tr></table></figure><p><strong>AND 和 OR</strong>  用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong>  操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong>  操作符用于否定一个条件。</p><p><strong>LIKE</strong>操作符用于模糊查询，对应的通配符：</p><p>  <strong>%</strong>  匹配 &gt;=0 个任意字符；</p><p>  <strong>_</strong>  匹配 ==1 个任意字符；</p><p>  <strong>[ ]</strong>  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 <strong>^</strong> 可以对其进行否定，也就是不匹配集合内的字符。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 匹配不以 A 和 B 开头的任意文本<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">WHERE</span> col <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;[^AB]%&#x27;</span>; <br></code></pre></div></td></tr></table></figure><ul><li><strong>DISTINCT</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 用于去重 相同值只会出现一次。对于多个列所有列的值都相同才算相同。<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> col1, col2<br><span class="hljs-keyword">FROM</span> table1;<br></code></pre></div></td></tr></table></figure><ul><li><strong>LIMIT</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 限制返回的行数。可以有两个参数，第一个参数为起始行，从 <span class="hljs-number">0</span> 开始;第二个参数为返回的总行数。<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> table1<br>LIMIT <span class="hljs-number">0</span>, <span class="hljs-number">5</span>;<br></code></pre></div></td></tr></table></figure><ul><li><strong>ORDER BY</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"># <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>可以对查询字段进行排序，并且为每个列指定不同的排序方式: <span class="hljs-keyword">ASC</span>(默认)：升序；<span class="hljs-keyword">DESC</span>：降序 <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> table1 <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> col1 <span class="hljs-keyword">ASC</span>, col2 <span class="hljs-keyword">DESC</span>;<br></code></pre></div></td></tr></table></figure><ul><li><strong>GROUP BY</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>可以把具有相同的数据值的行放在同一组中。<br><span class="hljs-keyword">SELECT</span> col, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> col;<br><br># <span class="hljs-keyword">WHERE</span> 过滤行，<span class="hljs-keyword">HAVING</span> 过滤分组，行过滤应当先于分组过滤。<br><span class="hljs-keyword">SELECT</span> col, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">WHERE</span> col <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> col<br><span class="hljs-keyword">HAVING</span> num <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>;<br><br># <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 后可以接<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 按分组后字段来进行排序。<br><span class="hljs-keyword">SELECT</span> col, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> col<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> num;<br></code></pre></div></td></tr></table></figure><blockquote><ul><li><p>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</p></li><li><p>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</p></li><li><p>NULL 的行会单独分为一组；</p></li><li><p>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</p></li></ul></blockquote><ul><li><p><strong>子查询</strong></p><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> mytable1<br><span class="hljs-keyword">WHERE</span> col1 <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> col2<br>               <span class="hljs-keyword">FROM</span> mytable2);<br></code></pre></div></td></tr></table></figure><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <br>  <span class="hljs-keyword">FROM</span> Orders <br>  <span class="hljs-keyword">WHERE</span> Orders.cust_id <span class="hljs-operator">=</span> Customers.cust_id) <span class="hljs-keyword">AS</span> orders_num <br><span class="hljs-keyword">FROM</span> Customers<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cust_name;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> #连接</h2><p><font style="color:red">连接用于连接多个表，使用 <code>JOIN</code> 关键字，并且连接的条件语句使用 <code>ON</code> 而不是 <code>WHERE</code>。</font></p><p><strong>连接可以替换子查询，并且比子查询的效率一般会更快。</strong></p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><ul><li><p><strong>自然连接</strong></p><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> tab1.value, tab2.value<br><span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">AS</span> tab1 <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">AS</span> tab2;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>内连接</strong></p><p>内连接又称等值连接，使用 INNER JOIN 关键字。可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> tab1.value, tab2.value<br><span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">AS</span> tab1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">AS</span> tab2<br><span class="hljs-keyword">ON</span> tab1.key <span class="hljs-operator">=</span> tab2.key;<br><br><span class="hljs-keyword">SELECT</span> tab1.value, tab2.value<br><span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">AS</span> tab1  <br><span class="hljs-keyword">WHERE</span> tab1.key <span class="hljs-operator">=</span> tab2.key;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>外连接</strong></p><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"># 检索所有顾客的订单信息，包括还没有订单信息的顾客。<br><span class="hljs-keyword">SELECT</span> Customers.cust_id, Orders.order_num<br><span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> Orders<br><span class="hljs-keyword">ON</span> Customers.cust_id <span class="hljs-operator">=</span> Orders.cust_id;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> #索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><p><font style="color:grey">待编纂。。</font></p><h2 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> #触发器</h2><p><font style="color:red">触发器会在某个表执行以下语句时而自动执行: DELETE、INSERT、UPDATE。</font></p><p><font style="color:red">触发器必须指定在语句执行之前或者之后自动执行，之前执行使用 <code>BEFORE</code> 关键字，之后执行使用 <code>AFTER</code> 关键字。<code>BEFORE</code> 用于数据验证和净化，<code>AFTER</code> 用于审计跟踪，将修改记录到另外一张表中。</font></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger1 AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> table1<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">SELECT</span> NEW.col <span class="hljs-keyword">into</span> <span class="hljs-variable">@result</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@result</span>; <span class="hljs-comment">-- 获取结果</span><br></code></pre></div></td></tr></table></figure><blockquote><p>INSERT 触发器包含一个名为 <code>NEW</code> 的虚拟表。</p><p>DELETE 触发器包含一个名为 <code>OLD</code> 的虚拟表，并且是只读的。</p><p>UPDATE 触发器包含一个名为 <code>NEW</code> 和一个名为 <code>OLD</code> 的虚拟表，其中 <strong>NEW 是可以被修改的，而 OLD 是只读的。</strong></p><p>MySQL 不允许在触发器中使用 <code>CALL</code> 语句，也就是不能调用存储过程。</p></blockquote><h2 id="存储过程"><a class="markdownIt-Anchor" href="#存储过程"></a> #存储过程</h2><p><font style="color:grey">待编纂。。</font></p><h2 id="游标"><a class="markdownIt-Anchor" href="#游标"></a> #游标</h2><p><font style="color:grey">待编纂。。</font></p><h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> #事务</h2><p><font style="color:grey">待编纂。。</font></p><h2 id="sql优化"><a class="markdownIt-Anchor" href="#sql优化"></a> #SQL优化</h2><ol><li><p><strong>避免全表扫描</strong>，首先应考虑在 where 及 order by 涉及的列上建立索引；</p></li><li><p><strong>避免在 where 子句中对字段进行 null 值判断</strong>，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> num <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br></code></pre></div></td></tr></table></figure><p>也可以自定义表示 null 值的标识符来填充，同时 定长类型 的字段在建立时，空间也固定了不管是否插入值（NULL也包含在内）。如果是 变长类型 字段 null 值是不占用空间的；</p></li><li><p><strong>避免在where子句中使用<code>!=</code>或<code>&lt;&gt;</code>操作符</strong>，否则引擎会放弃索引搜索而进行全表扫描；</p></li><li><p><strong>避免在where子句中使用<code>or</code>来连接条件</strong>，如果一个字段有索引，另一个没有索引时，引擎也会放弃索引搜索而进行全表扫描；</p><p><strong>可以将<code>or</code>连接方式改成<code>union</code>方式</strong> ：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> role <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;admin&#x27;</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong><code>in</code>和<code>not in</code>也会导致全表扫描，用 <code>exists</code> 代替 <code>in</code>，或者对于连续的数值使用<code>between</code></strong>；</p></li><li><p>前导的模糊查询会导致全表扫描：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%abc&#x27;</span><br></code></pre></div></td></tr></table></figure><p>若要提高效率，可以考虑全文检索。</p></li><li><p>避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</p></li><li><p>Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</p></li><li><p>对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。</p></li><li><p>类似 <code>select count(*) from table；</code>这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。</p></li><li><p>索引并不是越多越好，<strong>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引</strong>，所以怎样建索引需要慎重考虑，视具体情况而定。<strong>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</strong></p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p></li><li><p>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p></li><li><p>任何地方都不要使用 select * from t ，用具体的字段列表代替“ * ”，不要返回用不到的任何字段。</p></li><li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</p></li><li><p>**在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；**如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p></li><li><p><strong>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</strong></p></li><li><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p></li><li><p>尽量避免大事务操作，提高系统并发能力。</p></li><li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写；使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p></li></ol><h2 id="规范"><a class="markdownIt-Anchor" href="#规范"></a> #规范</h2><p><font style="color:grey">待编纂。。</font></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
      <tag>Sql</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/helloworld/notes/Java/Spring/Spring/"/>
    <url>/helloworld/notes/Java/Spring/Spring/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p>参考文章：</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-introduce.html">Spring框架组成</a></li><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-ioc.html">Spring核心之控制反转(IoC)</a></li><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-aop.html">Spring核心之面向切面编程(AOP)</a></li><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-springmvc.html">SpringMVC请求流程和案例</a></li></ul><h2 id="spring介绍"><a class="markdownIt-Anchor" href="#spring介绍"></a> #Spring介绍</h2><p>Spring框架是一个开放源代码的J2EE应用程序框架，是<font style="color:red"><strong>针对bean的生命周期进行管理的轻量级容器</strong></font>，提供了功能强大IOC、AOP及Web MVC等功能。</p><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。</li><li>容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期</li><li><strong>控制反转：IoC</strong>(Inversion of Control)，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。</li><li><strong>依赖注入：DI</strong>(Dependency Injection)，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。</li><li><strong>面向切面编程</strong>：<strong>AOP</strong>(Aspect Oriented Programming)</li><li>一站式：在 <strong>IoC</strong> 和 <strong>AOP</strong> 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表现层的 SpringMVC 和持久层的 Spring JDBC）</li><li>非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API</li></ul><h2 id="spring组件"><a class="markdownIt-Anchor" href="#spring组件"></a> #Spring组件</h2><p>Spring采用分层架构，根据不同的功能划分为多个组件模块：</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Spring%E7%BB%84%E4%BB%B6.png" alt="Spring组件" /></p><ol><li><p><strong>Data Access/Integration（数据访问／集成）</strong>:</p><p>数据访问/集成层 包括JDBC、ORM、OXM、JMS和Transactions模块：</p><ul><li>JDBC模块：提供了JDBC的抽象层，大幅减少了开发时对数据库的操作。</li><li>ORM模块：对流行的对象关系映射API，包括JPA、JDO、Hibernate和iBatis提供了集成层。</li><li>OXM 模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。</li><li>JMS 模块：指 Java 消息服务，包含的功能为生产和消费的信息。</li><li><font style="color:red">Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类。</font></li></ul></li><li><p><strong>Web模块</strong>：</p><p>包括Web、Servlet、Struts和Protlet组件：</p><ul><li>Web模块：提供了基本的Web开发集成特性，如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。</li><li>Servlet模块：包括Spring模型-视图-控制器（MVC）实现Web应用程序。</li><li>Struts模块：支持类内的Spring应用程序，集成了经典的Struts Web层。</li><li>Protlet模块：提供在 Portlet 环境中使用 MVC实现，类似 Web-Servlet 模块的功能。</li></ul></li><li><p><strong>Core Container（核心容器）</strong>：</p><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成，具体介绍如下。</p><ul><li><font style="color:red">Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。</font></li><li><font style="color:red">Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。</font></li><li>Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。</li><li>Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。</li></ul></li><li><p><strong>其他模块</strong>：</p><p>Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下。</p><ul><li><font style="color:red">AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。</font></li><li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li><li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li>Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。</li></ul></li></ol><h2 id="bean"><a class="markdownIt-Anchor" href="#bean"></a> #Bean</h2><p>  <font style="color:red">在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。由Spring IoC容器实例化、组装和管理bean对象，从而对组件之间依赖关系进行了解耦。</font></p><h3 id="bean配置"><a class="markdownIt-Anchor" href="#bean配置"></a> Bean配置</h3><p>  Spring 配置文件支持两种不同的格式，分别是 XML 文件格式和 Properties 文件格式。</p><p>  通常情况下，Spring 会以 XML 文件格式作为 Spring 的配置文件，这种配置方式通过 XML 文件注册并管理 Bean 之间的依赖关系。定义 Bean 的示例代码如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用id属性定义bean1，其对应的实现类为com.bean.Bean1 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bean1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bean.Bean1&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--使用name属性定义bean2，其对应的实现类为com.beam.Bean2--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bean2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.beam.Bean2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>Bean配置常用属性：</p><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">是一个 Bean 的唯一标识符，Spring 容器对 Bean 的配置和管理都通过该属性完成</td></tr><tr><td style="text-align:center">name</td><td style="text-align:center">Spring 容器同样可以通过此属性对容器中的 Bean 进行配置和管理，name 属性中可以为 Bean 指定多个名称，每个名称之间用逗号或分号隔开</td></tr><tr><td style="text-align:center">class</td><td style="text-align:center">该属性指定了 Bean 的具体实现类，它必须是一个完整的类名，使用类的全限定名</td></tr><tr><td style="text-align:center">scope</td><td style="text-align:center">用于设定 Bean 实例的作用域，其属性值有 <code>singleton</code>（单例）、<code>prototype</code>（原型）、<code>request</code>、<code>session</code> 和 <code>global Session</code>。其默认值是 <code>singleton</code></td></tr><tr><td style="text-align:center">constructor-arg</td><td style="text-align:center"><code>&lt;bean&gt;</code>元素的子元素，可以使用此元素传入构造参数进行实例化。该元素的 index 属性指定构造参数的序号（从 0 开始），type 属性指定构造参数的类型</td></tr><tr><td style="text-align:center">property</td><td style="text-align:center"><code>&lt;bean&gt;</code>元素的子元素，用于调用 Bean 实例中的 Set 方法完成属性赋值，从而完成依赖注入。该元素的 name 属性指定 Bean 实例中的相应属性名</td></tr><tr><td style="text-align:center">ref</td><td style="text-align:center"><code>&lt;property&gt;</code> 和 <code>&lt;constructor-arg&gt;</code> 等元素的子元索，该元素中的 bean 属性用于指定对 Bean 工厂中某个 Bean 实例的引用</td></tr><tr><td style="text-align:center">value</td><td style="text-align:center"><code>&lt;property&gt;</code> 和<code>&lt;constractor-arg&gt;</code> 等元素的子元素，用于直接指定一个常量值</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">用于封装 List 或数组类型的依赖注入</td></tr><tr><td style="text-align:center">set</td><td style="text-align:center">用于封装 Set 类型属性的依赖注入</td></tr><tr><td style="text-align:center">map</td><td style="text-align:center">用于封装 Map 类型属性的依赖注入</td></tr><tr><td style="text-align:center">entry</td><td style="text-align:center"><code>&lt;map&gt;</code> 元素的子元素，用于设置一个键值对。其 key 属性指定字符串类型的键值，<code>ref</code> 或 <code>value</code> 子元素指定其值</td></tr></tbody></table><h3 id="bean的使用"><a class="markdownIt-Anchor" href="#bean的使用"></a> Bean的使用：</h3><p>由于IoC 是指在程序开发中，实例的创建不再由调用者管理，而是由 Spring 容器创建，Spring 容器会负责控制程序之间的关系。</p><p>Spring提供了两种IoC容器</p><ul><li><p>BeanFactory</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">BeanFactory factory=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanFactory</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;application.xml&quot;</span>));<br></code></pre></div></td></tr></table></figure></li><li><p>ApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationContext app=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;application.xml&quot;</span>);<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="ioc控制反转"><a class="markdownIt-Anchor" href="#ioc控制反转"></a> #IoC(控制反转)</h2><p>  IoC(Inversion of Control)即 控制反转 <strong>是一种设计思想</strong>，简单来说就是<font style="color:red">创建对象的控制权，被反转到了Spring框架上；</font><font style="color:#00FFFF">通常，我们实例化一个对象时，都是使用类的构造方法来new一个对象，这个过程是由我们自己来控制的，而控制反转就把new对象的工作交给了Spring容器。</font></p><p>传统程序设计下，需要我们主动去创建相关对象然后再组合起来，比如：</p><p>示例1：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">UserDaoImpl userDao=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>UserServiceImpl userService=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>userService.setUserDao(userDao);<br></code></pre></div></td></tr></table></figure><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/IoC%E5%9B%BE%E7%A4%BA1.png" alt="IoC示例1" /></p><p>当有了IoC/DI的容器后，我们就不用再主动去创建这些对象了，如下：</p><p>示例2：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ApplicationContext context=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPashXmlApplicationContext</span>(<span class="hljs-string">&quot;application.xml&quot;</span>);<br><span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> xmlApp.getBean(<span class="hljs-string">&quot;userService&quot;</span>,UserServiceImpl.class);<br></code></pre></div></td></tr></table></figure><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/IoC%E5%9B%BE%E7%A4%BA2.png" alt="IoC示例2" /></p><p><strong>IoC</strong>的主要实现方式有两种：依赖查找、依赖注入。</p><h3 id="依赖查找"><a class="markdownIt-Anchor" href="#依赖查找"></a> 依赖查找</h3><p>  主要是容器为组件提供一个回调接口和上下文环境。这样一来，组件就必须自己使用容器提供的API来查找资源和协作对象，所以依赖查找的控制反转仅体现在那些回调方法上，容器调用这些回调方法，从而应用代码获取到资源。</p><h3 id="依赖注入"><a class="markdownIt-Anchor" href="#依赖注入"></a> 依赖注入</h3><p>  组件不做定位查询，只提供标准的Java方法让容器去决定依赖关系。容器全权负责组件的装配，把符合依赖关系的对象通过Java Bean属性或构造方法传递给需要的对象。<font style="color:red">由IoC容器动态地将某个对象所需要的外部资源（包括对象、资源、常量数据）注入到组件(Controller, Service等）之中。简单点说，就是IoC容器会把当前对象所需要的外部资源动态的注入给我们。</font></p><p>Spring依赖注入的方式主要有三个：</p><ul><li><p>注解注入</p><p><code>@Autowired</code>默认按类型装配<br /><code>@Qualifier</code>和<code>Autowired</code>配合使用，指定bean的名称<br /><code>@Resource</code>默认按名称装配，当找不到与名称匹配的bean时，才会按类型装配。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ioctest.bean;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;cat&quot;)</span><br>    Cat cat;<br>    <span class="hljs-meta">@Resource</span><br>    Dog dog;<br><br>    <span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">getCat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cat;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Dog <span class="hljs-title function_">getDog</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dog;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;People&#123;&quot;</span><br>                +<span class="hljs-string">&quot; cat=&quot;</span> + cat.name +<br>                <span class="hljs-string">&quot;, dog=&quot;</span> + dog.name +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>set注入</p><p>setter是Spring现在<strong>最主流</strong>的注入方式,它可以利用<strong>Java Bean</strong> 规范所定义<strong>set/get</strong>方法来完成注入,可读性灵活性高</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String lastName ;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String email;<br><span class="hljs-comment">//getter/setter方法和无参全参构造器省略.....</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>xml文件配置：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person01&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.ioctest.bean.Person&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 使用property标签是通过类的set方法为Person对象的属性赋值 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- name是属性名，value是属性值 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;163@qq.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>构造器注入</p><p><font style="color:#00FFFF">构造器注入主要是依赖于构造方法去实现,构造方法可以是有参也可以是无参,我们在平常都是通过类的构造方法来创建类对象,以及给他赋值,同样Spring 是通过反射的方式,使用构造方法来完成注入(赋值)</font></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String lastName ;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String email;<br><span class="hljs-comment">//getter/setter方法省略.....</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String lastName, Integer age, String gender, String email)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lastName = lastName;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.gender = gender;<br>        <span class="hljs-built_in">this</span>.email = email;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>xml文件配置：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person03&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.ioctest.bean.Person&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- constructor-arg标签是通过有参构造器方法为属性赋值 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;王五&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;12494@qq.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>接口注入</p><p>接口注入模式因为具备<font style="color:yellow">侵入性<sup>1</sup></font>，它要求组件必须与特定的接口相关联，其在灵活性、易用性上不如其他注入模式，所以不突出说明了。</p></li></ul><p><font style="color:yellow">①：侵入性是指一个类中继承了一个接口或继承了一个类，那么这个类就得实现接口的定义的方法或继承了父类。从一定的意义上说这个类被入侵了。</font></p><h2 id="aop面向切面编程"><a class="markdownIt-Anchor" href="#aop面向切面编程"></a> #AOP(面向切面编程)</h2><p>Spring 框架通过定义切面, 通过拦截切点实现了不同业务模块的解耦，这个就叫<strong>面向切面编程</strong>。它和IoC一样是一种设计思想。</p><p>将分散在各个业务逻辑代码中相同的代码通过<strong>横向切割</strong>的方式抽取到一个独立的模块中</p><p><strong>AOP术语</strong>：</p><blockquote><p><strong>连接点（Jointpoint）</strong>：表示需要在程序中插入横切关注点的扩展点，<strong>连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等</strong>，Spring只支持方法执行连接点，在AOP中表示为<strong>在哪里干</strong>；</p><p><strong>切入点（Pointcut）</strong>： 选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为<strong>在哪里干的集合</strong>；</p><p><strong>通知（Advice）</strong>：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为<strong>干什么</strong>；</p><p><strong>方面/切面（Aspect）</strong>：横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为<strong>在哪干和干什么集合</strong>；</p><p><strong>引入（inter-type declaration）</strong>：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在AOP中表示为<strong>干什么（引入什么）</strong>；</p><p><strong>目标对象（Target Object）</strong>：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为被通知对象；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为<strong>对谁干</strong>；</p><p><strong>织入（Weaving）</strong>：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。在AOP中表示为<strong>怎么实现的</strong>；</p><p><strong>AOP代理（AOP Proxy）</strong>：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</p></blockquote><p><strong>通知类型</strong>：</p><blockquote><p><strong>前置通知（Before advice）</strong>：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</p><p><strong>后置通知（After returning advice）</strong>：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p><p><strong>异常通知（After throwing advice）</strong>：在方法抛出异常退出时执行的通知。</p><p><strong>最终通知（After (finally) advice）</strong>：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p><p><strong>环绕通知（Around Advice）</strong>：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p></blockquote><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/AOP%E5%9B%BE%E7%A4%BA.png" alt="AOP图示" /></p><h3 id="aop使用示例"><a class="markdownIt-Anchor" href="#aop使用示例"></a> AOP使用示例</h3><ul><li><p>目标类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.aoptest.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AopDemoServiceImpl</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doMethod1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;AopDemoServiceImpl.doMethod1()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doMethod2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;AopDemoServiceImpl.doMethod2()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doMethod3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;AopDemoServiceImpl.doMethod3()&quot;</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;some exception&quot;</span>);<br>    &#125;<br>&#125;<br>  <br></code></pre></div></td></tr></table></figure></li><li><p>切面类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.aoptest.aspect;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;环绕通知: 进入方法&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> pjp.proceed();<br>        System.out.println(<span class="hljs-string">&quot;环绕通知: 退出方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前置通知.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBefore</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;前置通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后置通知.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterReturning</span><span class="hljs-params">(String result)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;后置通知, 返回值: &quot;</span> + result);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常通知.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterThrowing</span><span class="hljs-params">(Exception e)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;异常通知, 异常: &quot;</span> + e.getMessage());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最终通知.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfter</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;最终通知&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>XML配置</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.spring.aoptest&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 目标类 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.spring.aoptest.service.AopDemoServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- configure properties of bean here as normal --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 切面 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.spring.aoptest.aspect.LogAspect&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- configure properties of aspect here as normal --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置切面 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logAspect&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 配置切入点 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.spring.aoptest.service.*.*(..))&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 环绕通知 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doAround&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 前置通知 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doBefore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 后置通知；returning属性：用于设置后置通知的第二个参数的名称，类型是Object --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doAfterReturning&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span> <span class="hljs-attr">returning</span>=<span class="hljs-string">&quot;result&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 异常通知：如果没有异常，将不会执行增强；throwing属性：用于设置通知第二个参数的的名称、类型--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doAfterThrowing&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span> <span class="hljs-attr">throwing</span>=<span class="hljs-string">&quot;e&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 最终通知 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doAfter&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCutMethod&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// create and configure beans</span><br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;aspects.xml&quot;</span>);<br><br>    <span class="hljs-comment">// retrieve configured instance</span><br>    <span class="hljs-type">AopDemoServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;demoService&quot;</span>, AopDemoServiceImpl.class);<br><br>    <span class="hljs-comment">// use configured instance</span><br>    service.doMethod1();<br>    service.doMethod2();<br>    <span class="hljs-keyword">try</span> &#123;<br>        service.doMethod3();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// e.printStackTrace();</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">-----------------------<br>环绕通知: 进入方法<br>前置通知<br>AopDemoServiceImpl.doMethod1()<br>环绕通知: 退出方法<br>最终通知<br>-----------------------<br>环绕通知: 进入方法<br>前置通知<br>AopDemoServiceImpl.doMethod2()<br>环绕通知: 退出方法<br>最终通知<br>后置通知, 返回值: hello world<br>-----------------------<br>环绕通知: 进入方法<br>前置通知<br>AopDemoServiceImpl.doMethod3()<br>最终通知<br>异常通知, 异常: some exception<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="spring-mvc"><a class="markdownIt-Anchor" href="#spring-mvc"></a> #Spring MVC</h2><p><font style="color:red">MVC英文是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计规范：用一种业务逻辑、数据、界面显示分离的方法，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</font></p><blockquote><ul><li><strong>Model</strong>（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。</li><li><strong>View</strong>（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。</li><li><strong>Controller</strong>（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul></blockquote><p>Spring MVC 是一种基于Java 的实现了Web MVC 设计模式的请求驱动类型的轻量级Web 框架，即使用了MVC 架 构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，<font style="color:red">框架的目的就是帮助我们简化开发。</font></p><p>SpringMVC运行流程：</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/SpringMVC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="SpringMVC运行流程" /></p><ol><li><code>DispatcherServlet</code>表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，<code>DispatcherServlet</code>接收请求并拦截请求；</li><li><code>HandlerMapping</code>为处理器映射。<code>DispatcherServlet</code>调用<code>HandlerMapping</code>,<code>HandlerMapping</code>根据请求url查找<code>Handler</code>；</li><li>返回<code>Headler执行链</code>，根据url查找控制器，并且将解析后的信息传递给<code>DispatcherServlet</code>；</li><li><code>HandlerAdapter</code>表示处理器适配器，其按照特定的规则去执行<code>Handler</code>；</li><li>执行<code>Handler</code>找到具体的处理器；</li><li><code>Controller</code>将具体的执行信息返回给<code>HandlerAdapter</code>,如ModelAndView；</li><li><code>HandlerAdapter</code>将视图逻辑名或模型传递给<code>DispatcherServlet</code>；</li><li><code>DispatcherServlet</code>调用视图解析器(<code>ViewResolver</code>)来解析<code>HandlerAdapter</code>传递的逻辑视图名；</li><li>视图解析器将解析的逻辑视图名传给<code>DispatcherServlet</code>；</li><li><code>DispatcherServlet</code>根据视图解析器解析的视图结果，调用具体的视图，进行试图渲染；</li><li>将响应数据返回给客户端。</li></ol><h3 id="mvc使用示例"><a class="markdownIt-Anchor" href="#mvc使用示例"></a> MVC使用示例</h3><p>IDEA创建Spring项目是会让我们先选择引用依赖，我们可以在这是选中MVC的依赖。</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/MVC%E4%BE%9D%E8%B5%96%E7%A4%BA%E4%BE%8B.png" alt="MVC依赖示例" /></p><p>或者直接创建无依赖的项目，再在<code>pom.xml</code>文件中引用依赖：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;servlet.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    &lt;/dependencies<br></code></pre></div></td></tr></table></figure><h4 id="业务代码"><a class="markdownIt-Anchor" href="#业务代码"></a> 业务代码</h4><ul><li><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.springmvctest.entity;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>Dao</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.springmvctest.dao;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><span class="hljs-keyword">import</span> com.spring.springmvctest.User;<br><br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * mocked to find user list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user list</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Collections.singletonList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-number">18</span>));<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure></li><li><p>Service</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.springmvctest.service;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> com.spring.springmvctest.dao.UserDaoImpl;<br><span class="hljs-keyword">import</span> com.spring.springmvctest.entity.User;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * user dao impl.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * find user list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user list</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">findUserList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.findUserList();<br>    &#125;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure></li><li><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.springmvctest.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<br><span class="hljs-keyword">import</span> tech.pdai.springframework.springmvc.service.UserServiceImpl;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserServiceImpl userService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * find user list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request  request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> model and view</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">list</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>        modelAndView.addObject(<span class="hljs-string">&quot;dateTime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        modelAndView.addObject(<span class="hljs-string">&quot;userList&quot;</span>, userService.findUserList());<br>        modelAndView.setViewName(<span class="hljs-string">&quot;userList&quot;</span>); <span class="hljs-comment">// views目录下userList.jsp</span><br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h4><ul><li><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.1&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>SpringFramework - SpringMVC Demo<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc-demo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc-demo<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><code>web.xml</code>中需配置初始化参数<code>contextConfigLocation</code>也即mvc配置文件，路径是<code>classpath:springmvc.xml</code></p></li><li><p>springmvc.xml</p><p>在<code>resources</code>目录下创建<code>springmvc.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br>著作权归https://pdai.tech所有。<br>链接：https://www.pdai.tech/md/spring/spring-x-framework-springmvc.html<br><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:jpa</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 扫描注解 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.spring.springmvctest&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 静态资源处理 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 开启注解 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 视图解析器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jspViewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><h4 id="视图"><a class="markdownIt-Anchor" href="#视图"></a> 视图</h4><ul><li><p>JSP</p><figure class="highlight jsp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;%@ taglib prefix=<span class="hljs-string">&quot;c&quot;</span> uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;<br>    &lt;meta http-equiv=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> content=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;<br>    &lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;<br><br>    &lt;title&gt;User List&lt;/title&gt;<br><br>    &lt;!-- Bootstrap --&gt;<br>    &lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css&quot;</span>&gt;<br><br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div class=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>        &lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;$&#123;!empty userList&#125;&quot;</span>&gt;<br>            &lt;table class=<span class="hljs-string">&quot;table table-bordered table-striped&quot;</span>&gt;<br>                &lt;tr&gt;<br>                    &lt;th&gt;Name&lt;/th&gt;<br>                    &lt;th&gt;Age&lt;/th&gt;<br>                &lt;/tr&gt;<br>                &lt;c:forEach items=<span class="hljs-string">&quot;$&#123;userList&#125;&quot;</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;<br>                    &lt;tr&gt;<br>                        &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt;<br>                        &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt;<br>                    &lt;/tr&gt;<br>                &lt;/c:forEach&gt;<br>            &lt;/table&gt;<br>        &lt;/c:<span class="hljs-keyword">if</span>&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程与并发编程</title>
    <link href="/helloworld/notes/Java/API/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/helloworld/notes/Java/API/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待编纂。</font></p><p>参考文章：</p><ul><li><a href="https://blog.kyire.site/2021/04/17/dcfce7ce.html">多线程与线程同步</a></li><li><a href="https://blog.kyire.site/2021/05/16/eb9166f8.html">JUC并发编程</a></li><li><a href="https://blog.csdn.net/pange1991/article/details/53860651">Java线程的6种状态及切换</a></li><li><a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">synchronized详解</a></li><li><a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html">volatile详解</a></li><li><a href="https://blog.csdn.net/qq_28082757/article/details/101065531">System.out.println如何影响内存可见性</a></li><li><a href="https://blog.csdn.net/duzhe2905/article/details/106038681">volatile如何保证可见性和有序性</a></li><li><a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-all.html">Java中所有的锁</a></li><li><a href="https://blog.csdn.net/qq_42290561/article/details/125575083">深入了解CAS和常用原子类</a></li><li><a href="https://blog.csdn.net/qq_43478694/article/details/123622726">Unsafe类详解</a></li></ul><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> #多线程</h2><p>  <font style="color : red"><strong>线程</strong>是CPU调度和执行的单位。</font>而多个线程组成一个进程，<font style="color : red"><strong>进程</strong>是一个动态的概念，是系统资源分配的单位。</font>进程又是执行程序的一次执行过程，<font style="color : red"><strong>程序</strong>是一个静态的概念，是指令和数据的有序集合，其本身没有任何运行的含义。</font></p><p><strong>多线程核心概念</strong></p><ul><li><p>线程就是独立的执行路径；在程序运行时，后台会就有多个线程，也称为<font style="color:yellow">守护线程<sup>1</sup></font>，如<code>main</code>主线程、gc线程；<code>main()</code>线程称之为主线程，为系统的入口，用于执行整个程序；</p></li><li><p>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的；</p></li><li><p>对同一份资源操作时，会存在资源抢占问题，需要加入并发控制；</p></li><li><p>线程会带来额外的开销，如CPU调度时间，并发控制开销；</p></li><li><p>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致；</p><p><font style="color:yellow">①：守护线程是指在程序运行时 在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分。而由我们自己定义的线程称为 <strong>用户线程</strong> 。</font></p></li></ul><h3 id="线程创建方式"><a class="markdownIt-Anchor" href="#线程创建方式"></a> 线程创建方式</h3><ul><li><p>继承Thread类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread方式&quot;</span>+i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TestThread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestThread</span>();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>实现Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Runnable方式&quot;</span>+i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TestRunnable runnable=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable).start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>实现Callable接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Runnable方式&quot;</span>+i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;call结束&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">//创建一个callable接口实现类对象</span><br>        <span class="hljs-type">CallableTest</span> <span class="hljs-variable">callableTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableTest</span>();<br>        <span class="hljs-comment">//创建执行服务</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//提交执行</span><br>        Future&lt;String&gt; future = service.submit(callableTest);<br>        <span class="hljs-comment">//获取call返回结果</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get();<br>        System.out.println(result);<br>        <span class="hljs-comment">//关闭服务</span><br>        service.shutdownNow();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote></blockquote><p><strong>小结</strong></p><ul><li>继承<code>Thread</code>类<ul><li>启动线程：子类对象.start()</li><li><b style="color:red">存在OOP单继承局限性</b></li></ul></li><li>实现<code>Runnable</code>接口<ul><li>启动线程：传入目标对象+Thread对象.start()</li><li><b style="color:red">灵活方便，方便同一个对象被多个线程使用，减少程序之间的耦合度，面向接口编程也是设计模式六大原则的核心。</b></li></ul></li><li>实现<code>Callable</code>接口<ul><li>启动线程：执行对象(线程池).submit(目标对象)</li><li>获取结果：执行对象(线程池).submit(目标对象).get()</li><li><b style="color:red">Callable主要用于线程池可以抛出异常并且有返回值。</b></li></ul></li></ul></li></ul><h3 id="thread类"><a class="markdownIt-Anchor" href="#thread类"></a> Thread类</h3><ul><li><p>线程状态</p><ol><li><p><strong>初始状态(NEW)</strong><br /><font style="color:#00FFFF">实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</font></p></li><li><p><strong>运行(RUNNABLE)</strong></p><blockquote><p><strong>2.1. 就绪 (RUNNABLE之READY)</strong></p><ul><li><font style="color:#00FFFF">就绪状态只是说有资格运行，只要调度程序没有挑选到你，就永远是就绪状态。</font></li><li>调用线程的<code>start()</code>方法，此线程进入就绪状态。</li><li>当前线程<code>sleep()</code>方法结束，其他线程<code>join()</code>结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</li><li>当前线程时间片用完了，调用当前线程的<code>yield()</code>方法，当前线程进入就绪状态。</li><li>锁池里的线程拿到对象锁后，进入就绪状态。</li></ul><p><strong>2.2. 运行中状态(RUNNABLE之RUNNING)</strong></p><ul><li><font style="color:#00FFFF">线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。</font></li></ul></blockquote></li><li><p><strong>阻塞(BLOCKED)</strong><br /><font style="color:#00FFFF">阻塞状态是线程阻塞在进入<code>synchronized</code>关键字修饰的方法或代码块(获取锁)时的状态。</font></p></li><li><p><strong>等待(WAITING)</strong><br /><font style="color:#00FFFF">处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</font></p></li><li><p><strong>超时等待(TIMED_WAITING)</strong><br /><font style="color:#00FFFF">处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</font></p></li><li><p><strong>终止(TERMINATED)</strong><br /><font style="color:#00FFFF">当线程的<code>run()</code>方法完成时，或者主线程的<code>main()</code>方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。</font><br /><font style="color : red">在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</font></p></li></ol><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpeg" alt="线程状态" /></p></li><li><p>线程方法</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">setPriority(int newPriority)</td><td style="text-align:center">更改线程的优先级</td></tr><tr><td style="text-align:center">static void sleep(long millis)</td><td style="text-align:center">在指定毫秒数内让当前正在执行的线程休眠</td></tr><tr><td style="text-align:center">void join()</td><td style="text-align:center">等待该线程终止</td></tr><tr><td style="text-align:center">static void yield()</td><td style="text-align:center">暂停当前正在执行的线程对象，并执行其他线程</td></tr><tr><td style="text-align:center">void interrupt()</td><td style="text-align:center">中断线程，别用这个方式</td></tr><tr><td style="text-align:center">boolean isAlive()</td><td style="text-align:center">测试线程是否处于活动状态</td></tr></tbody></table><p><font style="color:yellow"><code>wait()</code>：wait是<code>Object</code>中的方法，任何对象实例都能调用。它和<code>Thread</code>中的<code>sleep()</code>很相似，不同的是sleep不会释放锁，也不需要占有锁；而wait会释放锁，而且调用它的前提是当前线程占有锁(即代码在<code>synchronized</code> 中)</font></p></li></ul><h3 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> synchronized</h3><p><code>synchronized</code>是Java中的关键字，是一种同步锁，它具有以下特点：</p><ul><li><p><font style="color:red">一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</font></p></li><li><p><font style="color:red"><code>synchronized</code>可以修饰 <strong>方法</strong> 和 <strong>代码块</strong> ；</font></p></li><li><p><font style="color:red">synchronized修饰 普通方法 锁对象默认为this(当前实例对象)，而同步代码块锁可以指定对象，两种都是<strong>对象锁</strong>；</font></p><p>对象锁示例1：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<span class="hljs-comment">//和synchronized修饰 普通方法 效果相同</span><br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">我是线程Thread-0<br>Thread-0结束<br>我是线程Thread-1<br>Thread-1结束<br></code></pre></div></td></tr></table></figure><p>上述代码两个线程使用的锁是一样的,<code>thread2</code>必须要等到<code>thread1</code>释放了该锁后，才能执行。</p><p>对象锁示例2：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br>    <span class="hljs-comment">// 创建2把锁</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">block1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">block2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span><br>        <span class="hljs-keyword">synchronized</span> (block1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (block2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">block1锁,Thread-0<br>block1锁,Thread-0 END！<br>block2锁,Thread-0<br>block1锁,Thread-1<br>block1锁,Thread-1 END！<br>block2锁,Thread-0 END！<br>block2锁,Thread-1<br>block2锁,Thread-1 END！<br></code></pre></div></td></tr></table></figure><p>由示例2可见，当同步代码块指定不同对象时，在<code>thread1</code>从<code>block1锁</code>释放后；由于此时<code>thread1</code>锁对象是<code>block1锁</code>而<code>thread2</code>锁对象是<code>block2锁</code>，<code>thread2</code>会和<code>thread1</code>同时运行。</p></li><li><p><font style="color:red"><code>synchronized</code>修饰 静态方法 或同步代码块指定锁对象为 <code>Class</code>对象时，称为<strong>类锁</strong>； </font></p><p>类锁示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedObjectLock</span> <span class="hljs-variable">instence2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedObjectLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 所有线程需要的锁都是同一把</span><br>        <span class="hljs-keyword">synchronized</span>(SynchronizedObjectLock.class)&#123;<br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; END！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence1);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(instence2);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">Thread-0<br>Thread-0 END！<br>Thread-1<br>Thread-1 END！<br></code></pre></div></td></tr></table></figure><p>类锁代码，无论是哪个线程访问它，需要的锁都只有一把。</p></li><li><p><font style="color:red">synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁。</font></p></li></ul><p><font style="color:grey">待完善。。</font></p><h2 id="并发编程juc"><a class="markdownIt-Anchor" href="#并发编程juc"></a> #并发编程(JUC)</h2><p>  JUC是<code>java.util.concurrent</code>的简写，是jdk针对java并发编程的工具包。</p><p>  在了解JUC之前我们先了解<strong>并发</strong>的概念：<font style="color:red"><strong>单核下多线程操作同一个资源</strong>，将CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。这种方式我们称之为并发(Concurrent)。</font><font style="color:#00FFFF">并发实质是一个物理CPU（也可以是多个物理CPU）在若干个程序之间多路复用，并发性是对有限物理资源强制行使 多用户共享以提高效率。</font><br />而和并发相似的<strong>并行</strong>是在<font style="color:red"><strong>多核下多线程同时执行</strong>，多个线程之间互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。</font></p><p>并发问题的三要素：可见性、原子性和有序性：</p><ul><li><font style="color:red">可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</font></li><li>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li></ul><h3 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> volatile</h3><h4 id="volatile可见性"><a class="markdownIt-Anchor" href="#volatile可见性"></a> volatile可见性</h4><p>  可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用，</p><p><code>volatile</code>可见性示例1：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">()</span>&#123;<br>        a = <span class="hljs-number">3</span>;<br>        b = a;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;b=&quot;</span>+b+<span class="hljs-string">&quot;;a=&quot;</span>+a);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">VolatileTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileTest</span>();<br>            <span class="hljs-comment">//线程1</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                test.change();<br>            &#125;).start();<br>            <span class="hljs-comment">//线程2</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">10</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    test.print();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>正常情况下，这段代码只存在两种情况：</p><ol><li>先执行<code>change()</code>，再执行<code>print()</code> 结果是：b=3;a=3；</li><li>先执行<code>print()</code>，再执行<code>change()</code> 结果是：b=2;a=1；</li></ol><p>但是还可能出现 b=2;a=3 或者 b=3;a=1 的情况，这种情况主要是因为线程1修改了a或者b后，对线程2是不可见的，所以才会出现这种情况，如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。</p><p><code>volatile</code>可见性示例2：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span> (num ==  <span class="hljs-number">0</span>)&#123; <br><span class="hljs-comment">//System.out.println(&quot;thread&quot;);</span><br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-comment">//主线程暂停1s</span><br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>    num = <span class="hljs-number">1</span>;<br>    System.out.println(num);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码也能体现volatile的可见性，代码会进入死循环；这是由于线程对主线程的内存变化不可见。</p><p><font style="color:#00FFFF">  如果循环中存在 输出语句 则不会进入死循环，这是因为<code>PrintStream</code>中输出方法都带上了<code>synchronized</code>，而<code>synchronized</code>会做一下操作：</font></p><blockquote><ol><li>获得同步锁；</li><li>清空工作内存；</li><li>从主内存拷贝对象副本到工作内存；</li><li>执行代码(计算或者输出等)；</li><li>刷新主内存数据；</li><li>释放同步锁。</li></ol></blockquote><p>可见性问题的根本原因：</p><blockquote><p>在Java内存模型中，规定了共享变量是存放在主内存中，然后<strong>每个线程都有自己的工作内存</strong>，而线程对共享变量的操作，必须先从主内存中读到工作内存中去，至于什么时候写回到主内存是不可预知的，这就导致每个线程之间对共享变量的操作是封闭的，其他线程不可见的。</p></blockquote><p><code>volatile</code>修饰的共享变量进行写操作的时候多出一条带<code>lock前缀的指令</code></p><ol><li>Lock前缀的指令让线程工作内存中的值写回主内存中；</li><li>通过缓存一致性协议，其他线程如果工作内存中存了该共享变量的值，就会失效；</li><li>其他线程会重新从主内存中获取最新的值；</li></ol><h4 id="volatile原子性"><a class="markdownIt-Anchor" href="#volatile原子性"></a> volatile原子性</h4><p><code>volatile</code>原子性示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        num++; <span class="hljs-comment">//不是一个原子性操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//理论上num结果为1000</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                add();<br>            &#125;).start();<br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">//等待3秒，保证上面程序执行完成</span><br><br>        System.out.println(<span class="hljs-string">&quot;num =&quot;</span> + num);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><i style="color:yellow">注：上面代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。</i></p><p>输出结果理论上来说应该是1000，但是由于i++其实是一个复合操作，包括三步骤：</p><ul><li><p>读取i的值。</p></li><li><p>对i加1。</p></li><li><p>将i的值写回内存。</p></li></ul><p>volatile是无法保证这三个操作是具有原子性的，我们可以通过<strong>原子类</strong>或者<code>synchronized</code>和<code>lock</code>来保证+1操作的原子性。</p><h4 id="volatile有序性"><a class="markdownIt-Anchor" href="#volatile有序性"></a> volatile有序性</h4><p>实例化一个对象可以分为三个步骤：</p><ul><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ul><p>但是由于操作系统可以对指令进行<font style="color:yellow"><code>重排序</code><sup>2</sup></font>，所以上面的过程也可能会变成如下过程：</p><ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul><p><font style="color:yellow">②：指令重排是指为了性能考虑, 编译器和CPU可能会对指令重新排序。同时内存也可能存在重排序，这主要是由于JMM(Java内存模型)中主内存和本地内存不一致导致程序乱序。</font></p><blockquote><p><strong>处理器在进行指令重排的时候，考虑：数据之间的依赖性！</strong></p><p>指令重排示例：</p><p>x,y,a,b初始值为0，然后进行以下操作：</p><table><thead><tr><th style="text-align:center">线程1</th><th style="text-align:center">线程2</th></tr></thead><tbody><tr><td style="text-align:center">x=a</td><td style="text-align:center">y=b</td></tr><tr><td style="text-align:center">b=1</td><td style="text-align:center">a=2</td></tr></tbody></table><p>正常结果应该是：x=0,y=0；但是由于指令重排可能导致指令执行顺序出现问题：</p><table><thead><tr><th style="text-align:center">线程1</th><th style="text-align:center">线程2</th></tr></thead><tbody><tr><td style="text-align:center">b=1</td><td style="text-align:center">a=2</td></tr><tr><td style="text-align:center">x=a</td><td style="text-align:center">y=b</td></tr></tbody></table><p>导致结果为：x=2,y=1。</p></blockquote><p>  <strong><code>volatile</code>禁止重排序</strong>，为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了<b style="color:red">内存屏障</b>阻止这种重排序。<font style="color:red">Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</font></p><h3 id="final"><a class="markdownIt-Anchor" href="#final"></a> final</h3><p>对于常用的关键字<code>final</code>的使用只简单概述一下，主要针对<code>final</code>在并发情况下的作用。</p><h4 id="final基础使用"><a class="markdownIt-Anchor" href="#final基础使用"></a> final基础使用</h4><ul><li><p>修饰类</p><p>当某个类的整体定义为final时，就表明了你不能打算继承该类，即这个类是<font style="color:red">不能有子类的。</font></p><p><font style="color:yellow">final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。</font></p></li><li><p>修饰方法</p><p><font style="color:red">声明方法不能被子类重写。</font></p><p><font style="color:yellow">private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</font></p></li><li><p>修饰参数</p><p><font style="color:red">Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。</font><font style="color:#00FFFF">这个特性主要用来向匿名内部类传递数据。</font></p></li><li><p>修饰变量</p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul></li></ul><h4 id="final重排序规则"><a class="markdownIt-Anchor" href="#final重排序规则"></a> final重排序规则</h4><h5 id="final修饰基本类型"><a class="markdownIt-Anchor" href="#final修饰基本类型"></a> final修饰基本类型</h5><ul><li><p>写规则</p><p><font style="color:red">JMM禁止编译器把final域的写重排序到 构造函数 之外；</font><font style="color:#00FFFF"> 编译器会在final域写之后，构造函数return之前，插入一个<code>storestore</code>屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</font></p><p><font style="color:red">在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。</font></p></li><li><p>读规则</p><p><font style="color:red">在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。</font><strong>(注意，这个规则仅仅是针对处理器)</strong>，处理器会在读final域操作的前面插入一个<code>LoadLoad</code>屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p></li></ul><h5 id="final修饰引用类型"><a class="markdownIt-Anchor" href="#final修饰引用类型"></a> final修饰引用类型</h5><ul><li><p>写规则</p><p>引用类型和基础类型相较多了对 对象的引用，即：<font style="color:red">在final基本类型的写规则上增加了 在构造函数内对一个final修饰对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。</font></p></li><li><p>读规则</p><p><font style="color:red">读final引用对象的成员域时结果时<strong>不可预知</strong>的，因为其对final修饰对象的成员域的写入是不可见的，两者之间存在数据竞争。</font></p></li></ul><h3 id="juc锁"><a class="markdownIt-Anchor" href="#juc锁"></a> JUC锁</h3><p>  Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍：</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Java%E9%94%81%E7%B1%BB%E5%9E%8B.png" alt="Java锁类型" /></p><h4 id="锁类型"><a class="markdownIt-Anchor" href="#锁类型"></a> 锁类型</h4><h5 id="悲观锁乐观锁"><a class="markdownIt-Anchor" href="#悲观锁乐观锁"></a> 悲观锁&amp;乐观锁</h5><ul><li>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此<font style="color:red">在获取数据的时候会先加锁，确保数据不会被别的线程修改。</font ><font style="color:#00FFFF">Java中，synchronized关键字和Lock的实现类都是悲观锁。</font></li><li>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是<font style="color:red">在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</font><font style="color:#00FFFF">乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</font></li></ul><blockquote><p><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。<br /><strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</p></blockquote><h5 id="自旋锁适应性自旋锁"><a class="markdownIt-Anchor" href="#自旋锁适应性自旋锁"></a> 自旋锁&amp;适应性自旋锁</h5><p>  <font style="color:red">阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。</font>如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>  在同步资源的锁定时间很短的场景下，让CPU去切换线程，线程挂起和恢复线程实在得不偿失。<font style="color:red">如果能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。所以我们让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</font></p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E8%87%AA%E6%97%8B%E9%94%81.png" alt="自旋锁" /></p><p>  自旋锁本身是有缺点的，它<strong>不能代替阻塞</strong>。<font style="color:#00FFFF">如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</font>所以，<font style="color:red">自旋等待的时间和自旋次数必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</font></p><p>  如果线程自旋刚结束，锁正好释放，这是不是也是资源的一种浪费。于是针对这种情况JDK引入了更灵活的适应性自旋锁，来提高并发性能。</p><p>  适应性自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确。</p><h5 id="无锁偏向锁轻量级锁重量解锁"><a class="markdownIt-Anchor" href="#无锁偏向锁轻量级锁重量解锁"></a> 无锁，偏向锁，轻量级锁&amp;重量解锁</h5><ul><li><p>无锁</p><blockquote><p>顾名思义程序不会有锁的竞争。那么这种情况我们不需要加锁，所以这种情况下对象锁状态为无锁。</p></blockquote></li><li><p>偏向锁</p><blockquote><p>偏向第一个访问锁的线程</p></blockquote><ul><li><font style="color:#00FFFF">如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</font></li><li>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。**一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。**升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致<font style="color:yellow">STW(stop the world)<sup>3</sup></font>操作；</li></ul><p><font style="color:yellow">③：<strong>等待所有用户线程进入安全点后并阻塞</strong>，做一些全局性操作的行为。Java中一种<strong>全局暂停现象，全局停顿，所有Java代码停止</strong>，<strong>native代码可以执行，但不能与JVM交互。</strong></font></p></li><li><p>轻量级锁</p><blockquote><p>轻量级锁对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。</p></blockquote><ol><li><p><font style="color:red">在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为<code>Lock Record</code>(锁记录)的空间用于存储锁对象目前的<code>Mark Word</code>的拷贝(JVM会将对象头中的<code>Mark Word</code>拷贝到锁记录中)。如果当前对象没有被锁定，那么锁标志位为<strong>01</strong>状态。</font></p></li><li><p><font style="color:red">JVM在执行当前线程时，虚拟机使用CAS操作将标记字段<code>Mark Word</code>拷贝到锁记录中。并且将<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。</font></p><p>如果更新成功，那么这个线程就有用了该对象的锁，并且对象<code>Mark Word</code>的锁标志位更新为(<code>Mark Word</code>中最后的2bit)<strong>00</strong>，即表示此对象处于轻量级锁定状态。</p><p>如果更新失败，JVM会检查当前的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为<strong>10</strong>，<code>Mark Word</code>中存储的时指向重量级锁的指针。</p></li></ol><p><strong>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗</strong>，包括系统调用引起的<font style="color:yellow">内核态<sup>4</sup></font>与<font style="color:yellow">用户态<sup>5</sup></font>切换、线程阻塞造成的线程切换等。</p></li><li><p>重量级锁</p><blockquote><p>当有其他线程占用锁时，当前线程会进入阻塞状态。</p></blockquote><p>内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。<font style="color:red">这种同步方式的成本非常高，包括系统调用引起的<font style="color:yellow">内核态<sup>4</sup></font>与<font style="color:yellow">用户态<sup>5</sup></font>切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</font></p><p><font style="color:yellow">④：</font></p><p><font style="color:yellow">⑤：</font></p></li></ul><h5 id="公平锁非公平锁"><a class="markdownIt-Anchor" href="#公平锁非公平锁"></a> 公平锁&amp;非公平锁</h5><p>  <font style="color:red">公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</font><font style="color:#00FFFF"><strong>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</strong></font></p><p>  <font style="color:red">非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</font><font style="color:#00FFFF"><strong>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</strong></font></p><h5 id="可重入锁非可重入锁"><a class="markdownIt-Anchor" href="#可重入锁非可重入锁"></a> 可重入锁&amp;非可重入锁</h5><p>  <font style="color:red">可重入锁是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</font>Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法1执行...&quot;</span>);<br>        doOthers();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOthers</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法2执行...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>  类中的两个方法都是被内置锁synchronized修饰的，<strong>在<code>doSomething()</code>方法中调用<code>doOthers()</code>方法时，由于内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作；</strong><br />  <strong>如果是不可重入锁，那么当前线程在调用<code>doOthers()</code>之前需要将执行<code>doSomething()</code>时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</strong></p><h5 id="共享锁排他锁"><a class="markdownIt-Anchor" href="#共享锁排他锁"></a> 共享锁&amp;排他锁</h5><p><strong>共享锁</strong>是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p><strong>排他锁</strong>是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的<code>synchronized</code>和JUC中<code>Lock</code>的实现类就是互斥锁。</p><h4 id="juc锁相关体系"><a class="markdownIt-Anchor" href="#juc锁相关体系"></a> JUC锁相关体系</h4><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Lock%E6%A1%86%E6%9E%B6.png" alt="Lock框架" /></p><ul><li><p>锁核心类AQS(AbstractQueuedSynchronizer)</p><p><font style="color:red"><code>AQS</code>是一个用来<strong>构建锁和同步器的框架</strong>，使用AQS能简单且高效地构造出应用广泛的大量的同步器。</font></p><p>AQS核心思想</p><p> <strong> 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制</strong>，这个机制AQS是用<font style="color:yellow">CLH队列锁<sup>6</sup></font>实现的，即将暂时获取不到锁的线程加入到队列中。</p></li><li><p>Lock</p><p><font style="color:red"><code>Lock</code>为接口类型，<code>Lock</code>实现提供了比使用<code>synchronized</code>方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。</font></p><p><strong>ReentrantLock</strong></p><p><code>ReentrantLock</code>可重入锁，实现了<code>Lock</code>接口，<code>Lock</code>接口中定义了<code>lock</code>与<code>unlock</code>相关操作，并且还存在<code>Condition</code>方法，表示生成一个条件。</p><p><code>ReentrantLock</code>总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系：</p><ul><li><p>Sync类</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">lock</td><td style="text-align:center">锁定，未实现，留给具体子类实现</td></tr><tr><td style="text-align:center">nonfairTryAcquire</td><td style="text-align:center">非公平方式获取</td></tr><tr><td style="text-align:center">tryRelease</td><td style="text-align:center">试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它</td></tr><tr><td style="text-align:center">isHeldExclusively</td><td style="text-align:center">判断资源是否被当前线程占有</td></tr><tr><td style="text-align:center">newCondition</td><td style="text-align:center">新生一个条件</td></tr><tr><td style="text-align:center">getOwner</td><td style="text-align:center">返回资源的占用线程</td></tr><tr><td style="text-align:center">getHoldCount</td><td style="text-align:center">返回状态</td></tr><tr><td style="text-align:center">isLocked</td><td style="text-align:center">资源是否被占用</td></tr><tr><td style="text-align:center">readObject</td><td style="text-align:center">自定义反序列化逻辑</td></tr></tbody></table></li><li><p>NonfairSync类</p><p><strong>NonfairSync类继承了Sync类，表示采用非公平策略获取锁</strong>，其实现了Sync类中抽象的lock方法，<font style="color:red">每一次都尝试获取锁，而并不会按照公平等待的原则进行等待，让等待时间最久的线程获得锁。</font></p></li><li><p>FairSyn类</p><p><strong>FairSync类也继承了Sync类，表示采用公平策略获取锁</strong>，其实现了Sync类中的抽象lock方法，<font style="color:red">当资源空闲时，它总是会先判断<code>sync</code>队列(AbstractQueuedSynchronizer中的数据结构)是否有等待时间更长的线程，如果存在，则将该线程加入到等待队列的尾部，实现了公平获取原则。</font></p></li></ul></li><li><p>ReadWriteLock</p><p><font style="color:red"><code>ReadWriteLock</code>为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 <code>writer</code>，读取锁可以由多个 <code>reader</code> 线程同时保持。写入锁是独占的。</font></p></li><li><p>Condition</p><p><code>Condition</code>为接口类型，它将 Object 监视器方法(<code>wait</code>、<code>notify</code> 和 <code>notifyAll</code>)分解成截然不同的对象，以便通过将这些对象与任意 <code>Lock</code> 实现组合使用，为每个对象提供多个等待 <code>set</code> (<code>wait-set</code>)。其中，<code>Lock</code> 替代了 <code>synchronized</code> 方法和语句的使用，<code>Condition</code> 替代了 <code>Object</code> 监视器方法的使用。可以通过<code>await()</code>,<code>signal()</code>来休眠/唤醒线程。</p></li></ul><p><font style="color:grey">待编纂。。</font></p><h3 id="原子类"><a class="markdownIt-Anchor" href="#原子类"></a> 原子类</h3><h4 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h4><p>  在了解原子类之前我们需要先了解<code>CAS</code>，<code>CAS</code>(Compare-And-Swap)是指对比交换，这是一条<code>CPU</code>原子指令，其作用是让<code>CPU</code>先进行比较两个值是否相等，然后原子地更新某个位置的值。<font style="color:yellow"><code>CAS</code>实现方式是基于硬件平台的汇编指令，<code>JVM</code>只是封装了汇编调用。</font>而<code>java.util.concurrent.atomic</code>包下所有的原子类都是使用了封装<code>CAS</code>后的接口，包括<code>Lock</code>底层<code>AQS</code>也是基于<code>CAS</code>获取锁的。</p><p><code>CAS</code>工作流程：</p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/CAS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="CAS工作流程" style="zoom:80%;"/><p>使用示例：</p><p>不使用CAS，在高并发下，多线程同时修改同一个变量的值需要<code>synchronized</code>加锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> i++;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以AtomicInteger原子类示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> i.addAndGet(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><font style="color:red"><code>CAS</code> 方式为乐观锁，<code>synchronized</code> 为悲观锁。因此使用 <code>CAS</code> 解决并发问题通常情况下性能更优。</font>然而<code>CAS</code>也存在几个方面问题：</p><ul><li><p><strong>ABA问题</strong>，因为CAS需要在操作值时，检查值有没有发生变化，没有发生变化则更新，但是<strong>如果一个值原来是A，变成了B，又变成了A</strong>，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/ABA%E9%97%AE%E9%A2%98.png" alt="ABA问题" style="zoom:80%;" /><p>ABA问题解决方案：JDK提供了版本号机制<code>AtomicStampedReference&lt;V&gt;</code>类，来解决 ABA问题 ，就是每次修改时更新版本号。<br /><code>AtomicMarkableReference&lt;V&gt;</code>类也能解决，只不过该类不关心版本变更了多少次，只关心是否发生了改变。</p></li><li><p><strong>循环时间长开销大</strong>，同自旋锁一般，自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong>，当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p></li></ul><h4 id="unsafe"><a class="markdownIt-Anchor" href="#unsafe"></a> Unsafe</h4><p>  Unsafe类提供了<strong>硬件级别的的原子性操作</strong>，<font style="color:red">Unsafe类中的方法都是native方法，通过使用JNI的方式访问本地C++库。</font><br />Unsafe是位于sun.misc包下，主要<strong>提供一些用于执行低级别、不安全操作的方法</strong>。这些方法在<strong>提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用</strong>。</p><p>  <font style="color:red">由于<strong>Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力</strong>，这也<strong>增加了程序发生相关指针问题的风险</strong>。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此<strong>对Unsafe的使用一定要慎重</strong>。</font></p><p>Unsafe中的方法示例：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">long objectFieldOffset(Field field)</td><td style="text-align:left">返回指定的变量在所属类中的内存偏移地址</td></tr><tr><td style="text-align:center">int arrayBaseOffset(Class arrayClass)</td><td style="text-align:left">获取数组中第一个元素的地址</td></tr><tr><td style="text-align:center">boolean compareAndSwapLong(Object obj, long offset, long expect, long update)</td><td style="text-align:left">CAS操作</td></tr><tr><td style="text-align:center">public native long getLongvolatile(Object obj, long offset</td><td style="text-align:left">获取对象obj中偏移量offset 的变量对应volatile语义的值</td></tr><tr><td style="text-align:center">void putLongvolatile(Object obj, long offset, long value)</td><td style="text-align:left">设置 obj 对象中<code>offset</code>偏移 的类型为 long 的 field 的值为 value，支持 volatile 语义</td></tr><tr><td style="text-align:center">void park(boolean isAbsolute, long time</td><td style="text-align:left">阻塞当前线程</td></tr><tr><td style="text-align:center">void unpark(Object thread</td><td style="text-align:left">唤醒调用park后阻塞的线程</td></tr><tr><td style="text-align:center">long getAndSetLong(Object obj , long offset, long update</td><td style="text-align:left">获取对象 obj 中偏移量为offset 的变量 volatile语义的当前值，并设置变量 volatile 语义的值为 update</td></tr><tr><td style="text-align:center">long getAndAddLong(Object obj, long offset, long addValue</td><td style="text-align:left">获取对象obj中偏移量为 offset 的变量 volatile 语义的当前值，并设置变量值为原始值＋addValue</td></tr></tbody></table><p><code>Unsafe</code>类尽管里面的方法都是 public 的，但是并没有办法使用它们，因为<code>AppClassLoader</code>应用程序加载器加载的，不是启动类加载器加载的，这是一种安全机制。然而可以使用<strong>反射</strong>来使用UnSafe类</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeDemo</span> &#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> O;<span class="hljs-comment">//变量</span><br><span class="hljs-keyword">static</span> Unsafe unsafe;<span class="hljs-comment">//获取Unsafe的实例</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">long</span> stateoffset;<span class="hljs-comment">//记录变量state在类unsafeDemo类中的偏移值</span><br><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>Field field;<br>            <span class="hljs-comment">//使用反射获取unsafe类的成员交量theUnsafe,</span><br>            field = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span> );<br>            field.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置为可存取</span><br>            unsafe = (unsafe) field.get(<span class="hljs-literal">null</span>);<span class="hljs-comment">//获取该变量的值//获取state在unsafeDemo中的偏移量</span><br>            stateOffset = unsafe.objectFieldoffset(UnsafeDemo.class.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>));<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printstackTrace();<br>&#125;<br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(string[] args)</span>&#123;<br>    <span class="hljs-type">UnsafeDemo</span> <span class="hljs-variable">uDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsafeDemo</span>();<br>    System.out.println( <span class="hljs-string">&quot;before CAS: &quot;</span>+uDemo.state);<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> unsafe.compareAndSwapInt(uDemo,stateoffset,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>System.out.println(success);<br>System.out.println( <span class="hljs-string">&quot;after CAS: &quot;</span>+uDemo.state);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="atomic"><a class="markdownIt-Anchor" href="#atomic"></a> Atomic</h4><p>在<code>atomic</code>包中主要有四种类型的原子更新类：原子更新基本类型、原子更新数组类型、原子更新引用和原子更新属性。<br />这些原子类都用了无锁的概念，或是直接使用<code>CAS</code>操作的线程安全类型</p><table><thead><tr><th>类名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>AtomicBoolean</td><td><strong>原子更新基本类型</strong></td><td>原子更新布尔变量</td></tr><tr><td>AtomicInteger</td><td><strong>原子更新基本类型</strong></td><td>原子更新整型变量</td></tr><tr><td>AtomicLong</td><td><strong>原子更新基本类型</strong></td><td>原子更新长整型变量</td></tr><tr><td>AtomicIntegerArray</td><td><strong>原子更新数组</strong></td><td>原子更新整型数组的某个元素</td></tr><tr><td>AtomicLongArray</td><td><strong>原子更新数组</strong></td><td>原子更新长整型数组的某个元素</td></tr><tr><td>AtomicReferenceArray</td><td><strong>原子更新数组</strong></td><td>原子更新引用类型数组的某个元素</td></tr><tr><td>AtomicReference</td><td><strong>原子更新引用类型</strong></td><td>原子更新引用类型</td></tr><tr><td>AtomicReferenceFieldUpdater</td><td><strong>原子更新引用类型</strong></td><td>原子更新引用类型里的字段</td></tr><tr><td>AtomicMarkableReference</td><td><strong>原子更新引用类型</strong></td><td>原子更新带有标记位的引用类型</td></tr><tr><td>AtomicIntegerFieldUpdater</td><td><strong>原子更新字段类</strong></td><td>原子更新整型字段</td></tr><tr><td>AtomicLongFieldUpdater</td><td><strong>原子更新字段类</strong></td><td>原子更新长整型字段</td></tr><tr><td>AtomicStampedReference</td><td><strong>原子更新字段类</strong></td><td>原子更新带有版本号的引用类型</td></tr></tbody></table><p>在原子类中有相应的操作方法，以<code>AtomicInteger</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br><br><span class="hljs-comment">//addAndGet()以原子方式将给定值添加到当前值，并在添加后返回新值。</span><br>System.out.println(<span class="hljs-string">&quot;addAndGet event: &quot;</span> + atomicInteger.addAndGet(<span class="hljs-number">2</span>));<br>System.out.println(<span class="hljs-string">&quot;addAndGet after: &quot;</span> + atomicInteger);<br><span class="hljs-comment">//getAndAdd()以原子方式将给定值添加到当前值并返回旧值。</span><br>System.out.println(<span class="hljs-string">&quot;getAndAdd event: &quot;</span> + atomicInteger.getAndAdd(<span class="hljs-number">2</span>));<br>System.out.println(<span class="hljs-string">&quot;getAndAdd after: &quot;</span> + atomicInteger);<br><span class="hljs-comment">//incrementAndGet()以原子方式将当前值递增1并在递增后返回新值。它相当于i ++操作。</span><br>System.out.println(<span class="hljs-string">&quot;incrementAndGet event: &quot;</span> + atomicInteger.incrementAndGet());<br>System.out.println(<span class="hljs-string">&quot;incrementAndGet after: &quot;</span> + atomicInteger);<br><span class="hljs-comment">//getAndIncrement()以原子方式递增当前值并返回旧值。它相当于++ i操作。</span><br>System.out.println(<span class="hljs-string">&quot;getAndIncrement event: &quot;</span> + atomicInteger.getAndIncrement());<br>System.out.println(<span class="hljs-string">&quot;getAndIncrement after: &quot;</span> + atomicInteger);<br><span class="hljs-comment">//decrementAndGet()原子地将当前值减1并在减量后返回新值。它等同于i-操作。</span><br>System.out.println(<span class="hljs-string">&quot;decrementAndGet event: &quot;</span> + atomicInteger.decrementAndGet());<br>System.out.println(<span class="hljs-string">&quot;decrementAndGet after: &quot;</span> + atomicInteger);<br><span class="hljs-comment">//getAndDecrement()以原子方式递减当前值并返回旧值。它相当于-i操作。</span><br>System.out.println(<span class="hljs-string">&quot;getAndDecrement event: &quot;</span> + atomicInteger.getAndDecrement());<br>System.out.println(<span class="hljs-string">&quot;getAndDecrement after: &quot;</span> + atomicInteger);<br></code></pre></div></td></tr></table></figure><p>每个原子类都会存在一个方法<code>compareAndSet</code>，它的作用是<font style="color:red">在多线程并发的情况下将当前状态值与旧值比较，当在某一线程修改值时，其他线程已经将该值修改了即当前状态值和旧值不一致，这时用<code>compareAndSet</code>方法就可以判断该值是否已经被修改，如果没被修改则成功赋值</font></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">do</span>&#123;<br>oldValue = atomicInt.get();<br>newValue = Math.max(oldValue, atomicInt);<br>&#125;<span class="hljs-keyword">while</span>(!largest.compareAndSet(oldValue, newValue);<br></code></pre></div></td></tr></table></figure><p>在<code>atomic</code>包下还有4个原子操作类，它们都依赖于<code>atomic</code>包中的<code>Striped64</code>实现：<br /><code>LongAdder</code>、<code>LongAccumulator</code>、<code>DoubleAdder</code>、<code>DoubleAccumulator</code>是JDK1.8提供的针对<code>long</code>和<code>double</code>类型的累加器实现，LongAdder和DoubleAdder只针对数值的增减，LongAccumulator和DoubleAccumulator针对自定义函数的增减。</p><h3 id="juc集合"><a class="markdownIt-Anchor" href="#juc集合"></a> JUC集合</h3><p><font style="color:grey">待编纂。。</font></p><h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3><p><font style="color:grey">待编纂。。</font></p><h3 id="juc工具类"><a class="markdownIt-Anchor" href="#juc工具类"></a> JUC工具类</h3><p><font style="color:grey">待编纂。。</font></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
      <tag>API</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/helloworld/notes/Java/API/Java%E9%9B%86%E5%90%88/"/>
    <url>/helloworld/notes/Java/API/Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p>参考文章：</p><ul><li><a href="https://blog.kyire.site//2021/07/02/13a54546.html">Java中的集合</a></li><li><a href="https://www.runoob.com/java/java-collections.html">菜鸟驿站-Java 集合框架</a></li><li>Map<ul><li><a href="https://blog.csdn.net/weixin_54361971/article/details/122430827">HashMap详解</a></li><li><a href="https://blog.csdn.net/qq_40050586/article/details/105851970">LinkedHashMap详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/268025265">HashTable</a></li><li><a href="https://blog.csdn.net/u013467442/article/details/105826778">WeakHashMap</a></li></ul></li><li>Queue<ul><li><a href="https://blog.csdn.net/lucklycoder/article/details/115381856">ArrayDeque类详解</a></li><li><a href="https://www.cnblogs.com/lxyit/p/9052962.html">PriorityQueue详解</a></li></ul></li><li>Set<ul><li><a href="https://blog.csdn.net/qq_44549134/article/details/109059724">TreeSet</a></li></ul></li><li>集合工具类<ul><li><a href="https://www.yiibai.com/java/java-listiterator.html">易百教程-listiterator接口</a></li><li><a href="https://www.yiibai.com/java/java_using_iterator.html">易百教程-iterator接口</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1299919855943714">Collections使用</a></li></ul></li></ul><h2 id="java集合体系"><a class="markdownIt-Anchor" href="#java集合体系"></a> #Java集合体系</h2><p>  Java 集合框架主要包括两种类型的容器，一种是**<code>Collection</code><strong>，存储一个元素集合，另一种是</strong><code>Map</code>**。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 <a href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a>、<a href="https://www.runoob.com/java/java-linkedlist.html">LinkedList</a>、<a href="https://www.runoob.com/java/java-hashset.html">HashSet</a>、LinkedHashSet、<a href="https://www.runoob.com/java/java-hashmap.html">HashMap</a>、LinkedHashMap 等等。</p><p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p><ul><li>**接口：**是代表<b style="color:red">集合的抽象数据类型</b>。例如 Collection、List、Set、Map 等。<b style="color:#00FFFF">之所以定义多个接口，是为了以不同的方式操作集合对象。</b></li><li>**实现（类）：**是<b style="color:red">集合接口的具体实现</b>。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li><li>**算法：**是实现<b style="color:red">集合接口的对象里的方法执行的一些有用的计算</b>，例如：搜索和排序。<b style="color:#00FFFF">这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现</b>。</li></ul><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB.png" alt="Java集合体系" /></p><p><strong>体系概述：</strong></p><blockquote><ul><li>整个集合框架分为两个类型：<code>Collection</code> 和 <code>Map</code>，前者是存储一系列的<strong>对象</strong>；后者是存储一系列的<strong>键值对</strong>。</li><li>在集合框架体系下，衍生出四种具体的集合类型：<code>Map</code>、<code>Set</code>、<code>List</code>、<code>Queue</code></li></ul></blockquote><h2 id="体系详解"><a class="markdownIt-Anchor" href="#体系详解"></a> #体系详解</h2><h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h3><p><code>map</code>接口定义了<b style="color:red">存储的数据结构是<code>&lt;key,value&gt;</code> 形式</b>，根据 key 映射到 value，一个 key 对应一个 value，所以 <code>key</code> 不可重复，而 <code>value</code> 可重复，key 和 value 都可以是任何引用类型的数据。</p><p>在 <code>Map</code> 接口下会将存储的方式细分为不同的种类：</p><blockquote><ul><li><code>SortedMap</code> 接口：该接口映射可以对 <code>&lt;key,value&gt;</code> 按照自己的规则进行 <strong>排序</strong>，具体实现有 TreeMap。</li><li><code>AbstractMap</code> 类：它为子类提供好一些 <strong>通用的API实现</strong>，所有的具体 Map 都会继承它。</li></ul></blockquote><h4 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h4><p>  HashMap 是一个 <strong>最通用的</strong> 利用哈希表存储元素的集合，将元素放入 HashMap 时，将 <code>key</code> 的哈希值转换为数组的 <code>索引</code> 下标 <strong>确定存放位置</strong>，查找时，根据 <code>key</code> 的哈希地址转换成数组的 <code>索引</code> 下标 <strong>确定查找位置</strong>。HashMap 的实现不是同步的，这意味着<b style="color:#00FFFF">它不是线程安全的</b>。<b style="color:#00FFFF">它的 key、value 都可以为 null</b>，此外，HashMap 中的映射不是有序的。</p><blockquote><ul><li><strong>底层结构</strong>：JDK1.8 之前 HashMap 由 数组 + 单向链表 组成，数组是 HashMap 的主体，单向链表则是主要为了解决<font style="color:#00FFFF">哈希冲突（两个对象调用的 hashCode 方法计算的哈希值经哈希函数算出来的地址被别的元素占用）</font >而存在的（“拉链法”解决冲突）。<font style="color:red">JDK1.8 以后在解决哈希冲突时有了较大的变化，当单向链表长度大于阈值（或者红黑树的边界值，默认为 8 ）并且当前数组的长度大于 64 时，此时此索引位置上的所有数据改为使用红黑树存储。</font ></li><li><strong>扩充机制</strong>：<font style="color:red">HashMap扩充的两个重要元素<code>Capacity</code>(HashMap当前长度)和<code>LoadFactory</code>(负载因子，默认值为<strong>0.75f</strong>)</font>。<font style="color:#00FFFF">当存入第<code>Capacity</code>*<code>LoadFactory</code>+1个元素时就会进行<code>resize</code>(扩容)。扩容会创建一个新的Entry空数组，长度是原来的2倍；然后遍历原<code>Entry</code>数组，把所有的<code>Entry</code>重新<code>hash</code>(长度扩大后，hash的规则也会随之改变)到新数组。</font></li><li><strong>Hash算法</strong>：…</li></ul></blockquote><h4 id="linkedhashmap"><a class="markdownIt-Anchor" href="#linkedhashmap"></a> LinkedHashMap</h4><p>  LinkedHashMap 可以看作是 <code>HashMap</code> 和 <code>LinkedList</code> 的结合：它<font style="color:red">在 HashMap 的基础上添加了一条双向链表</font>，<code>默认</code> 存储各个元素的插入顺序，但由于这条双向链表，使得 LinkedHashMap 可以实现 <b style="color:yellow"><code>LRU</code> 缓存淘汰策略<sup>1</sup></b>，因为我们可以设置这条双向链表按照 <code>元素的访问次序</code> 进行排序。</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/LinkedHashMap%E7%BB%93%E6%9E%84.png" alt="LinkedHashMap结构" /></p><blockquote><ul><li>底层维护了一条 <code>双向链表</code>，因为继承了 HashMap，所以不是线程安全的。</li><li>LinkedHashMap 可实现 <code>LRU</code> 缓存淘汰策略，其原理是通过设置 <code>accessOrder</code> 为 <code>true</code> 并重写 <code>removeEldestEntry</code> 方法定义淘汰元素时需满足的条件。</li></ul></blockquote><p><font style="color:yellow"> ① ：LRU缓存淘汰策略 简要来说就是当内存满了将优先删除长时间未使用的数据。</font></p><h4 id="treemap"><a class="markdownIt-Anchor" href="#treemap"></a> TreeMap</h4><p>  TreeMap 是 <code>SortedMap</code> 的子类，所以它<font style="color:red">具有 排序 功能</font>。它是基于 红黑树 数据结构实现的，每一个键值对 <code>&lt;key,value&gt;</code> 都是一个节点，<strong>默认情况下按照 <code>key</code> 自然排序(放入的Key必须实现<code>Comparable</code>接口)，另一种是可以通过传入定制的 <code>Comparator</code> 进行自定义规则排序</strong>。</p><ul><li><p><strong>自然排序</strong>：要求 <code>key</code> 必须实现 <code>Comparable</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">TreeMap&lt;Integer,String&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>treeMap.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;TWO&quot;</span>);<br>treeMap.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ONE&quot;</span>);<br>System.out.print(treeMap);<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">&#123;1=ONE,2=TWO&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><strong>定制排序</strong>：在初始化 TreeMap 时传入新的 <code>Comparator</code>，不要求 <code>key</code> 实现 Comparable 接口</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">TreeMap&lt;Integer,String&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;((o1,o2) -&gt; Integer.compare(o2,o1));<br>treeMap.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;TWO&quot;</span>);<br>treeMap.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ONE&quot;</span>);<br>treeMap.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Three&quot;</span>);<br>treeMap.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;Four&quot;</span>);<br>System.out.print(treeMap);<br></code></pre></div></td></tr></table></figure><p>运行结果</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">&#123;4=Four, 3=Three, 2=TWO, 1=ONE&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> HashTable</h4><p> HashTable和HashMap很相似，其底层的存储结构是 数组+单向链表 ，主要不同的是<strong>HashTable是线程安全的</strong>，很多方法都被<code>synchronized</code>修饰，但同时因为加锁导致并发效率低下，单线程环境效率也十分低；也是由于性能问题HashTable已经被淘汰。</p><p><strong>与HashMap的区别</strong>：</p><blockquote><p><strong>扩容机制</strong>：HashMap创建一个为原先2倍的数组，然后对原数组进行遍历以及rehash；HashTable扩容将创建一个原长度2倍的数组，再使用头插法将链表进行反序；</p><p><strong>结构区别</strong>：HashMap是由数组+链表形成，在JDK1.8之后链表长度大于8时转化为红黑树；而HashTable一直都是数组+链表；</p><p><strong>线程安全</strong>：Hashtable是多线程安全的，HashMap不是；</p><p><strong>遍历方式</strong>：HashMap仅支持<code>Iterator</code>的遍历方式，Hashtable支持<code>Iterator</code>和<code>Enumeration</code>两种遍历方式；</p><p><strong>继承关系</strong>：HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作；</p><p><strong>存储值</strong>：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。</p></blockquote><h4 id="weakhashmap"><a class="markdownIt-Anchor" href="#weakhashmap"></a> WeakHashMap</h4><p>  WeakHashMap 日常开发中比较少见，它是基于普通的 <code>Map</code> 实现的，而里面 <font style="color:red"><code>Entry</code> 中的键在每一次的 <code>垃圾回收</code> 都会被清除掉，所以非常适合用于存储 <strong>短暂访问</strong>、<strong>仅访问一次</strong> 的元素</font>。</p><p><font style="color:#00FFFF">WeakHashMap 内部维护了一个引用队列<code>queue</code></font>。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Reference queue for cleared WeakEntries</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br></code></pre></div></td></tr></table></figure><p><font style="color:#00FFFF">这个 <code>queue</code>里包含了所有被 <code>GC</code> 掉的键，当JVM开启 <code>GC</code> 后，如果回收掉 WeakHashMap 中的 key，会将 key 放入 queue 中，在 <code>expungeStaleEntries()</code> 中遍历 queue，把 queue 中的所有 <code>key</code> 拿出来，并在 WeakHashMap 中删除掉，以达到 <strong>同步</strong></font >。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Expunges stale entries from the table.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Object x; (x = queue.poll()) != <span class="hljs-literal">null</span>; ) &#123;<br>            <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, table.length);<br><br>                Entry&lt;K,V&gt; prev = table[i];<br>                Entry&lt;K,V&gt; p = prev;<br>                <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>                    Entry&lt;K,V&gt; next = p.next;<br>                    <span class="hljs-keyword">if</span> (p == e) &#123;<br>                        <span class="hljs-keyword">if</span> (prev == e)<br>                            table[i] = next;<br>                        <span class="hljs-keyword">else</span><br>                            prev.next = next;<br>                        <span class="hljs-comment">// Must not null out e.next;</span><br>                        <span class="hljs-comment">// stale entries may be in use by a HashIterator</span><br>                        e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help GC</span><br>                        size--;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    prev = p;<br>                    p = next;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><blockquote><ul><li>WeakHashMap的键是一种<b style="color:yellow"> <code>弱键</code><sup>2</sup></b>，放入 WeakHashMap 时，随时会被回收掉，所以不能确保某次访问元素一定存在。</li><li>它依赖普通的 <code>Map</code> 进行实现，是一个<strong>非线程安全的集合。</strong></li><li>WeakHashMap 通常作为 <strong>缓存</strong> 使用，适用存储那些 <code>只需访问一次</code>、或 <code>只需保存短暂时间</code> 的键值对。</li></ul></blockquote><p><font style="color:yellow"> ②：弱键 （<code>WeakReference</code>）:又称弱引用，被WeakReference引用时，在下个垃圾收集周期时该对象就会被回收。</font><br /><font style="color:yellow">扩展：</font><br /><font style="color:yellow">- 软引用（<code>SoftReference</code>）:被<code>SoftReference</code>指向的对象可能会被垃圾收集器回收，但是只有在JVM内存不够的情况下才会回收。</font><br /><font style="color:yellow">- 强引用（<code>StrongReference</code>）:被强引用指向的对象，绝对不会被垃圾收集器回收。</font></p><h3 id="collection"><a class="markdownIt-Anchor" href="#collection"></a> Collection</h3><p><code>Collection</code> 接口为其实现其接口的集合提供了 <strong>通用方法</strong>：</p><ul><li>添加方法：<code>add(E e)</code> / <code>addAll(Collection&lt;? extends E&gt; c)</code></li><li>删除方法：<code>remove(Object o)</code> / <code>removeAll(Collection&lt;?&gt; c)</code></li><li>查找方法：<code>contains(Object o)</code> / <code>containsAll(Collection&lt;?&gt; c)</code></li><li>查询集合自身信息；<code>size()</code> / <code>isEmpty()</code></li><li>···</li></ul><h4 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h4><p><code>List</code>接口直接继承于 Collection 接口，它定义为<font style="color:red">可以存储 <strong>重复</strong> 元素的集合，并且元素按照插入顺序 <strong>有序排列</strong>，且可以通过 <strong>索引</strong>访问指定位置的元素。</font>常见的实现有：<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code> 和 <code>Stack</code>。</p><p>List接口下也细分有不同的种类：</p><blockquote><ul><li><code>AbstractList</code>类：<font style="color:#00FFFF">内部实现了所有的 List 都需具备的功能</font>，子类可以专注于实现自己具体的操作逻辑。</li><li><code>AbstractSequentialList</code>类：<code>AbstractSequentialList</code> 继承了 <code>AbstractList</code>，在其原基础上<font style="color:#00FFFF">限制了访问元素的顺序 <strong>只能够按照顺序访问</strong>，而 <strong>不支持随机访问</strong></font>，如果需要满足随机访问的特性，则继承 AbstractList。</li></ul></blockquote><h5 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h5><p><font style="color:red">ArrayList 以 <strong>数组</strong> 作为存储结构，它是 <strong>线程不安全</strong> 的集合；具有 <strong>查询快、在数组中或头部增删慢</strong> 的特点</font>，所以它除了线程不安全这一点，其余可以替代 <code>Vector</code> ，而线程安全的 ArrayList 可以使用 <code>CopyOnWriteArrayList</code> 代替 Vector。</p><blockquote><ul><li><strong>底层结构</strong>：ArrayList 底层是使用数组作为存储结构，具有 <strong>查找快、增删慢、随机访问</strong> 的特点</li><li><strong>扩容机制</strong>：ArrayList <strong>首次扩容</strong>后其核心数组的长度为 <strong>10</strong>，集合从 <strong>第二次扩容</strong> 开始，数组长度将扩容为原来的 <strong>1.5</strong> 倍</li></ul></blockquote><h5 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h5><p><font style="color:red">LinkedList 底层采用 <strong>双向链表</strong> 数据接口存储元素，由于链表的内存地址 <strong>非连续</strong>，所以它不具备随机访问的特点，但由于它利用指针连接各个元素，所以插入、删除元素只需要 <strong>操作指针</strong>，不需要 <strong>移动元素</strong>，故具有 <strong>增删快、查询慢</strong> 的特点。</font>它也是一个<strong>非线程安全</strong>的集合。</p><p>LinkedList实现了 <code>Deque</code> 接口，使得 LinkedList 可以用作 <strong>双端队列</strong> 。<code>Node</code> 是LinkedList集合中的元素，提供了前驱指针和后继指针，还提供了一系列操作 <code>头结点</code> 和 <code>尾结点</code> 的方法，具有双端队列的特性。</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/LinkedList%E7%BB%93%E6%9E%84.png" alt="LinkedList结构" /></p><p>双向链表存储的每个节点称为一个 <code>Node</code> ， <code>Node</code> 中保存了 <code>next</code> 和 <code>prev</code> 指针，<code>item</code> 是该节点的值。在插入和删除时，时间复杂度都保持为 <code>O(1)</code></p><blockquote><ul><li><p>优势：<font style="color:red">LinkedList 底层没有 <code>扩容机制</code>，使用 <code>双向链表</code> 存储元素，所以插入和删除元素效率较高，适用于频繁操作元素的场景。</font></p></li><li><p>劣势：<font style="color:red">LinkedList 不具备 <code>随机访问</code> 的特点，查找某个元素只能从 <code>head</code> 或 <code>tail</code> 指针一个一个比较，所以 <strong>查找中间元素是效率很低</strong>。</font></p></li><li><p>查找优化：LinkedList 查找某个下标 <code>index</code> 的元素时做了优化，若 <code>index &lt; (size / 2)</code>，则从 <code>head</code> 往后查找，否则从 <code>tail</code> 开始往前查找，代码如下所示：</p>  <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 查找的下标处于链表的前半部分则从头开始找</span><br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 查找的下标处于链表的后半部分则从尾开始找</span><br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></blockquote><h5 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> Vector</h5><p><code>Vector</code> 已经是一种过时的集合了，包括继承它的 <code>Stack</code> 集合也是如此，它们都同<code>HashTable</code>一样被淘汰的原因都是因为 <strong>性能</strong> 低下。</p><blockquote><p>JDK 1.0 时代，ArrayList 还没诞生，大家都是使用 Vector 集合，但由于 Vector 的 <strong>每个操作</strong> 都被 <strong>synchronized</strong> 关键字修饰，即使在线程安全的情况下， 仍然 <strong>进行着无意义的加锁/释放锁</strong>，造成额外的性能开销，做了无用功。</p></blockquote><h5 id="stack"><a class="markdownIt-Anchor" href="#stack"></a> Stack</h5><p><font style="color:red"><code>Stack</code> 是一种 <code>后进先出（LIFO）</code> 型的集合容器。</font>如下图所示，<font style="color:#00FFFF">top 指针指向最后进入容器的元素。弹出元素时会将先栈顶元素开始移除。</font>Stack 继承了 Vector 类，提供了栈顶的压入元素操作（push）和弹出元素（pop），以及查看栈顶元素（peek）等等，但也是由于继承于 Vector，Stack 也渐渐被淘汰了。</p><p>取而代之的是 <code>Deque</code> 接口下的<code>ArrayDeque</code>，该数据结构更加完善，可靠性更好，依靠队列也可以实现 <code>LIFO</code> 的栈操作，所以优先选择 ArrayDeque 实现栈。</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Stack%E7%BB%93%E6%9E%84.png" alt="Stack结构" /></p><h4 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h4><p>队列是一种特殊的线性表，遵循先进先出、后进后出的基本原则，一般来说，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，但是java的某些队列运行在任何地方插入删除；</p><p>Queue 中提供了两套增加、删除元素的 API，当插入或删除元素失败时，会有两种不同的失败处理策略。</p><table><thead><tr><th>方法及失败策略</th><th>插入方法</th><th>删除方法</th><th>查找方法</th></tr></thead><tbody><tr><td>抛出异常</td><td>add()</td><td>remove()</td><td>get()</td></tr><tr><td>返回失败默认值</td><td>offer()</td><td>poll()</td><td>peek()</td></tr></tbody></table><ul><li><p><code>add()</code> 和 <code>offer()</code> 对比：</p><p>在队列长度大小确定的场景下，队列放满元素后，添加下一个元素时，add() 会抛出 <code>IllegalStateException</code> 异常，而 <code>offer()</code> 会返回 <code>false</code>。但是他们两个方法在插入 <strong>某些不合法的元素</strong> 时会抛出三个相同的异常：<code>ClassCastExceptioin</code>,<code>NullPointerException</code>,<code>IllegalArgumentException</code>。</p></li><li><p><code>remove()</code> 和 <code>poll()</code> 对比：</p><p>在 <strong>队列为空</strong> 的场景下：<code>remove()</code> 会抛出 <code>NoSuchElmentException</code> 异常，而 <code>poll()</code> 则返回 <code>null</code>。</p></li><li><p><code>get()</code> 和 <code>peek()</code> 对比：</p><p>在队列为空的情况，<code>get()</code> 会抛出 <code>NoSuchElementException</code> 异常，而 <code>peek()</code> 则返回 <code>null</code>。</p></li></ul><p>Queue接口下可以细分不同的种类：</p><blockquote><ul><li><p><code>Deque</code>接口：<font style="color:#00FFFF">表示双端队列（Double-ended queue），同时具备 <strong>队列</strong> 和 <strong>栈</strong> 的性质。</font>双端队列可以在头尾都具有入队和出队的功能，即双端队列则可以分别从两端插入元素、两端移除元素。</p></li><li><p><code>AbstractQueue</code>类：AbstractQueue 类中提供了各个 API 的基本实现，主要针对各个不同的处理策略给出基本的方法实现，定义在这里的作用让 子类 根据其 方法规范 （操作失败时抛出异常还是返回默认值）实现具体的业务逻辑。</p></li></ul></blockquote><h5 id="linkedlist-2"><a class="markdownIt-Anchor" href="#linkedlist-2"></a> LinkedList</h5><p>上文已经解释过LinkedList实现了<code>Deque</code> 接口，提供了针对头结点和尾结点的操作，并且每个结点都有 <strong>前驱</strong> 和 <strong>后继</strong> 指针，具备双向队列的所有特性。</p><h5 id="arraydeque"><a class="markdownIt-Anchor" href="#arraydeque"></a> ArrayDeque</h5><p><code>ArrayDeque</code>是由数组组成的双端队列，它是 <strong>无界</strong> 的双端队列，最小的容量是 <code>8</code> （JDK1.8）。在 JDK11 之后默认容量是 <code>16</code>。</p><p>ArrayDeque可以当作栈，也可以当作队列；<font style="color:#00FFFF">作为栈时比 Stack 性能好，作为队列时比 LinkedList 性能好</font>。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">boolean add(E e)</td><td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>在队列尾部添加一个元素</td></tr><tr><td style="text-align:center">boolean offer(E e)</td><td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>在队列尾部添加一个元素，并返回是否成功</td></tr><tr><td style="text-align:center">E poll()</td><td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</td></tr><tr><td style="text-align:center">E element()</td><td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>获取第一个元素，如果没有将抛出异常</td></tr><tr><td style="text-align:center">E peek()</td><td style="text-align:center"><font style="color:#00FFFF">(队列操作)</font>获取第一个元素，如果返回null</td></tr><tr><td style="text-align:center">void push(E e)</td><td style="text-align:center"><font style="color:#00FFFF">(栈操作)</font>栈顶添加一个元素</td></tr><tr><td style="text-align:center">E pop()</td><td style="text-align:center"><font style="color:#00FFFF">(栈操作)</font>移除栈顶元素,如果栈顶没有元素将抛出异常</td></tr></tbody></table><blockquote><ul><li><strong>底层结构</strong>：数组 + 双向队列，ArrayDeque的出队入队是通过头尾指针循环，利用数组实现的。</li><li><strong>扩容机制</strong>：ArrayDeque容量不足时是会扩容的，每次扩容容量增加一倍。</li></ul></blockquote><h5 id="priorityqueue"><a class="markdownIt-Anchor" href="#priorityqueue"></a> PriorityQueue</h5><p>PriorityQueue 基于 <strong>优先级堆实现</strong> 的优先级队列。这里的<strong>优先</strong>是指：<b style="color:red">根据某种规则将队列元素进行排序，每次出队时总是取出排序中的最大或者最小元素，这样的特性决定优先队列不完全遵循FIFO规则，其中排序规则可以决策元素的优先级。</b></p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTest</span>()</span> &#123;<br>    Queue&lt;Integer&gt; random = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>    <span class="hljs-comment">//按2，1，3的顺序添加元素</span><br>    random.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>); random.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>); random.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);<br>    System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;输出：&quot;</span> );<br>    <span class="hljs-built_in">int</span> rs = random.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; rs; i++) &#123;<br>       System.<span class="hljs-keyword">out</span>.print(random.<span class="hljs-keyword">remove</span>() + <span class="hljs-string">&quot;,&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码按照FIFO规则结果应该是：输出：2,1,3,</p><p>然而实际输出：输出：</p><figure class="highlight text"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">1,2,3,<br></code></pre></div></td></tr></table></figure><p><code>PriorityQueue</code>会按照自然顺序对元素进行排序，它要求元素实现 <code>Comparable</code> 接口，所以 <code>PriorityQueue</code> <strong>不允许存储 NULL 元素</strong>。</p><blockquote><ul><li><strong>底层结构</strong>：基于 优先级堆实现 的优先级队列，而堆是采用 <strong>数组</strong> 实现的。</li><li><strong>扩容机制</strong>：实例化时若未指定初始容量，默认容量为11。如果容量小于64，两倍增长扩容；否则增长50%。</li></ul></blockquote><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4><p><code>Set</code> 接口继承了 <code>Collection</code> 接口，是一个<b style="color:red">不包括重复元素</b>的集合，更确切地说，Set 中任意两个元素不会出现 <code>o1.equals(o2)</code>为<code>true</code>的情况，而且 Set <strong>至多</strong> 只能存储一个 <code>null</code> 值元素。</p><p>Set接口下细分的种类：</p><blockquote><ul><li><p><code>SortedSet</code> 接口：在 Set 的基础上扩展了 <strong>排序</strong> 的行为，所以所有实现它的子类都会拥有排序功能。</p></li><li><p><code>AbstractSet</code> 抽象类：定义在这里的方法可以将所有具体 Set 集合的 <strong>相同行为</strong> 在这里实现，<strong>避免子类包含大量的重复代码。</strong></p></li></ul></blockquote><h5 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h5><p><font style="color:red"><code>HashSet</code>是<code>Set</code>的实现类，自然其中不能存储相同的数据，存储数据时是无序的。而且HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。</font>HashSet 底层是借助 <code>HashMap</code> 实现，HashSet 中又没有额外添加同步策略所以HashSet 也是 <strong>线程不安全</strong>。</p><p>观察它的多个构造方法，本质上都是 new 一个 HashMap。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(Math.max((<span class="hljs-type">int</span>) (c.size()/<span class="hljs-number">.75f</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">16</span>));<br>        addAll(c);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity);<br>    &#125;<br><br>    HashSet(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">boolean</span> dummy) &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>其次还能看到一个 <strong>静态常量</strong><code>PRESENT</code>：使用 PRESENT 作为 HashMap 的 value 值，使用 HashSet 的开发者只需要 <strong>关注</strong> 插入的 <code>key</code>，<strong>屏蔽</strong> 了其中 HashMap 的 <code>value</code>。</p><blockquote><ul><li>底层数据结构： HashSet 和 HashMap 一样也是采用 <code>数组 + 链表 + 红黑树</code> 实现</li><li>存入 HashSet 的对象的状态 <strong>最好不要发生变化</strong>，因为有可能改变状态后，在集合内部出现两个元素 <code>o1.equals(o2) == true</code>，破坏了 <code>equals</code> 的含义。</li></ul></blockquote><h5 id="linkedhashset"><a class="markdownIt-Anchor" href="#linkedhashset"></a> LinkedHashSet</h5><p><font style="color:#00FFFF"><code>LinkedHashSet</code>继承自 <code>HashSet</code>，根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</font> LinkedHashSet插入性能略低于 HashSet，但在迭代访问Set里的全部元素时有很好的性能。</p><p>跟随<code>LinkedHashSet</code> 的构造方法可以发现它调用了父类构造方法创建了一个<code>LinkedHashMap</code>，而 <code>LinkedHashMap</code>底层又采用 HashMap + 双向链表 实现的；所以本质上 LinkedHashSet 还是使用 HashMap 实现的。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">HashSet(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">boolean</span> dummy) &#123;<br>map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>LinkedHashSet 中也没有添加额外的同步策略，所以 LinkedHashSet 集合<strong>也不是线程安全</strong> 的。</p><blockquote><ul><li>底层数据结构： 继承于 <code>HashSet</code>，初始化时创建了一个LinkedHashMap，所以它是由 HashMap + 双向链表 构成的</li><li>除了具有set集合不重复的特点，同时具有可预测的迭代顺序，也就是我们插入的顺序。</li></ul></blockquote><h5 id="treeset"><a class="markdownIt-Anchor" href="#treeset"></a> TreeSet</h5><p><font style="color:red"><code>TreeSet</code>作用是提供有序的Set集合。TreeSet也是线程不安全的，它基于TreeMap实现，TreeSet和TreeMap一样，它们的元素支持2种排序方式：自然排序或者根据提供的Comparator进行排序。</font></p><p>TreeSet中的元素<strong>必须实现Comparable接口并重写<code>compareTo()</code>方法</strong>，TreeSet判断元素是否重复 、以及确定元素的顺序 靠的都是这个方法；对于未实现Comparable的元素，程序运行时会抛出java.lang.ClassCastException类型转化异常。</p><blockquote><p>① 对于Java类库中定义的类，TreeSet可以直接对其进行存储，如String，Integer等,因为这些类已经实现了Comparable接口);<br />② 对于自定义类，如果不做适当的处理，TreeSet中只能存储一个该类型的对象实例，否则无法判断是否重复。<br />③ 关于<code>compareTo()</code>方法规则：</p><ol><li>如果将compareTo()返回值写死为0，元素值每次比较，都认为是相同的元素，这时就不再向TreeSet中插入除第一个外的新元素。所以TreeSet中就只存在插入的第一个元素。</li><li>如果将compareTo()返回值写死为1，元素值每次比较，都认为新插入的元素比上一个元素大，于是二叉树存储时，会存在根的右侧，读取时就是正序排列的。</li><li>如果将compareTo()返回值写死为-1，元素值每次比较，都认为新插入的元素比上一个元素小，于是二叉树存储时，会存在根的左侧，读取时就是倒序序排列的。</li></ol></blockquote><h2 id="集合工具类"><a class="markdownIt-Anchor" href="#集合工具类"></a> #集合工具类</h2><h4 id="iteratoriterable-listiterator"><a class="markdownIt-Anchor" href="#iteratoriterable-listiterator"></a> Iterator，Iterable &amp; ListIterator</h4><ul><li><p><code>Iterator</code> 接口：迭代器（Iterator）有时又称为游标（cursor），是<strong>单向迭代器</strong>，<font style="color : red">用于遍历Collection集合中的元素，Collection接口中的iterator方法能够直接提供Iterator实例化的对象。它能访问一个容器（container）对象中各个元素，而又不暴露该对象的内部细节。</font></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>提供的API接口含义如下：</p><ul><li><code>hasNext()</code> ：判断集合中是否存在下一个对象</li><li><code>next()</code> ：返回集合中的下一个对象，并将访问指针移动一位</li><li><code>remove()</code> ：删除集合中调用 <code>next()</code> 方法返回的对象</li></ul><p>在早期，遍历集合的方式只有一种，通过 <code>Iterator</code> 迭代器操作：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Iterator&lt;Integer&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>    System.out.println(next);<br>    <span class="hljs-keyword">if</span>(next==<span class="hljs-number">2</span>)&#123;iterator.remove();&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>Iterable</code> 接口主要是为为集合类提供for-each循环的支持，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// JDK1.8</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p><code>ListIterator</code>和<code>Iterator</code>一样也是Java迭代器，<font style="color : red">它扩展了<code>Iterator</code>接口，且仅对<code>List</code>实现的类有用。</font></p><p><code>ListIterator</code>&amp;<code>Iterator</code>区别：</p><ul><li><code>ListIterator</code>仅对<code>List</code>实现的类有用，<code>Iterator</code>作用在<code>Collection</code>实现的类。</li><li><code>ListIterator</code>支持四种操作：<font style="color:yellow"><code>CRUD</code><sup>3</sup>(<code>CREATE</code>，<code>READ</code>，<code>UPDATE</code>和<code>DELETE</code>)</font>。</li><li><code>ListIterator</code>是一个双向迭代器，它支持正向和反向迭代。</li><li><code>ListIterator</code>没有当前元素; 它的光标位置总是位于调用<code>previous()</code>返回的元素和调用<code>next()</code>返回的元素之间。</li></ul><p><font style="color:yellow">③：可以对List对象的元素进行增删改查操作</font></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void add(E e)</code></td><td>将指定的元素插入列表中。</td></tr><tr><td><code>boolean hasNext()</code></td><td>如果此列表迭代器在向前遍历列表时具有元素，则返回<code>true</code>。</td></tr><tr><td><code>boolean hasPrevious()</code></td><td>如果此列表迭代器在反向遍历列表时具有元素，则返回<code>true</code>。</td></tr><tr><td><code>E next()</code></td><td>返回列表中的下一个元素。</td></tr><tr><td><code>int nextIndex()</code></td><td>返回元素的索引。</td></tr><tr><td><code>E previous()</code></td><td>返回列表中的上一个元素并向后移动光标位置。</td></tr><tr><td><code>int previousIndex()</code></td><td>返回元素的索引。</td></tr><tr><td><code>void remove()</code></td><td>从列表中删除由<code>next()</code>或<code>previous()</code>返回的最后一个元素。</td></tr><tr><td><code>void set(E e)</code></td><td>用指定的元素替换由<code>next()</code>或<code>previous()</code>返回的最后一个元素。</td></tr></tbody></table><p><code>ListIterator</code>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListIteratorDemo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    names.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>    names.add(<span class="hljs-string">&quot;Rust&quot;</span>);<br><br>    <span class="hljs-comment">// 获取ListIterator</span><br>    ListIterator&lt;String&gt; namesIterator = names.listIterator();<br><br>    <span class="hljs-comment">// 遍历元素</span><br>    <span class="hljs-keyword">while</span>(namesIterator.hasNext())&#123;<br>       System.out.println(namesIterator.next());<br>    &#125;<br>      <br>    <span class="hljs-comment">// 反向遍历元素</span><br>    <span class="hljs-keyword">while</span>(namesIterator.hasPrevious())&#123;<br>  System.out.println(namesIterator.previous());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="collections"><a class="markdownIt-Anchor" href="#collections"></a> Collections</h4><p>Collections是JDK提供的集合工具类，提供了一系列的静态方法，能更方便的操作各种集合。</p><ul><li><p>创建空集合，<code>Collections</code>提供了一系列方法创建空集合：</p><blockquote><p>List<T> emptyList()，创建空List</p><p>Map&lt;K, V&gt; emptyMap()，创建空Map</p><p>Set<T> emptySet()，创建空Set</p></blockquote><p><font style="color:red">这些返回的空集合是不可变集合，无法向其中添加或删除元素。</font>其实在<font style="color:#007777"><strong>Java9以后各个集合接口也提供了<code>of()</code>方法</strong></font>创建空集合：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list1 = List.of();<br><span class="hljs-comment">//of方法等同于Collections.emptyList();</span><br>List&lt;String&gt; list2 = Collections.emptyList();<br></code></pre></div></td></tr></table></figure></li><li><p>创建单元素集合</p><blockquote><p>List<T> singletonList(T o)，创建单个元素List</p><p>Map&lt;K, V&gt; singletonMap(K key, V value)，创建单个元素Map</p><p>Set<T> singleton(T o)，创建单个元素Set</p></blockquote><p>各个集合接口也提供的<code>of()</code>方法也可以实现，因为<code>of()</code>可以创建任意元素集合：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Collections创建单个元素方法</span><br>List&lt;String&gt; list1 = Collections.singletonList(<span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-comment">//of方法创建任意元素的集合</span><br>List&lt;String&gt; list2 = List.of(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>排序</p><p><code>Collections</code>可以对<code>List</code>进行排序。因为排序会直接修改<code>List</code>元素的位置，因此必须传入可变<code>List</code>：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; list = List.of(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">// 排序前:</span><br>System.out.println(list);<br>Collections.sort(list);<br><span class="hljs-comment">// 排序后:</span><br>System.out.println(list);<br></code></pre></div></td></tr></table></figure></li><li><p>乱序</p><p><code>Collections</code>提供了洗牌算法，即传入一个有序的<code>List</code>，可以随机打乱<code>List</code>内部元素的顺序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>list.add(i);<br>&#125;<br><span class="hljs-comment">// 乱序前:</span><br>System.out.println(list);<br>Collections.shuffle(list);<br><span class="hljs-comment">// 乱序后:</span><br>System.out.println(list);<br></code></pre></div></td></tr></table></figure></li><li><p>不可变集合</p><p><code>Collections</code>提供了一组方法把可变集合封装成不可变集合：</p><blockquote><ul><li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li><li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li><li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li></ul></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Java9以上才可用</span><br>List&lt;String&gt; mutable = List.of(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-comment">// 变为不可变集合</span><br>List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);<br>immutable.add(<span class="hljs-string">&quot;C&quot;</span>); <span class="hljs-comment">// 抛出错误UnsupportedOperationException!</span><br></code></pre></div></td></tr></table></figure><p>然而对原始的可变List进行增删会直接影响到封装后的List</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Java9以上才可用</span><br>List&lt;String&gt; mutable = List.of(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-comment">// 变为不可变集合</span><br>List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);<br>mutable.add(<span class="hljs-string">&quot;C&quot;</span>);<br>System.out.println(immutable);<br></code></pre></div></td></tr></table></figure><p>所以，如果我们需要封装一个不可变集合，在返回不可变后最好立刻扔掉原来可变List的引用：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; mutable = List.of(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-comment">// 变为不可变集合</span><br>List&lt;String&gt; immutable1 = Collections.unmodifiableList(mutable);<br><span class="hljs-comment">// 立刻扔掉mutable的引用</span><br>mutable = <span class="hljs-literal">null</span>;<br>System.out.println(immutable1);<br></code></pre></div></td></tr></table></figure></li><li><p><font style="color:grey">线程安全集合，<code>Collections</code>提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</font></p><blockquote><ul><li>变为线程安全的List：<code>List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li><li>变为线程安全的Set：<code>Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li><li>变为线程安全的Map：<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li></ul></blockquote><p>Java后来引入了更高效的并发集合类，所以上述这几个转变线程安全集合方法已经没有什么用了</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/helloworld/notes/Java/JVM/"/>
    <url>/helloworld/notes/Java/JVM/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> #前言</h2><p><font style="color:grey">待完善。</font></p><p>参考文章：</p><ul><li><p><a href="https://blog.kyire.site/2021/05/06/eb9166f8.html">JVM探究</a></p></li><li><p><a href="https://blog.csdn.net/qq_41644234/article/details/117733410">JVM详解-栈&amp;堆</a></p></li><li><p><a href="https://blog.csdn.net/xtayfjpk/article/details/41924283?utm_source=tuicool&amp;utm_medium=referral">深入理解Java虚拟机笔记—运行时栈帧结构</a></p></li><li><p><a href="https://blog.csdn.net/zuodaoyong/article/details/106560472">JVM堆详解</a></p></li><li><p><a href="https://www.joshua317.com/article/189">Java 类和对象在内存中的表现形式</a></p></li><li><p>Java虚拟机详解</p><ol><li><a href="https://www.cnblogs.com/qianguyihao/p/4736162.html">常用JVM配置参数</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4744233.html">GC算法和种类</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4748313.html">垃圾收集器及GC参数</a></li></ol></li><li><p><a href="https://blog.csdn.net/Littewood/article/details/123327233">JVM之本地方法接口和本地方法栈</a></p></li></ul><h2 id="jvm体系结构"><a class="markdownIt-Anchor" href="#jvm体系结构"></a> #JVM体系结构</h2><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/JVM%E4%BD%93%E7%B3%BB.png" alt="JVM体系" /></p><h2 id="类加载过程"><a class="markdownIt-Anchor" href="#类加载过程"></a> #类加载过程</h2><p>  <b style="color:red">类加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象</b>，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。<br />  <b style="color:#00FFFF">类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。</b>除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程" /></p><p><strong>双亲委派机制</strong></p><p>  <b style="color:red">当某个类加载器需要加载某个<code>.class</code>文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。</b></p><p>各种类加载器的区别：</p><p><strong>BootstrapClassLoader（启动类加载器）</strong></p><p><code>c++</code>编写，加载<code>java</code>核心库 <code>java.*</code>,构造<code>ExtClassLoader</code>和<code>AppClassLoader</code>。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作</p><p><strong>ExtClassLoader （标准扩展类加载器）</strong></p><p><code>java</code>编写，加载扩展库，如<code>classpath</code>中的<code>jre</code> ，<code>javax.*</code>或者<br /><code>java.ext.dir</code> 指定位置中的类，开发者可以直接使用标准扩展类加载器。</p><p><strong>AppClassLoader（系统类加载器）</strong></p><p><code>java</code>编写，加载程序所在的目录，如<code>user.dir</code>所在的位置的`class</p><p><strong>CustomClassLoader（用户自定义类加载器）</strong></p><p><code>java</code>编写,用户自定义的类加载器,可加载指定路径的<code>class</code>文件</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt="双亲委派" /></p><p>双亲委派作用：</p><ol><li><b style="color:red">防止重复加载同一个<code>.class</code></b>。通过委托去向上面查找，加载过了，就不用再加载一遍。保证数据安全。</li><li><b style="color:red">保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了</b>。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ol><h2 id="运行时数据区"><a class="markdownIt-Anchor" href="#运行时数据区"></a> #运行时数据区</h2><h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3><p>栈是一种数据结构，只能在一端进行插入和删除操作的特殊线性表。它<b style="color:red">按照后进先出的原则存储数据</b>，<b style="color:#00FFFF">先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据(最后一个数据被第一个读出来)</b>。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p><p><strong>JVM中的栈</strong>：Oracle关于<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html">栈和栈帧</a>提供了如下描述：</p><blockquote><p><u>每个JVM线程拥有一个私有的 Java虚拟机栈，创建线程的同时栈也被创建。一个JVM栈由许多帧组成，称之为&quot;栈帧&quot;。</u>JVM中的栈和C等常见语言中的栈比较类似，都用于保存局部变量和部分计算结果，同时也参与方法调用和返回。</p></blockquote><p>如Oracle官方说明，<strong>每个线程拥有自己的私有栈</strong>，因此在多线程应用中将有多个栈，<strong>每个栈有自己的栈帧</strong>。</p><p><strong>Java中的栈</strong>：</p><ul><li>当一个新的线程创建时，JVM会为这个线程创建一个新的Stack。一个Java Stack在一个个独立的栈帧中存储了线程的状态。<b style="color:red">JVM只会在Java Stack中做两个操作：push 和 pop.</b></li><li>一个线程当前正在执行的方法称之为线程的 <u>当前方法</u>，当前方法对应的栈帧称为 <u>当前帧</u>，当前方法所属的类称为 <u>当前类</u>，当前类的常量池称为 当前常量池。 <strong>在执行一个方法时，JVM会保存当前类和当前常量池的轨迹。当JVM执行 需要操作栈帧中数据的指令时，JVM会在当前栈帧进行处理。</strong></li><li>当一个线程执行一个Java方法时，JVM将创建一个新的栈帧并且把它push到栈顶。此时新的栈帧就变成了当前栈帧，<u>方法执行时，使用栈帧来存储参数、局部变量、中间指令以及其他数据</u>。</li></ul><p><b style="color:red">栈内存，主管程序的运行，生命周期和线程同步</b></p><p><b style="color:red">线程结束，栈内存释放，对于栈来说，不存在垃圾回收</b></p><p><strong>栈&amp;栈帧详解(简单了解)</strong>：</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/Java%E6%A0%88&amp;%E6%A0%88%E5%B8%A7.png" alt="Java栈&amp;栈帧" /></p><ul><li><p><strong>局部变量表</strong></p><p>局部变量表是一组<strong>变量值存储</strong>空间，<b style="color:red">用于存放方法参数和方法内部定义的局部变量</b>。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。</p><blockquote><p>  在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字<code>this</code>来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量<code>Slot</code>，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的<code>Slot</code>。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的<code>Slot</code>就可以交给其它变量使用。<br />  局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。</p></blockquote></li><li><p>操作数栈</p><p>当一个方法刚刚执行的时候，这个方法的操作数栈是空的，**在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。**例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。</p><blockquote><p>   操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意Java数据类型，包括<code>long</code>和<code>double</code>。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个”字宽“占4个字节，对于64位虚拟机来说，一个”字宽“占8个字节。<br />  另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了。</p></blockquote></li><li><p>动态连接</p><p><strong>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用</strong>，持有这个引用是为了支持方法调用过程中的动态连接。</p><blockquote><p>  在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为<strong>动态连接</strong>。</p></blockquote></li><li><p>方法返回地址</p><p>当一个方法被执行后，有两种方式退出这个方法。</p><ol><li><p>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。</p></li><li><p>在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。</p></li></ol><blockquote><p>  无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。<br />  方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。</p></blockquote></li><li><p>附加信息</p><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。</p></li></ul><h3 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h3><ul><li>一个JVM实例只存在一个堆内存，堆也是<b style="color:red">Java内存管理的核心区域。</b></li><li><b style="color:red">Java堆在JVM启动的时候被创建，其空间大小也就确定了。</b>是JVM管理的最大的一块内存空间。</li><li><b style="color:red">堆可以处于物理上不连续的内存空间中，但在逻辑上为连续的。</b></li><li>所有线程共享堆，还可以划分线程私有的缓冲区（TLAB）</li><li><strong>堆内存中主要存放数据是 类的成员变量，实例对象等</strong></li></ul><p><strong>堆空间分代思想</strong>：</p><p>  为什么需要分代？<br />  分代唯一的理由是优化GC(垃圾回收机制)性能，如果没有分代，那所有的对象都在一起，GC的时候要找到哪些对象没用，这样就会在堆的所有区域进行扫描。</p><blockquote><p>Java 7及之前堆内存逻辑上分三部分：<strong>新生区+养老区+<b style="color:red">永久区</b></strong><br />Java 8及之后堆内存逻辑上分为：<strong>新生区+养老区+<b style="color:red">元空间</b></strong></p></blockquote><ul><li><p>新生代（新生区）</p><p>主要是用来存放新生的对象。一般占据堆的1/3空间。</p><p>新生代又分为 <strong>Eden区、ServivorFrom、ServivorTo</strong>三个区。</p><ul><li>Eden区：<b style="color:red">Java新对象的出生地</b><b style="color:#00FFFF">（如果新创建的对象占用内存很大，则直接分配到老年代）</b>。当Eden区内存不够的时候就会触发<b style="color:yellow">MinorGC<sup>1</sup></b>，对新生代区进行一次垃圾回收。</li><li>ServivorTo：保留了一次<b style="color:yellow">MinorGC<sup>1</sup></b>过程中的幸存者。</li><li>ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。</li></ul></li><li><p>老年代（养老区）</p><p>在进行<b style="color:yellow">MajorGC<sup>2</sup></b>前一般都先进行了一次<b style="color:yellow">MinorGC<sup>1</sup></b>，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次<b style="color:yellow">MajorGC<sup>2</sup></b>进行垃圾回收腾出空间。</p></li><li><p>永久代（永久区/元空间）</p><p>指<strong>内存的永久保存区域</strong>，主要存放Class和Meta（元数据）的信息。</p><p>Class在被加载的时候被放入永久区域。它和和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。</p><p><strong>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</strong></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过<b style="color:red">元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</b>因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory，字符串池和类的静态变量放入 堆 中。这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p><p><font style="color:yellow">①：MinorGC，也称轻GC，采用复制算法。</font><br /><font  style="color:yellow">②：MajorGC，也称重GC，采用标记—清除算法。</font></p></li></ul><h3 id="方法区"><a class="markdownIt-Anchor" href="#方法区"></a> 方法区</h3><p>**方法区跟堆一样，又被称为静态区，通常存放常量数据。它存储已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等,它跟堆一样，被所有的线程共享。**但是<b style="color:red">实例变量存在堆内存中，和方法区无关！</b></p><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名称( java.lang.Object除外，其他类型若没有声明父类，默认父类是Object)</li><li>这个类型的修饰符(public、abstract、final的某个子集)</li><li>这个类型直接接口的一个有序列表</li></ul><p><strong>除此之外还方法区（Method Area）存储类信息还有</strong></p><ul><li>类型的常量池( constant pool)</li><li>域(Field)信息</li><li>方法(Method)信息</li><li>除了常量外的所有静态(static)变量</li></ul><h3 id="程序计数器"><a class="markdownIt-Anchor" href="#程序计数器"></a> 程序计数器</h3><p>每个线程都有一个程序计数器，是线程私有的，就是一个指针, 指向方法区中的方法字节码(用来存储指向像一条指令的地址， 也即将要执行的指令代码)，在执行引擎读取下一条指令, 是一个非常小的内存空间，几乎可以忽略不计。</p><p><font style="color:grey">待完善</font></p><h3 id="垃圾回收机制gc"><a class="markdownIt-Anchor" href="#垃圾回收机制gc"></a> 垃圾回收机制(GC)</h3><p>垃圾回收是指<strong>对在系统运行过程当中所产生的一些无用的对象回收，如果这些对象一直占据着内存空间，长期不被释放，可能导致内存溢出(OOM)</strong>。</p><p>Java中，<strong>GC的对象是Java堆和方法区</strong>：</p><blockquote><p>  内存区域中的<strong>程序计数器、虚拟机栈、本地方法栈</strong>这3个区域随着线程而生，线程而灭；<strong>栈中的栈帧</strong>随着方法的进入和退出，每个栈帧中分配多少内存基本是<strong>在类结构确定下来时就已知的。在这几个区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了</strong>。<br />  而<strong>Java堆和方法区</strong>则不同，一个接口中的多个实现类需要的内存可能不同，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，<strong>这部分内存的分配和回收都是动态的</strong>，GC关注的也是这部分内存。</p></blockquote><p>垃圾回收机制算法：<sub>GC算法种类很多，本文只简单介绍几种</sub></p><ul><li><p><strong>引用计数算法</strong></p><p><b style="color:#00FFFF">给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</b></p><p>缺陷：</p><ol><li><p>引用和去引用伴随加法和减法，影响性能。</p></li><li><p><b style="color:red">对于循环引用的对象无法进行回收</b></p></li></ol><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95.png" alt="引用计数算法" /></p></li><li><p><strong>根搜索算法</strong></p><p><b style="color:#00FFFF">设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。</b></p><p>从根（GC Roots）的对象作为起始点，开始向下搜索，搜索所走过的路径称为“<strong>引用链</strong>”，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<b style="color:#00FFFF">此逻辑称为可达性分析</b>。</p><p>而对于<strong>根搜索算法</strong>中的**根(GC Roots)**大致分为以下几种：</p><blockquote><ol><li><p>栈（栈帧中的本地变量表）中引用的对象。<strong>[本地变量表]</strong></p></li><li><p>本地方法栈中JNI（一般说的Native方法）引用的对象。<strong>[本地变量表]</strong></p></li><li><p><strong>方法区</strong>中的常量引用的对象（全局变量）</p></li><li><p><strong>方法区</strong>中的静态成员。</p></li></ol></blockquote><p><b style="color:red">在根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，分别是复制算法、标记-清除算法、标记-整理**算法。这三种算法都扩充了根搜索算法。</b></p></li><li><p><strong>复制算法</strong></p><p>原有的内存空间分为两块，每次只使用其中一块，<b style="color:#00FFFF">在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收</b>。</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法" /></p><p>缺陷：</p><p><strong>复制算法使得每次都只对整个半区进行内存回收</strong>，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。虽然实现简单，运行高效。但是这种算法的代价是将内存缩小为原来的一半。</p></li><li><p><strong>标记-清除算法</strong></p><p>标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：<b style="color:yellow">标记阶段</b>和<b style="color:yellow">清除阶段</b>。一种可行的实现是，在标记阶段，<strong>首先通过根节点，标记所有从根节点开始的可达对象</strong>。因此，未被标记的对象就是未被引用的垃圾对象；然后，在清除阶段，清除所有未被标记的对象。</p><ul><li>标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</li><li>清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</li></ul><p><b style="color:red">当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。</b></p><p><b style="color:#00FFFF">暂停程序运行是必须的！为了防止标记清除算法运行过程中，程序新创建对象进入内存，从而错过标记阶段使这个新对象直接在清除阶段被清除。所以需要停止程序运行！</b></p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记-清除算法" /></p><p>缺陷：</p><ol><li><strong>效率较低（递归与全堆对象遍历）</strong></li><li><strong>这种方式清理出来的空闲内存是不连续的</strong></li></ol></li><li><p><strong>标记-整理算法</strong></p><p>标记-压缩算法适合用于存活对象较多的场合。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记；<b style="color:#00FFFF">但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端；再清理边界外所有的空间。</b></p><ul><li>标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。</li><li>整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</li></ul><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记-整理算法" /></p><p>缺陷：</p><p>标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。</p><p><strong>标记-清除算法、复制算法、标记整理算法的总结：</strong></p><blockquote><p>（1）<strong>效率</strong>：<strong>复制算法</strong>&gt;标记/整理算法&gt;标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。</p><p>（2）<strong>内存整齐度</strong>：复制算法=标记/整理算法&gt;标记/清除算法。</p><p>（3）内存利用率：标记/整理算法=标记/清除算法&gt;复制算法。</p></blockquote></li></ul><h3 id="native"><a class="markdownIt-Anchor" href="#native"></a> Native</h3><ul><li>native :凡是带了native关键字的，说明Java的作用范围达不到了，回去调用底层c语言的库！它的初衷也是为了融合C/C++程序</li><li>调用本地方法本地接口 JNI (Java Native Interface)</li><li>JNI作用:开拓Java的使用，融合不同的编程语言为Java所用!最初: <code>C</code>、<code>C++</code></li><li>它在内存区域中专门开辟了一块标记区域: Native Method Stack，登记native方法</li><li>在最终执行的时候，加载本地方法库中的方法通过JNI</li><li><font style="color:grey">待完善</font></li></ul><h3 id="native-method-stack本地方法栈"><a class="markdownIt-Anchor" href="#native-method-stack本地方法栈"></a> Native Method Stack(本地方法栈)</h3><p><b style="color:#00FFFF">Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</b></p><p><strong>本地方法栈，也是线程私有的。</strong></p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li><p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。</p></li><li><p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</p></li></ul><p>本地方法是使用C语言实现的。</p><p><font style="color:grey">待完善</font></p><p><strong>具体做法：Native Method Stack中登记native方法，在执行引擎(Execution Engine)执行时加载本地方法库</strong></p><p><font style="color:grey">待完善。。</font></p><h2 id="执行引擎"><a class="markdownIt-Anchor" href="#执行引擎"></a> #执行引擎</h2><h3 id="native-interface本地方法接口"><a class="markdownIt-Anchor" href="#native-interface本地方法接口"></a> Native Interface(本地方法接口)</h3><p>简单地讲，一个Native Method是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p><img src="https://c1thulhu.oss-cn-shanghai.aliyuncs.com/notes_SCSX/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%A6%82%E8%A6%81%E5%9B%BE.png" alt="本地方法运行概要图" /></p><p><font style="color:grey">待完善。</font></p><h2 id="jvm调优"><a class="markdownIt-Anchor" href="#jvm调优"></a> #JVM调优</h2><p><font style="color:grey">待编纂。。</font></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
